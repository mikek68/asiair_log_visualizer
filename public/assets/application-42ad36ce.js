var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/@rails/actioncable/src/adapters.js
var adapters_default;
var init_adapters = __esm({
  "node_modules/@rails/actioncable/src/adapters.js"() {
    adapters_default = {
      logger: typeof console !== "undefined" ? console : void 0,
      WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
    };
  }
});

// node_modules/@rails/actioncable/src/logger.js
var logger_default;
var init_logger = __esm({
  "node_modules/@rails/actioncable/src/logger.js"() {
    init_adapters();
    logger_default = {
      log(...messages) {
        if (this.enabled) {
          messages.push(Date.now());
          adapters_default.logger.log("[ActionCable]", ...messages);
        }
      }
    };
  }
});

// node_modules/@rails/actioncable/src/connection_monitor.js
var now, secondsSince, ConnectionMonitor, connection_monitor_default;
var init_connection_monitor = __esm({
  "node_modules/@rails/actioncable/src/connection_monitor.js"() {
    init_logger();
    now = () => (/* @__PURE__ */ new Date()).getTime();
    secondsSince = (time) => (now() - time) / 1e3;
    ConnectionMonitor = class {
      constructor(connection) {
        this.visibilityDidChange = this.visibilityDidChange.bind(this);
        this.connection = connection;
        this.reconnectAttempts = 0;
      }
      start() {
        if (!this.isRunning()) {
          this.startedAt = now();
          delete this.stoppedAt;
          this.startPolling();
          addEventListener("visibilitychange", this.visibilityDidChange);
          logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
        }
      }
      stop() {
        if (this.isRunning()) {
          this.stoppedAt = now();
          this.stopPolling();
          removeEventListener("visibilitychange", this.visibilityDidChange);
          logger_default.log("ConnectionMonitor stopped");
        }
      }
      isRunning() {
        return this.startedAt && !this.stoppedAt;
      }
      recordMessage() {
        this.pingedAt = now();
      }
      recordConnect() {
        this.reconnectAttempts = 0;
        delete this.disconnectedAt;
        logger_default.log("ConnectionMonitor recorded connect");
      }
      recordDisconnect() {
        this.disconnectedAt = now();
        logger_default.log("ConnectionMonitor recorded disconnect");
      }
      // Private
      startPolling() {
        this.stopPolling();
        this.poll();
      }
      stopPolling() {
        clearTimeout(this.pollTimeout);
      }
      poll() {
        this.pollTimeout = setTimeout(
          () => {
            this.reconnectIfStale();
            this.poll();
          },
          this.getPollInterval()
        );
      }
      getPollInterval() {
        const { staleThreshold, reconnectionBackoffRate } = this.constructor;
        const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
        const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
        const jitter = jitterMax * Math.random();
        return staleThreshold * 1e3 * backoff * (1 + jitter);
      }
      reconnectIfStale() {
        if (this.connectionIsStale()) {
          logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
          this.reconnectAttempts++;
          if (this.disconnectedRecently()) {
            logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
          } else {
            logger_default.log("ConnectionMonitor reopening");
            this.connection.reopen();
          }
        }
      }
      get refreshedAt() {
        return this.pingedAt ? this.pingedAt : this.startedAt;
      }
      connectionIsStale() {
        return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
      }
      disconnectedRecently() {
        return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
      }
      visibilityDidChange() {
        if (document.visibilityState === "visible") {
          setTimeout(
            () => {
              if (this.connectionIsStale() || !this.connection.isOpen()) {
                logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                this.connection.reopen();
              }
            },
            200
          );
        }
      }
    };
    ConnectionMonitor.staleThreshold = 6;
    ConnectionMonitor.reconnectionBackoffRate = 0.15;
    connection_monitor_default = ConnectionMonitor;
  }
});

// node_modules/@rails/actioncable/src/internal.js
var internal_default;
var init_internal = __esm({
  "node_modules/@rails/actioncable/src/internal.js"() {
    internal_default = {
      "message_types": {
        "welcome": "welcome",
        "disconnect": "disconnect",
        "ping": "ping",
        "confirmation": "confirm_subscription",
        "rejection": "reject_subscription"
      },
      "disconnect_reasons": {
        "unauthorized": "unauthorized",
        "invalid_request": "invalid_request",
        "server_restart": "server_restart",
        "remote": "remote"
      },
      "default_mount_path": "/cable",
      "protocols": [
        "actioncable-v1-json",
        "actioncable-unsupported"
      ]
    };
  }
});

// node_modules/@rails/actioncable/src/connection.js
var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
var init_connection = __esm({
  "node_modules/@rails/actioncable/src/connection.js"() {
    init_adapters();
    init_connection_monitor();
    init_internal();
    init_logger();
    ({ message_types, protocols } = internal_default);
    supportedProtocols = protocols.slice(0, protocols.length - 1);
    indexOf = [].indexOf;
    Connection = class {
      constructor(consumer2) {
        this.open = this.open.bind(this);
        this.consumer = consumer2;
        this.subscriptions = this.consumer.subscriptions;
        this.monitor = new connection_monitor_default(this);
        this.disconnected = true;
      }
      send(data) {
        if (this.isOpen()) {
          this.webSocket.send(JSON.stringify(data));
          return true;
        } else {
          return false;
        }
      }
      open() {
        if (this.isActive()) {
          logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
          return false;
        } else {
          const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
          logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
          if (this.webSocket) {
            this.uninstallEventHandlers();
          }
          this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
          this.installEventHandlers();
          this.monitor.start();
          return true;
        }
      }
      close({ allowReconnect } = { allowReconnect: true }) {
        if (!allowReconnect) {
          this.monitor.stop();
        }
        if (this.isOpen()) {
          return this.webSocket.close();
        }
      }
      reopen() {
        logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
        if (this.isActive()) {
          try {
            return this.close();
          } catch (error2) {
            logger_default.log("Failed to reopen WebSocket", error2);
          } finally {
            logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
            setTimeout(this.open, this.constructor.reopenDelay);
          }
        } else {
          return this.open();
        }
      }
      getProtocol() {
        if (this.webSocket) {
          return this.webSocket.protocol;
        }
      }
      isOpen() {
        return this.isState("open");
      }
      isActive() {
        return this.isState("open", "connecting");
      }
      triedToReconnect() {
        return this.monitor.reconnectAttempts > 0;
      }
      // Private
      isProtocolSupported() {
        return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
      }
      isState(...states) {
        return indexOf.call(states, this.getState()) >= 0;
      }
      getState() {
        if (this.webSocket) {
          for (let state in adapters_default.WebSocket) {
            if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
              return state.toLowerCase();
            }
          }
        }
        return null;
      }
      installEventHandlers() {
        for (let eventName in this.events) {
          const handler = this.events[eventName].bind(this);
          this.webSocket[`on${eventName}`] = handler;
        }
      }
      uninstallEventHandlers() {
        for (let eventName in this.events) {
          this.webSocket[`on${eventName}`] = function() {
          };
        }
      }
    };
    Connection.reopenDelay = 500;
    Connection.prototype.events = {
      message(event) {
        if (!this.isProtocolSupported()) {
          return;
        }
        const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
        this.monitor.recordMessage();
        switch (type) {
          case message_types.welcome:
            if (this.triedToReconnect()) {
              this.reconnectAttempted = true;
            }
            this.monitor.recordConnect();
            return this.subscriptions.reload();
          case message_types.disconnect:
            logger_default.log(`Disconnecting. Reason: ${reason}`);
            return this.close({ allowReconnect: reconnect });
          case message_types.ping:
            return null;
          case message_types.confirmation:
            this.subscriptions.confirmSubscription(identifier);
            if (this.reconnectAttempted) {
              this.reconnectAttempted = false;
              return this.subscriptions.notify(identifier, "connected", { reconnected: true });
            } else {
              return this.subscriptions.notify(identifier, "connected", { reconnected: false });
            }
          case message_types.rejection:
            return this.subscriptions.reject(identifier);
          default:
            return this.subscriptions.notify(identifier, "received", message);
        }
      },
      open() {
        logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
        this.disconnected = false;
        if (!this.isProtocolSupported()) {
          logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
          return this.close({ allowReconnect: false });
        }
      },
      close(event) {
        logger_default.log("WebSocket onclose event");
        if (this.disconnected) {
          return;
        }
        this.disconnected = true;
        this.monitor.recordDisconnect();
        return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
      },
      error() {
        logger_default.log("WebSocket onerror event");
      }
    };
    connection_default = Connection;
  }
});

// node_modules/@rails/actioncable/src/subscription.js
var extend, Subscription;
var init_subscription = __esm({
  "node_modules/@rails/actioncable/src/subscription.js"() {
    extend = function(object, properties) {
      if (properties != null) {
        for (let key in properties) {
          const value = properties[key];
          object[key] = value;
        }
      }
      return object;
    };
    Subscription = class {
      constructor(consumer2, params = {}, mixin) {
        this.consumer = consumer2;
        this.identifier = JSON.stringify(params);
        extend(this, mixin);
      }
      // Perform a channel action with the optional data passed as an attribute
      perform(action, data = {}) {
        data.action = action;
        return this.send(data);
      }
      send(data) {
        return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
      }
      unsubscribe() {
        return this.consumer.subscriptions.remove(this);
      }
    };
  }
});

// node_modules/@rails/actioncable/src/subscription_guarantor.js
var SubscriptionGuarantor, subscription_guarantor_default;
var init_subscription_guarantor = __esm({
  "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
    init_logger();
    SubscriptionGuarantor = class {
      constructor(subscriptions) {
        this.subscriptions = subscriptions;
        this.pendingSubscriptions = [];
      }
      guarantee(subscription) {
        if (this.pendingSubscriptions.indexOf(subscription) == -1) {
          logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
          this.pendingSubscriptions.push(subscription);
        } else {
          logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
        }
        this.startGuaranteeing();
      }
      forget(subscription) {
        logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
        this.pendingSubscriptions = this.pendingSubscriptions.filter((s) => s !== subscription);
      }
      startGuaranteeing() {
        this.stopGuaranteeing();
        this.retrySubscribing();
      }
      stopGuaranteeing() {
        clearTimeout(this.retryTimeout);
      }
      retrySubscribing() {
        this.retryTimeout = setTimeout(
          () => {
            if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
              this.pendingSubscriptions.map((subscription) => {
                logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                this.subscriptions.subscribe(subscription);
              });
            }
          },
          500
        );
      }
    };
    subscription_guarantor_default = SubscriptionGuarantor;
  }
});

// node_modules/@rails/actioncable/src/subscriptions.js
var Subscriptions;
var init_subscriptions = __esm({
  "node_modules/@rails/actioncable/src/subscriptions.js"() {
    init_subscription();
    init_subscription_guarantor();
    init_logger();
    Subscriptions = class {
      constructor(consumer2) {
        this.consumer = consumer2;
        this.guarantor = new subscription_guarantor_default(this);
        this.subscriptions = [];
      }
      create(channelName, mixin) {
        const channel = channelName;
        const params = typeof channel === "object" ? channel : { channel };
        const subscription = new Subscription(this.consumer, params, mixin);
        return this.add(subscription);
      }
      // Private
      add(subscription) {
        this.subscriptions.push(subscription);
        this.consumer.ensureActiveConnection();
        this.notify(subscription, "initialized");
        this.subscribe(subscription);
        return subscription;
      }
      remove(subscription) {
        this.forget(subscription);
        if (!this.findAll(subscription.identifier).length) {
          this.sendCommand(subscription, "unsubscribe");
        }
        return subscription;
      }
      reject(identifier) {
        return this.findAll(identifier).map((subscription) => {
          this.forget(subscription);
          this.notify(subscription, "rejected");
          return subscription;
        });
      }
      forget(subscription) {
        this.guarantor.forget(subscription);
        this.subscriptions = this.subscriptions.filter((s) => s !== subscription);
        return subscription;
      }
      findAll(identifier) {
        return this.subscriptions.filter((s) => s.identifier === identifier);
      }
      reload() {
        return this.subscriptions.map((subscription) => this.subscribe(subscription));
      }
      notifyAll(callbackName, ...args) {
        return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
      }
      notify(subscription, callbackName, ...args) {
        let subscriptions;
        if (typeof subscription === "string") {
          subscriptions = this.findAll(subscription);
        } else {
          subscriptions = [subscription];
        }
        return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
      }
      subscribe(subscription) {
        if (this.sendCommand(subscription, "subscribe")) {
          this.guarantor.guarantee(subscription);
        }
      }
      confirmSubscription(identifier) {
        logger_default.log(`Subscription confirmed ${identifier}`);
        this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
      }
      sendCommand(subscription, command) {
        const { identifier } = subscription;
        return this.consumer.send({ command, identifier });
      }
    };
  }
});

// node_modules/@rails/actioncable/src/consumer.js
function createWebSocketURL(url) {
  if (typeof url === "function") {
    url = url();
  }
  if (url && !/^wss?:/i.test(url)) {
    const a = document.createElement("a");
    a.href = url;
    a.href = a.href;
    a.protocol = a.protocol.replace("http", "ws");
    return a.href;
  } else {
    return url;
  }
}
var Consumer;
var init_consumer = __esm({
  "node_modules/@rails/actioncable/src/consumer.js"() {
    init_connection();
    init_subscriptions();
    Consumer = class {
      constructor(url) {
        this._url = url;
        this.subscriptions = new Subscriptions(this);
        this.connection = new connection_default(this);
        this.subprotocols = [];
      }
      get url() {
        return createWebSocketURL(this._url);
      }
      send(data) {
        return this.connection.send(data);
      }
      connect() {
        return this.connection.open();
      }
      disconnect() {
        return this.connection.close({ allowReconnect: false });
      }
      ensureActiveConnection() {
        if (!this.connection.isActive()) {
          return this.connection.open();
        }
      }
      addSubProtocol(subprotocol) {
        this.subprotocols = [...this.subprotocols, subprotocol];
      }
    };
  }
});

// node_modules/@rails/actioncable/src/index.js
var src_exports = {};
__export(src_exports, {
  Connection: () => connection_default,
  ConnectionMonitor: () => connection_monitor_default,
  Consumer: () => Consumer,
  INTERNAL: () => internal_default,
  Subscription: () => Subscription,
  SubscriptionGuarantor: () => subscription_guarantor_default,
  Subscriptions: () => Subscriptions,
  adapters: () => adapters_default,
  createConsumer: () => createConsumer,
  createWebSocketURL: () => createWebSocketURL,
  getConfig: () => getConfig,
  logger: () => logger_default
});
function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
  return new Consumer(url);
}
function getConfig(name) {
  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
  if (element) {
    return element.getAttribute("content");
  }
}
var init_src = __esm({
  "node_modules/@rails/actioncable/src/index.js"() {
    init_connection();
    init_connection_monitor();
    init_consumer();
    init_internal();
    init_subscription();
    init_subscriptions();
    init_subscription_guarantor();
    init_adapters();
    init_logger();
  }
});

// app/javascript/custom/dhtmlxgantt.js
var require_dhtmlxgantt = __commonJS({
  "app/javascript/custom/dhtmlxgantt.js"(exports, module) {
    (function(yt, W) {
      typeof exports == "object" && typeof module < "u" ? W(exports) : typeof define == "function" && define.amd ? define(["exports"], W) : W((yt = typeof globalThis < "u" ? globalThis : yt || self).dhtmlxgantt = {});
    })(exports, function(yt) {
      "use strict";
      function W(t) {
        var e = 0, n = 0, i = 0, a = 0;
        if (t.getBoundingClientRect) {
          var r = t.getBoundingClientRect(), s = document.body, o = document.documentElement || document.body.parentNode || document.body, l = window.pageYOffset || o.scrollTop || s.scrollTop, d = window.pageXOffset || o.scrollLeft || s.scrollLeft, c = o.clientTop || s.clientTop || 0, u = o.clientLeft || s.clientLeft || 0;
          e = r.top + l - c, n = r.left + d - u, i = document.body.offsetWidth - r.right, a = document.body.offsetHeight - r.bottom;
        } else {
          for (; t; ) e += parseInt(t.offsetTop, 10), n += parseInt(t.offsetLeft, 10), t = t.offsetParent;
          i = document.body.offsetWidth - t.offsetWidth - n, a = document.body.offsetHeight - t.offsetHeight - e;
        }
        return { y: Math.round(e), x: Math.round(n), width: t.offsetWidth, height: t.offsetHeight, right: Math.round(i), bottom: Math.round(a) };
      }
      function Tn(t) {
        var e = false, n = false;
        if (window.getComputedStyle) {
          var i = window.getComputedStyle(t, null);
          e = i.display, n = i.visibility;
        } else t.currentStyle && (e = t.currentStyle.display, n = t.currentStyle.visibility);
        return e != "none" && n != "hidden";
      }
      function En(t) {
        return !isNaN(t.getAttribute("tabindex")) && 1 * t.getAttribute("tabindex") >= 0;
      }
      function Cn(t) {
        return !{ a: true, area: true }[t.nodeName.loLowerCase()] || !!t.getAttribute("href");
      }
      function Dn(t) {
        return !{ input: true, select: true, textarea: true, button: true, object: true }[t.nodeName.toLowerCase()] || !t.hasAttribute("disabled");
      }
      function Zt(t) {
        for (var e = t.querySelectorAll(["a[href]", "area[href]", "input", "select", "textarea", "button", "iframe", "object", "embed", "[tabindex]", "[contenteditable]"].join(", ")), n = Array.prototype.slice.call(e, 0), i = 0; i < n.length; i++) n[i].$position = i;
        for (n.sort(function(r, s) {
          return r.tabIndex === 0 && s.tabIndex !== 0 ? 1 : r.tabIndex !== 0 && s.tabIndex === 0 ? -1 : r.tabIndex === s.tabIndex ? r.$position - s.$position : r.tabIndex < s.tabIndex ? -1 : 1;
        }), i = 0; i < n.length; i++) {
          var a = n[i];
          (En(a) || Dn(a) || Cn(a)) && Tn(a) || (n.splice(i, 1), i--);
        }
        return n;
      }
      function Te() {
        var t = document.createElement("div");
        t.style.cssText = "visibility:hidden;position:absolute;left:-1000px;width:100px;padding:0px;margin:0px;height:110px;min-height:100px;overflow-y:scroll;", document.body.appendChild(t);
        var e = t.offsetWidth - t.clientWidth;
        return document.body.removeChild(t), Math.max(e, 15);
      }
      function Y(t) {
        if (!t) return "";
        var e = t.className || "";
        return e.baseVal && (e = e.baseVal), e.indexOf || (e = ""), te(e);
      }
      function bt(t, e) {
        e && t.className.indexOf(e) === -1 && (t.className += " " + e);
      }
      function Ht(t, e) {
        e = e.split(" ");
        for (var n = 0; n < e.length; n++) {
          var i = new RegExp("\\s?\\b" + e[n] + "\\b(?![-_.])", "");
          t.className = t.className.replace(i, "");
        }
      }
      function Qt(t) {
        return typeof t == "string" ? document.getElementById(t) || document.querySelector(t) || document.body : t || document.body;
      }
      var Ot;
      function Ee(t, e) {
        Ot || (Ot = document.createElement("div")), Ot.innerHTML = e;
        var n = Ot.firstChild;
        return t.appendChild(n), n;
      }
      function Ce(t) {
        t && t.parentNode && t.parentNode.removeChild(t);
      }
      function De(t, e) {
        for (var n = t.childNodes, i = n.length, a = [], r = 0; r < i; r++) {
          var s = n[r];
          s.className && s.className.indexOf(e) !== -1 && a.push(s);
        }
        return a;
      }
      function mt(t) {
        var e;
        return t.tagName ? e = t : (e = (t = t || window.event).target || t.srcElement).shadowRoot && t.composedPath && (e = t.composedPath()[0]), e;
      }
      function Z(t, e) {
        if (e) {
          for (var n = mt(t); n; ) {
            if (n.getAttribute && n.getAttribute(e)) return n;
            n = n.parentNode;
          }
          return null;
        }
      }
      function te(t) {
        return (String.prototype.trim || function() {
          return this.replace(/^\s+|\s+$/g, "");
        }).apply(t);
      }
      function ut(t, e, n) {
        var i = mt(t), a = "";
        for (n === void 0 && (n = true); i; ) {
          if (a = Y(i)) {
            var r = a.indexOf(e);
            if (r >= 0) {
              if (!n) return i;
              var s = r === 0 || !te(a.charAt(r - 1)), o = r + e.length >= a.length || !te(a.charAt(r + e.length));
              if (s && o) return i;
            }
          }
          i = i.parentNode;
        }
        return null;
      }
      function et(t, e) {
        var n = document.documentElement, i = W(e);
        return { x: t.clientX + n.scrollLeft - n.clientLeft - i.x + e.scrollLeft, y: t.clientY + n.scrollTop - n.clientTop - i.y + e.scrollTop };
      }
      function Ae(t, e) {
        const n = W(t), i = W(e);
        return { x: n.x - i.x, y: n.y - i.y };
      }
      function G(t, e) {
        if (!t || !e) return false;
        for (; t && t != e; ) t = t.parentNode;
        return t === e;
      }
      function ot(t, e) {
        if (t.closest) return t.closest(e);
        if (t.matches || t.msMatchesSelector || t.webkitMatchesSelector) {
          var n = t;
          if (!document.documentElement.contains(n)) return null;
          do {
            if ((n.matches || n.msMatchesSelector || n.webkitMatchesSelector).call(n, e)) return n;
            n = n.parentElement || n.parentNode;
          } while (n !== null && n.nodeType === 1);
          return null;
        }
        return console.error("Your browser is not supported"), null;
      }
      function Ie(t) {
        for (; t; ) {
          if (t.offsetWidth > 0 && t.offsetHeight > 0) return t;
          t = t.parentElement;
        }
        return null;
      }
      function Me() {
        return document.head.createShadowRoot || document.head.attachShadow;
      }
      function ee() {
        var t = document.activeElement;
        return t.shadowRoot && (t = t.shadowRoot.activeElement), t === document.body && document.getSelection && (t = document.getSelection().focusNode || document.body), t;
      }
      function vt(t) {
        if (!t || !Me()) return document.body;
        for (; t.parentNode && (t = t.parentNode); ) if (t instanceof ShadowRoot) return t.host;
        return document.body;
      }
      const Ne = Object.freeze(Object.defineProperty({ __proto__: null, addClassName: bt, closest: ot, getActiveElement: ee, getChildNodes: De, getClassName: Y, getClosestSizedElement: Ie, getFocusableNodes: Zt, getNodePosition: W, getRelativeEventPosition: et, getRelativeNodePosition: Ae, getRootNode: vt, getScrollSize: Te, getTargetNode: mt, hasClass: function(t, e) {
        return "classList" in t ? t.classList.contains(e) : new RegExp("\\b" + e + "\\b").test(t.className);
      }, hasShadowParent: function(t) {
        return !!vt(t);
      }, insertNode: Ee, isChildOf: G, isShadowDomSupported: Me, locateAttribute: Z, locateClassName: ut, removeClassName: Ht, removeNode: Ce, toNode: Qt }, Symbol.toStringTag, { value: "Module" })), lt = typeof window < "u" ? window : global;
      let An = class {
        constructor(t) {
          this._mouseDown = false, this._gantt = t, this._domEvents = t._createDomEventScope();
        }
        attach(t, e, n) {
          const i = this._gantt, a = t.getViewPort();
          this._originPosition = lt.getComputedStyle(a).display, this._restoreOriginPosition = () => {
            a.style.position = this._originPosition;
          }, this._originPosition === "static" && (a.style.position = "relative");
          const r = i.$services.getService("state");
          r.registerProvider("clickDrag", () => ({ autoscroll: false }));
          let s = null;
          const o = () => {
            s && (this._mouseDown = true, t.setStart(i.copy(s)), t.setPosition(i.copy(s)), t.setEnd(i.copy(s)), s = null);
          };
          this._domEvents.attach(a, "mousedown", (d) => {
            s = null;
            let c = ".gantt_task_line, .gantt_task_link";
            n !== void 0 && (c = n instanceof Array ? n.join(", ") : n), c && i.utils.dom.closest(d.target, c) || (r.registerProvider("clickDrag", () => ({ autoscroll: this._mouseDown })), e && d[e] !== true || (s = this._getCoordinates(d, t)));
          });
          const l = vt(i.$root) || document.body;
          this._domEvents.attach(l, "mouseup", (d) => {
            if (s = null, (!e || d[e] === true) && this._mouseDown === true) {
              this._mouseDown = false;
              const c = this._getCoordinates(d, t);
              t.dragEnd(c);
            }
          }), this._domEvents.attach(a, "mousemove", (d) => {
            if (e && d[e] !== true) return;
            const c = this._gantt.ext.clickDrag, u = (this._gantt.config.drag_timeline || {}).useKey;
            if (c && u && !e && d[u]) return;
            let h = null;
            if (!this._mouseDown && s) return h = this._getCoordinates(d, t), void (Math.abs(s.relative.left - h.relative.left) > 5 && o());
            this._mouseDown === true && (h = this._getCoordinates(d, t), t.setEnd(h), t.render());
          });
        }
        detach() {
          const t = this._gantt;
          this._domEvents.detachAll(), this._restoreOriginPosition && this._restoreOriginPosition(), t.$services.getService("state").unregisterProvider("clickDrag");
        }
        destructor() {
          this.detach();
        }
        _getCoordinates(t, e) {
          const n = e.getViewPort(), i = n.getBoundingClientRect(), { clientX: a, clientY: r } = t;
          return { absolute: { left: a, top: r }, relative: { left: a - i.left + n.scrollLeft, top: r - i.top + n.scrollTop } };
        }
      };
      var Le = function() {
        this._silent_mode = false, this.listeners = {};
      };
      Le.prototype = { _silentStart: function() {
        this._silent_mode = true;
      }, _silentEnd: function() {
        this._silent_mode = false;
      } };
      var In = function(t) {
        var e = {}, n = 0, i = function() {
          var a = true;
          for (var r in e) {
            var s = e[r].apply(t, arguments);
            a = a && s;
          }
          return a;
        };
        return i.addEvent = function(a, r) {
          if (typeof a == "function") {
            var s;
            if (r && r.id ? s = r.id : (s = n, n++), r && r.once) {
              var o = a;
              a = function() {
                o(), i.removeEvent(s);
              };
            }
            return e[s] = a, s;
          }
          return false;
        }, i.removeEvent = function(a) {
          delete e[a];
        }, i.clear = function() {
          e = {};
        }, i;
      };
      function nt(t) {
        var e = new Le();
        t.attachEvent = function(n, i, a) {
          n = "ev_" + n.toLowerCase(), e.listeners[n] || (e.listeners[n] = In(this)), a && a.thisObject && (i = i.bind(a.thisObject));
          var r = n + ":" + e.listeners[n].addEvent(i, a);
          return a && a.id && (r = a.id), r;
        }, t.attachAll = function(n) {
          this.attachEvent("listen_all", n);
        }, t.callEvent = function(n, i) {
          if (e._silent_mode) return true;
          var a = "ev_" + n.toLowerCase(), r = e.listeners;
          return r.ev_listen_all && r.ev_listen_all.apply(this, [n].concat(i)), !r[a] || r[a].apply(this, i);
        }, t.checkEvent = function(n) {
          return !!e.listeners["ev_" + n.toLowerCase()];
        }, t.detachEvent = function(n) {
          if (n) {
            var i = e.listeners;
            for (var a in i) i[a].removeEvent(n);
            var r = n.split(":");
            if (i = e.listeners, r.length === 2) {
              var s = r[0], o = r[1];
              i[s] && i[s].removeEvent(o);
            }
          }
        }, t.detachAllEvents = function() {
          for (var n in e.listeners) e.listeners[n].clear();
        };
      }
      var Pe = { second: 1, minute: 60, hour: 3600, day: 86400, week: 604800, month: 2592e3, quarter: 7776e3, year: 31536e3 };
      function Bt(t) {
        return Pe[t] || Pe.hour;
      }
      function kt(t, e) {
        if (t.forEach) t.forEach(e);
        else for (var n = t.slice(), i = 0; i < n.length; i++) e(n[i], i);
      }
      function Mn(t, e) {
        if (t.find) return t.find(e);
        for (var n = 0; n < t.length; n++) if (e(t[n], n)) return t[n];
      }
      function zt(t, e) {
        if (t.includes) return t.includes(e);
        for (var n = 0; n < t.length; n++) if (t[n] === e) return true;
        return false;
      }
      function ne(t) {
        return Array.isArray ? Array.isArray(t) : t && t.length !== void 0 && t.pop && t.push;
      }
      function J(t) {
        return !(!t || typeof t != "object") && !!(t.getFullYear && t.getMonth && t.getDate);
      }
      function xt(t) {
        return J(t) && !isNaN(t.getTime());
      }
      function Re(t, e) {
        var n, i = function() {
          i.$cancelTimeout(), i.$pending = true;
          var a = Array.prototype.slice.call(arguments);
          n = setTimeout(function() {
            t.apply(this, a), i.$pending = false;
          }, e);
        };
        return i.$pending = false, i.$cancelTimeout = function() {
          clearTimeout(n), i.$pending = false;
        }, i.$execute = function() {
          var a = Array.prototype.slice.call(arguments);
          t.apply(this, a), i.$cancelTimeout();
        }, i;
      }
      function it(t, e) {
        return He(t) && !He(e) && (t = "0"), t;
      }
      function He(t) {
        return t === 0;
      }
      function Tt(t, e) {
        for (var n, i, a, r = 0, s = t.length - 1; r <= s; ) if (i = +t[n = Math.floor((r + s) / 2)], a = +t[n - 1], i < e) r = n + 1;
        else {
          if (!(i > e)) {
            for (; +t[n] == +t[n + 1]; ) n++;
            return n;
          }
          if (!isNaN(a) && a < e) return n - 1;
          s = n - 1;
        }
        return t.length - 1;
      }
      class Nn {
        constructor(e, n, i) {
          var a;
          this._el = document.createElement("div"), this.defaultRender = (r, s) => {
            this._el || (this._el = document.createElement("div"));
            const o = this._el, l = Math.min(r.relative.top, s.relative.top), d = Math.max(r.relative.top, s.relative.top), c = Math.min(r.relative.left, s.relative.left), u = Math.max(r.relative.left, s.relative.left);
            if (this._singleRow) {
              const h = this._getTaskPositionByTop(this._startPoint.relative.top);
              o.style.height = h.height + "px", o.style.top = h.top + "px";
            } else o.style.height = Math.abs(d - l) + "px", o.style.top = l + "px";
            return o.style.width = Math.abs(u - c) + "px", o.style.left = c + "px", o;
          }, this._gantt = n, this._view = i, this._viewPort = e.viewPort, this._el.classList.add(e.className), typeof e.callback == "function" && (this._callback = e.callback), this.render = () => {
            let r;
            r = e.render ? e.render(this._startPoint, this._endPoint) : this.defaultRender(this._startPoint, this._endPoint), r !== this._el && (this._el && this._el.parentNode && this._el.parentNode.removeChild(this._el), this._el = r), e.className !== "" && this._el.classList.add(e.className), this.draw();
          }, (a = this._viewPort).attachEvent && a.detachEvent || nt(this._viewPort), this._singleRow = e.singleRow, this._useRequestAnimationFrame = e.useRequestAnimationFrame;
        }
        draw() {
          if (this._useRequestAnimationFrame) return requestAnimationFrame(() => {
            this._viewPort.appendChild(this.getElement());
          });
          this._viewPort.appendChild(this.getElement());
        }
        clear() {
          if (this._useRequestAnimationFrame) return requestAnimationFrame(() => {
            this._el.parentNode && this._viewPort.removeChild(this._el);
          });
          this._el.parentNode && this._viewPort.removeChild(this._el);
        }
        getElement() {
          return this._el;
        }
        getViewPort() {
          return this._viewPort;
        }
        setStart(e) {
          const n = this._gantt;
          this._startPoint = e, this._startDate = n.dateFromPos(this._startPoint.relative.left), this._viewPort.callEvent("onBeforeDrag", [this._startPoint]);
        }
        setEnd(e) {
          const n = this._gantt;
          if (this._endPoint = e, this._singleRow) {
            const i = this._getTaskPositionByTop(this._startPoint.relative.top);
            this._endPoint.relative.top = i.top;
          }
          this._endDate = n.dateFromPos(this._endPoint.relative.left), this._startPoint.relative.left > this._endPoint.relative.left && (this._positionPoint = { relative: { left: this._endPoint.relative.left, top: this._positionPoint.relative.top }, absolute: { left: this._endPoint.absolute.left, top: this._positionPoint.absolute.top } }), this._startPoint.relative.top > this._endPoint.relative.top && (this._positionPoint = { relative: { left: this._positionPoint.relative.left, top: this._endPoint.relative.top }, absolute: { left: this._positionPoint.absolute.left, top: this._endPoint.absolute.top } }), this._viewPort.callEvent("onDrag", [this._startPoint, this._endPoint]);
        }
        setPosition(e) {
          this._positionPoint = e;
        }
        dragEnd(e) {
          const n = this._gantt;
          e.relative.left < 0 && (e.relative.left = 0), this._viewPort.callEvent("onBeforeDragEnd", [this._startPoint, e]), this.setEnd(e), this._endDate = this._endDate || n.getState().max_date, this._startDate.valueOf() > this._endDate.valueOf() && ([this._startDate, this._endDate] = [this._endDate, this._startDate]), this.clear();
          const i = n.getTaskByTime(this._startDate, this._endDate), a = this._getTasksByTop(this._startPoint.relative.top, this._endPoint.relative.top);
          this._viewPort.callEvent("onDragEnd", [this._startPoint, this._endPoint]), this._callback && this._callback(this._startPoint, this._endPoint, this._startDate, this._endDate, i, a);
        }
        getInBounds() {
          return this._singleRow;
        }
        _getTasksByTop(e, n) {
          const i = this._gantt;
          let a = e, r = n;
          e > n && (a = n, r = e);
          const s = this._getTaskPositionByTop(a).index, o = this._getTaskPositionByTop(r).index, l = [];
          for (let d = s; d <= o; d++) i.getTaskByIndex(d) && l.push(i.getTaskByIndex(d));
          return l;
        }
        _getTaskPositionByTop(e) {
          const n = this._gantt, i = this._view, a = i.getItemIndexByTopPosition(e), r = n.getTaskByIndex(a);
          if (r) {
            const s = i.getItemHeight(r.id);
            return { top: i.getItemTop(r.id) || 0, height: s || 0, index: a };
          }
          {
            const s = i.getTotalHeight();
            return { top: e > s ? s : 0, height: n.config.row_height, index: e > s ? n.getTaskCount() : 0 };
          }
        }
      }
      class ie {
        constructor(e) {
          this._mouseDown = false, this._calculateDirectionVector = () => {
            if (this._trace.length >= 10) {
              const n = this._trace.slice(this._trace.length - 10), i = [];
              for (let r = 1; r < n.length; r++) i.push({ x: n[r].x - n[r - 1].x, y: n[r].y - n[r - 1].y });
              const a = { x: 0, y: 0 };
              return i.forEach((r) => {
                a.x += r.x, a.y += r.y;
              }), { magnitude: Math.sqrt(a.x * a.x + a.y * a.y), angleDegrees: 180 * Math.atan2(Math.abs(a.y), Math.abs(a.x)) / Math.PI };
            }
            return null;
          }, this._applyDndReadyStyles = () => {
            this._timeline.$task.classList.add("gantt_timeline_move_available");
          }, this._clearDndReadyStyles = () => {
            this._timeline.$task.classList.remove("gantt_timeline_move_available");
          }, this._getScrollPosition = (n) => {
            const i = this._gantt;
            return { x: i.$ui.getView(n.$config.scrollX).getScrollState().position, y: i.$ui.getView(n.$config.scrollY).getScrollState().position };
          }, this._countNewScrollPosition = (n) => {
            const i = this._calculateDirectionVector();
            let a = this._startPoint.x - n.x, r = this._startPoint.y - n.y;
            return i && (i.angleDegrees < 15 ? r = 0 : i.angleDegrees > 75 && (a = 0)), { x: this._scrollState.x + a, y: this._scrollState.y + r };
          }, this._setScrollPosition = (n, i) => {
            const a = this._gantt;
            requestAnimationFrame(() => {
              a.scrollLayoutCell(n.$id, i.x, i.y);
            });
          }, this._stopDrag = (n) => {
            const i = this._gantt;
            if (this._trace = [], i.$root.classList.remove("gantt_noselect"), this._originalReadonly !== void 0 && (i.config.readonly = this._originalReadonly, this._mouseDown && i.config.drag_timeline && i.config.drag_timeline.render && i.render()), this._originAutoscroll !== void 0 && (i.config.autoscroll = this._originAutoscroll), i.config.drag_timeline) {
              const { useKey: a } = i.config.drag_timeline;
              if (a && n[a] !== true) return;
            }
            this._mouseDown = false;
          }, this._startDrag = (n) => {
            const i = this._gantt;
            this._originAutoscroll = i.config.autoscroll, i.config.autoscroll = false, i.$root.classList.add("gantt_noselect"), this._originalReadonly = i.config.readonly, i.config.readonly = true, i.config.drag_timeline && i.config.drag_timeline.render && i.render(), this._trace = [], this._mouseDown = true;
            const { x: a, y: r } = this._getScrollPosition(this._timeline);
            this._scrollState = { x: a, y: r }, this._startPoint = { x: n.clientX, y: n.clientY }, this._trace.push(this._startPoint);
          }, this._gantt = e, this._domEvents = e._createDomEventScope(), this._trace = [];
        }
        static create(e) {
          return new ie(e);
        }
        destructor() {
          this._domEvents.detachAll();
        }
        attach(e) {
          this._timeline = e;
          const n = this._gantt;
          this._domEvents.attach(e.$task, "mousedown", (i) => {
            if (!n.config.drag_timeline) return;
            const { useKey: a, ignore: r, enabled: s } = n.config.drag_timeline;
            if (s === false) return;
            let o = ".gantt_task_line, .gantt_task_link";
            r !== void 0 && (o = r instanceof Array ? r.join(", ") : r), o && n.utils.dom.closest(i.target, o) || a && i[a] !== true || this._startDrag(i);
          }), this._domEvents.attach(document, "keydown", (i) => {
            if (!n.config.drag_timeline) return;
            const { useKey: a } = n.config.drag_timeline;
            a && i[a] === true && this._applyDndReadyStyles();
          }), this._domEvents.attach(document, "keyup", (i) => {
            if (!n.config.drag_timeline) return;
            const { useKey: a } = n.config.drag_timeline;
            a && i[a] === false && (this._clearDndReadyStyles(), this._stopDrag(i));
          }), this._domEvents.attach(document, "mouseup", (i) => {
            this._stopDrag(i);
          }), this._domEvents.attach(n.$root, "mouseup", (i) => {
            this._stopDrag(i);
          }), this._domEvents.attach(document, "mouseleave", (i) => {
            this._stopDrag(i);
          }), this._domEvents.attach(n.$root, "mouseleave", (i) => {
            this._stopDrag(i);
          }), this._domEvents.attach(n.$root, "mousemove", (i) => {
            if (!n.config.drag_timeline) return;
            const { useKey: a } = n.config.drag_timeline;
            if (a && i[a] !== true) return;
            const r = this._gantt.ext.clickDrag, s = (this._gantt.config.click_drag || {}).useKey;
            if ((!r || !s || a || !i[s]) && this._mouseDown === true) {
              this._trace.push({ x: i.clientX, y: i.clientY });
              const o = this._countNewScrollPosition({ x: i.clientX, y: i.clientY });
              this._setScrollPosition(e, o), this._scrollState = o, this._startPoint = { x: i.clientX, y: i.clientY };
            }
          });
        }
      }
      function Ln(t) {
        (function() {
          var e = [];
          function n() {
            return !!e.length;
          }
          function i(d) {
            setTimeout(function() {
              n() || t.$destroyed || t.focus();
            }, 1);
          }
          function a(d) {
            t.eventRemove(d, "keydown", s), t.event(d, "keydown", s), e.push(d);
          }
          function r() {
            var d = e.pop();
            d && t.eventRemove(d, "keydown", s), i();
          }
          function s(d) {
            var c = d.currentTarget;
            c == e[e.length - 1] && t.$keyboardNavigation.trapFocus(c, d);
          }
          function o() {
            a(t.getLightbox());
          }
          t.attachEvent("onLightbox", o), t.attachEvent("onAfterLightbox", r), t.attachEvent("onLightboxChange", function() {
            r(), o();
          }), t.attachEvent("onAfterQuickInfo", function() {
            i();
          }), t.attachEvent("onMessagePopup", function(d) {
            l = t.utils.dom.getActiveElement(), a(d);
          }), t.attachEvent("onAfterMessagePopup", function() {
            r(), setTimeout(function() {
              l && (l.focus(), l = null);
            }, 1);
          });
          var l = null;
          t.$keyboardNavigation.isModal = n;
        })();
      }
      class Pn {
        constructor(e) {
          this.show = (n, i) => {
            i === void 0 ? this._showForTask(n) : this._showAtCoordinates(n, i);
          }, this.hide = (n) => {
            const i = this._gantt, a = this._quickInfoBox;
            this._quickInfoBoxId = 0;
            const r = this._quickInfoTask;
            if (this._quickInfoTask = null, a && a.parentNode) {
              if (i.config.quick_info_detached) return i.callEvent("onAfterQuickInfo", [r]), a.parentNode.removeChild(a);
              a.className += " gantt_qi_hidden", a.style.right === "auto" ? a.style.left = "-350px" : a.style.right = "-350px", n && (a.style.left = a.style.right = "", a.parentNode.removeChild(a)), i.callEvent("onAfterQuickInfo", [r]);
            }
          }, this.getNode = () => this._quickInfoBox ? this._quickInfoBox : null, this.setContainer = (n) => {
            n && (this._container = typeof n == "string" ? document.getElementById(n) : n);
          }, this.setContent = (n) => {
            const i = this._gantt, a = { taskId: null, header: { title: "", date: "" }, content: "", buttons: i.config.quickinfo_buttons };
            n || (n = a), n.taskId || (n.taskId = a.taskId), n.header || (n.header = a.header), n.header.title || (n.header.title = a.header.title), n.header.date || (n.header.date = a.header.date), n.content || (n.content = a.content), n.buttons || (n.buttons = a.buttons);
            let r = this.getNode();
            r || (r = this._createQuickInfoElement()), n.taskId && (this._quickInfoBoxId = n.taskId);
            const s = r.querySelector(".gantt_cal_qi_title"), o = s.querySelector(".gantt_cal_qi_tcontent"), l = s.querySelector(".gantt_cal_qi_tdate"), d = r.querySelector(".gantt_cal_qi_content"), c = r.querySelector(".gantt_cal_qi_controls");
            i._waiAria.quickInfoHeader(r, [n.header.title, n.header.date].join(" ")), o.innerHTML = n.header.title, l.innerHTML = n.header.date, n.header.title || n.header.date ? s.style.display = "" : s.style.display = "none", d.innerHTML = n.content;
            const u = n.buttons;
            u.length ? c.style.display = "" : c.style.display = "none";
            let h = "";
            for (let g = 0; g < u.length; g++) {
              const f = i._waiAria.quickInfoButtonAttrString(i.locale.labels[u[g]]);
              h += `<div class="gantt_qi_big_icon ${u[g]} dhx_gantt_${u[g]}" title="${i.locale.labels[u[g]]}" ${f}>
            <div class='dhx_menu_icon dhx_gantt_icon ${u[g]} gantt_menu_icon dhx_gantt_${u[g]}'></div>
            <div>${i.locale.labels[u[g]]}</div>
         </div>`;
            }
            c.innerHTML = h, i.eventRemove(r, "click", this._qiButtonClickHandler), i.eventRemove(r, "keypress", this._qiKeyPressHandler), i.event(r, "click", this._qiButtonClickHandler), i.event(r, "keypress", this._qiKeyPressHandler);
          }, this._qiButtonClickHandler = (n) => {
            this._qi_button_click(n.target);
          }, this._qiKeyPressHandler = (n) => {
            const i = n.which;
            i !== 13 && i !== 32 || setTimeout(() => {
              this._qi_button_click(n.target);
            }, 1);
          }, this._gantt = e;
        }
        _showAtCoordinates(e, n) {
          this.hide(true), this._quickInfoBoxId = 0, this._quickInfoTask = null, this._quickInfoBox || (this._createQuickInfoElement(), this.setContent()), this._appendAtCoordinates(e, n), this._gantt.callEvent("onQuickInfo", [null]);
        }
        _showForTask(e) {
          const n = this._gantt;
          if (e === this._quickInfoBoxId && n.utils.dom.isChildOf(this._quickInfoBox, document.body) || !n.config.show_quick_info) return;
          this.hide(true);
          const i = this._getContainer(), a = this._get_event_counter_part(e, 6, i.xViewport, i.yViewport);
          a && (this._quickInfoBox = this._init_quick_info(e), this._quickInfoTask = e, this._quickInfoBox.className = this._prepare_quick_info_classname(e), this._fill_quick_data(e), this._show_quick_info(a, 6), n.callEvent("onQuickInfo", [e]));
        }
        _get_event_counter_part(e, n, i, a) {
          const r = this._gantt;
          let s = r.getTaskNode(e);
          if (!s && (s = r.getTaskRowNode(e), !s)) return null;
          let o = 0;
          const l = n + s.offsetTop + s.offsetHeight;
          let d = s;
          if (r.utils.dom.isChildOf(d, i)) for (; d && d !== i; ) o += d.offsetLeft, d = d.offsetParent;
          const c = r.getScrollState();
          return d ? { left: o, top: l, dx: o + s.offsetWidth / 2 - c.x > i.offsetWidth / 2 ? 1 : 0, dy: l + s.offsetHeight / 2 - c.y > a.offsetHeight / 2 ? 1 : 0, width: s.offsetWidth, height: s.offsetHeight } : null;
        }
        _createQuickInfoElement() {
          const e = this._gantt, n = document.createElement("div");
          n.className += "gantt_cal_quick_info", e._waiAria.quickInfoAttr(n);
          var i = `
		<div class="gantt_cal_qi_tcontrols">
			<a class="gantt_cal_qi_close_btn dhx_gantt_icon dhx_gantt_icon_close"></a>
		</div>
		<div class="gantt_cal_qi_title" ${e._waiAria.quickInfoHeaderAttrString()}>
				
				<div class="gantt_cal_qi_tcontent"></div>
				<div class="gantt_cal_qi_tdate"></div>
			</div>
			<div class="gantt_cal_qi_content"></div>`;
          if (i += '<div class="gantt_cal_qi_controls">', i += "</div>", n.innerHTML = i, e.config.quick_info_detached) {
            const a = this._getContainer();
            e.event(a.parent, "scroll", () => {
              this.hide();
            });
          }
          return this._quickInfoBox = n, n;
        }
        _init_quick_info(e) {
          const n = this._gantt, i = n.getTask(e);
          return typeof this._quickInfoReadonly == "boolean" && n.isReadonly(i) !== this._quickInfoReadonly && (this.hide(true), this._quickInfoBox = null), this._quickInfoReadonly = n.isReadonly(i), this._quickInfoBox || (this._quickInfoBox = this._createQuickInfoElement()), this._quickInfoBox;
        }
        _prepare_quick_info_classname(e) {
          const n = this._gantt, i = n.getTask(e);
          let a = `gantt_cal_quick_info gantt_${n.getTaskType(i)}`;
          const r = n.templates.quick_info_class(i.start_date, i.end_date, i);
          return r && (a += " " + r), a;
        }
        _fill_quick_data(e) {
          const n = this._gantt, i = n.getTask(e);
          this._quickInfoBoxId = e;
          let a = [];
          if (this._quickInfoReadonly) {
            const r = n.config.quickinfo_buttons, s = { icon_delete: true, icon_edit: true };
            for (let o = 0; o < r.length; o++) this._quickInfoReadonly && s[r[o]] || a.push(r[o]);
          } else a = n.config.quickinfo_buttons;
          this.setContent({ header: { title: n.templates.quick_info_title(i.start_date, i.end_date, i), date: n.templates.quick_info_date(i.start_date, i.end_date, i) }, content: n.templates.quick_info_content(i.start_date, i.end_date, i), buttons: a });
        }
        _appendAtCoordinates(e, n) {
          const i = this._quickInfoBox, a = this._getContainer();
          i.parentNode && i.parentNode.nodeName.toLowerCase() !== "#document-fragment" || a.parent.appendChild(i), i.style.left = e + "px", i.style.top = n + "px";
        }
        _show_quick_info(e, n) {
          const i = this._gantt, a = this._quickInfoBox;
          if (i.config.quick_info_detached) {
            const r = this._getContainer();
            a.parentNode && a.parentNode.nodeName.toLowerCase() !== "#document-fragment" || r.parent.appendChild(a);
            const s = a.offsetWidth, o = a.offsetHeight, l = i.getScrollState(), d = r.xViewport, c = r.yViewport, u = d.offsetWidth + l.x - s, h = e.top - l.y + o;
            let g = e.top;
            h > c.offsetHeight / 2 && (g = e.top - (o + e.height + 2 * n), g < l.y && h <= c.offsetHeight && (g = e.top)), g < l.y && (g = l.y);
            const f = Math.min(Math.max(l.x, e.left - e.dx * (s - e.width)), u), y = g;
            this._appendAtCoordinates(f, y);
          } else a.style.top = "20px", e.dx === 1 ? (a.style.right = "auto", a.style.left = "-300px", setTimeout(() => {
            a.style.left = "10px";
          }, 1)) : (a.style.left = "auto", a.style.right = "-300px", setTimeout(() => {
            a.style.right = "10px";
          }, 1)), a.className += " gantt_qi_" + (e.dx === 1 ? "left" : "right"), i.$root.appendChild(a);
        }
        _qi_button_click(e) {
          const n = this._gantt, i = this._quickInfoBox;
          if (!e || e === i) return;
          if (e.closest(".gantt_cal_qi_close_btn")) return void this.hide();
          const a = e.className;
          if (a.indexOf("_icon") !== -1) {
            const r = this._quickInfoBoxId;
            n.$click.buttons[a.split(" ")[1].replace("icon_", "")](r);
          } else this._qi_button_click(e.parentNode);
        }
        _getContainer() {
          const e = this._gantt;
          let n = this._container ? this._container : e.$task_data;
          return n && n.offsetHeight && n.offsetWidth ? { parent: n, xViewport: e.$task, yViewport: e.$task_data } : (n = this._container ? this._container : e.$grid_data, n && n.offsetHeight && n.offsetWidth ? { parent: n, xViewport: e.$grid, yViewport: e.$grid_data } : { parent: this._container ? this._container : e.$layout, xViewport: e.$layout, yViewport: e.$layout });
        }
      }
      var ae, Rn = {}.constructor.toString();
      function V(t) {
        var e, n;
        if (t && typeof t == "object") switch (true) {
          case J(t):
            n = new Date(t);
            break;
          case ne(t):
            for (n = new Array(t.length), e = 0; e < t.length; e++) n[e] = V(t[e]);
            break;
          default:
            for (e in n = function(i) {
              return i.constructor.toString() !== Rn;
            }(t) ? Object.create(t) : {}, t) Object.prototype.hasOwnProperty.apply(t, [e]) && (n[e] = V(t[e]));
        }
        return n || t;
      }
      function N(t, e, n) {
        for (var i in e) (t[i] === void 0 || n) && (t[i] = e[i]);
        return t;
      }
      function j(t) {
        return t !== void 0;
      }
      function at() {
        return ae || (ae = (/* @__PURE__ */ new Date()).valueOf()), ++ae;
      }
      function R(t, e) {
        return t.bind ? t.bind(e) : function() {
          return t.apply(e, arguments);
        };
      }
      function Oe(t, e, n, i) {
        t.addEventListener ? t.addEventListener(e, n, i !== void 0 && i) : t.attachEvent && t.attachEvent("on" + e, n);
      }
      function Be(t, e, n, i) {
        t.removeEventListener ? t.removeEventListener(e, n, i !== void 0 && i) : t.detachEvent && t.detachEvent("on" + e, n);
      }
      const Hn = Object.freeze(Object.defineProperty({ __proto__: null, bind: R, copy: V, defined: j, event: Oe, eventRemove: Be, mixin: N, uid: at }, Symbol.toStringTag, { value: "Module" }));
      function re(t, e) {
        t = t || Oe, e = e || Be;
        var n = [], i = { attach: function(a, r, s, o) {
          n.push({ element: a, event: r, callback: s, capture: o }), t(a, r, s, o);
        }, detach: function(a, r, s, o) {
          e(a, r, s, o);
          for (var l = 0; l < n.length; l++) {
            var d = n[l];
            d.element === a && d.event === r && d.callback === s && d.capture === o && (n.splice(l, 1), l--);
          }
        }, detachAll: function() {
          for (var a = n.slice(), r = 0; r < a.length; r++) {
            var s = a[r];
            i.detach(s.element, s.event, s.callback, s.capture), i.detach(s.element, s.event, s.callback, void 0), i.detach(s.element, s.event, s.callback, false), i.detach(s.element, s.event, s.callback, true);
          }
          n.splice(0, n.length);
        }, extend: function() {
          return re(this.event, this.eventRemove);
        } };
        return i;
      }
      class On {
        constructor(e) {
          this._gantt = e;
        }
        getNode() {
          const e = this._gantt;
          return this._tooltipNode || (this._tooltipNode = document.createElement("div"), this._tooltipNode.className = "gantt_tooltip", e._waiAria.tooltipAttr(this._tooltipNode)), this._tooltipNode;
        }
        setViewport(e) {
          return this._root = e, this;
        }
        show(e, n) {
          const i = this._gantt, a = document.body, r = this.getNode();
          if (G(r, a) || (this.hide(), r.style.top = r.style.top || "0px", r.style.left = r.style.left || "0px", a.appendChild(r)), this._isLikeMouseEvent(e)) {
            const s = this._calculateTooltipPosition(e);
            n = s.top, e = s.left;
          }
          return r.style.top = n + "px", r.style.left = e + "px", i._waiAria.tooltipVisibleAttr(r), this;
        }
        hide() {
          const e = this._gantt, n = this.getNode();
          return n && n.parentNode && n.parentNode.removeChild(n), e._waiAria.tooltipHiddenAttr(n), this;
        }
        setContent(e) {
          return this.getNode().innerHTML = e, this;
        }
        _isLikeMouseEvent(e) {
          return !(!e || typeof e != "object") && "clientX" in e && "clientY" in e;
        }
        _getViewPort() {
          return this._root || document.body;
        }
        _calculateTooltipPosition(e) {
          const n = this._gantt, i = this._getViewPortSize(), a = this.getNode(), r = { top: 0, left: 0, width: a.offsetWidth, height: a.offsetHeight, bottom: 0, right: 0 }, s = n.config.tooltip_offset_x, o = n.config.tooltip_offset_y, l = document.body, d = et(e, l), c = W(l);
          d.y += c.y, r.top = d.y, r.left = d.x, r.top += o, r.left += s, r.bottom = r.top + r.height, r.right = r.left + r.width;
          const u = window.scrollY + l.scrollTop;
          return r.top < i.top - u ? (r.top = i.top, r.bottom = r.top + r.height) : r.bottom > i.bottom && (r.bottom = i.bottom, r.top = r.bottom - r.height), r.left < i.left ? (r.left = i.left, r.right = i.left + r.width) : r.right > i.right && (r.right = i.right, r.left = r.right - r.width), d.x >= r.left && d.x <= r.right && (r.left = d.x - r.width - s, r.right = r.left + r.width), d.y >= r.top && d.y <= r.bottom && (r.top = d.y - r.height - o, r.bottom = r.top + r.height), r;
        }
        _getViewPortSize() {
          const e = this._gantt, n = this._getViewPort();
          let i, a = n, r = window.scrollY + document.body.scrollTop, s = window.scrollX + document.body.scrollLeft;
          return n === e.$task_data ? (a = e.$task, r = 0, s = 0, i = W(e.$task)) : i = W(a), { left: i.x + s, top: i.y + r, width: i.width, height: i.height, bottom: i.y + i.height + r, right: i.x + i.width + s };
        }
      }
      class Bn {
        constructor(e) {
          this._listeners = {}, this.tooltip = new On(e), this._gantt = e, this._domEvents = re(), this._initDelayedFunctions();
        }
        destructor() {
          this.tooltip.hide(), this._domEvents.detachAll();
        }
        hideTooltip() {
          this.delayHide();
        }
        attach(e) {
          let n = document.body;
          const i = this._gantt;
          e.global || (n = i.$root);
          let a = null;
          const r = (s) => {
            const o = mt(s), l = ot(o, e.selector);
            if (G(o, this.tooltip.getNode())) return;
            const d = () => {
              a = l, e.onmouseenter(s, l);
            };
            a ? l && l === a ? e.onmousemove(s, l) : (e.onmouseleave(s, a), a = null, l && l !== a && d()) : l && d();
          };
          this.detach(e.selector), this._domEvents.attach(n, "mousemove", r), this._listeners[e.selector] = { node: n, handler: r };
        }
        detach(e) {
          const n = this._listeners[e];
          n && this._domEvents.detach(n.node, "mousemove", n.handler);
        }
        tooltipFor(e) {
          const n = (i) => {
            let a = i;
            return document.createEventObject && !document.createEvent && (a = document.createEventObject(i)), a;
          };
          this._initDelayedFunctions(), this.attach({ selector: e.selector, global: e.global, onmouseenter: (i, a) => {
            const r = e.html(i, a);
            r && this.delayShow(n(i), r);
          }, onmousemove: (i, a) => {
            const r = e.html(i, a);
            r ? this.delayShow(n(i), r) : (this.delayShow.$cancelTimeout(), this.delayHide());
          }, onmouseleave: () => {
            this.delayShow.$cancelTimeout(), this.delayHide();
          } });
        }
        _initDelayedFunctions() {
          const e = this._gantt;
          this.delayShow && this.delayShow.$cancelTimeout(), this.delayHide && this.delayHide.$cancelTimeout(), this.tooltip.hide(), this.delayShow = Re((n, i) => {
            e.callEvent("onBeforeTooltip", [n]) === false ? this.tooltip.hide() : (this.tooltip.setContent(i), this.tooltip.show(n));
          }, e.config.tooltip_timeout || 1), this.delayHide = Re(() => {
            this.delayShow.$cancelTimeout(), this.tooltip.hide();
          }, e.config.tooltip_hide_timeout || 1);
        }
      }
      const ze = { onBeforeUndo: "onAfterUndo", onBeforeRedo: "onAfterRedo" }, We = ["onTaskDragStart", "onAfterTaskUpdate", "onAfterParentExpand", "onAfterTaskDelete", "onBeforeBatchUpdate"];
      class zn {
        constructor(e, n) {
          this._batchAction = null, this._batchMode = false, this._ignore = false, this._ignoreMoveEvents = false, this._initialTasks = {}, this._initialLinks = {}, this._nestedTasks = {}, this._nestedLinks = {}, this._undo = e, this._gantt = n, this._attachEvents();
        }
        store(e, n, i = false) {
          return n === this._gantt.config.undo_types.task ? this._storeTask(e, i) : n === this._gantt.config.undo_types.link && this._storeLink(e, i);
        }
        isMoveEventsIgnored() {
          return this._ignoreMoveEvents;
        }
        toggleIgnoreMoveEvents(e) {
          this._ignoreMoveEvents = e || false;
        }
        startIgnore() {
          this._ignore = true;
        }
        stopIgnore() {
          this._ignore = false;
        }
        startBatchAction() {
          this._timeout || (this._timeout = setTimeout(() => {
            this.stopBatchAction(), this._timeout = null;
          }, 10)), this._ignore || this._batchMode || (this._batchMode = true, this._batchAction = this._undo.action.create());
        }
        stopBatchAction() {
          if (this._ignore) return;
          const e = this._undo;
          this._batchAction && e.logAction(this._batchAction), this._batchMode = false, this._batchAction = null;
        }
        onTaskAdded(e) {
          this._ignore || this._storeTaskCommand(e, this._undo.command.type.add);
        }
        onTaskUpdated(e) {
          this._ignore || this._storeTaskCommand(e, this._undo.command.type.update);
        }
        onTaskMoved(e) {
          if (!this._ignore) {
            e.$local_index = this._gantt.getTaskIndex(e.id);
            const n = this.getInitialTask(e.id);
            if (e.$local_index === n.$local_index && this._gantt.getParent(e) === this._gantt.getParent(n)) return;
            this._storeEntityCommand(e, this.getInitialTask(e.id), this._undo.command.type.move, this._undo.command.entity.task);
          }
        }
        onTaskDeleted(e) {
          if (!this._ignore) {
            if (this._storeTaskCommand(e, this._undo.command.type.remove), this._nestedTasks[e.id]) {
              const n = this._nestedTasks[e.id];
              for (let i = 0; i < n.length; i++) this._storeTaskCommand(n[i], this._undo.command.type.remove);
            }
            if (this._nestedLinks[e.id]) {
              const n = this._nestedLinks[e.id];
              for (let i = 0; i < n.length; i++) this._storeLinkCommand(n[i], this._undo.command.type.remove);
            }
          }
        }
        onLinkAdded(e) {
          this._ignore || this._storeLinkCommand(e, this._undo.command.type.add);
        }
        onLinkUpdated(e) {
          this._ignore || this._storeLinkCommand(e, this._undo.command.type.update);
        }
        onLinkDeleted(e) {
          this._ignore || this._storeLinkCommand(e, this._undo.command.type.remove);
        }
        setNestedTasks(e, n) {
          const i = this._gantt;
          let a = null;
          const r = [];
          let s = this._getLinks(i.getTask(e));
          for (let d = 0; d < n.length; d++) a = this.setInitialTask(n[d]), s = s.concat(this._getLinks(a)), r.push(a);
          const o = {};
          for (let d = 0; d < s.length; d++) o[s[d]] = true;
          const l = [];
          for (const d in o) l.push(this.setInitialLink(d));
          this._nestedTasks[e] = r, this._nestedLinks[e] = l;
        }
        setInitialTask(e, n) {
          const i = this._gantt;
          if (n || !this._initialTasks[e] || !this._batchMode) {
            const a = i.copy(i.getTask(e));
            a.$index = i.getGlobalTaskIndex(e), a.$local_index = i.getTaskIndex(e), this.setInitialTaskObject(e, a);
          }
          return this._initialTasks[e];
        }
        getInitialTask(e) {
          return this._initialTasks[e];
        }
        clearInitialTasks() {
          this._initialTasks = {};
        }
        setInitialTaskObject(e, n) {
          this._initialTasks[e] = n;
        }
        setInitialLink(e, n) {
          return this._initialLinks[e] && this._batchMode || (this._initialLinks[e] = this._gantt.copy(this._gantt.getLink(e))), this._initialLinks[e];
        }
        getInitialLink(e) {
          return this._initialLinks[e];
        }
        clearInitialLinks() {
          this._initialLinks = {};
        }
        _attachEvents() {
          let e = null;
          const n = this._gantt, i = () => {
            e || (e = setTimeout(() => {
              e = null;
            }), this.clearInitialTasks(), n.eachTask((l) => {
              this.setInitialTask(l.id);
            }), this.clearInitialLinks(), n.getLinks().forEach((l) => {
              this.setInitialLink(l.id);
            }));
          }, a = (l) => n.copy(n.getTask(l));
          for (const l in ze) n.attachEvent(l, () => (this.startIgnore(), true)), n.attachEvent(ze[l], () => (this.stopIgnore(), true));
          for (let l = 0; l < We.length; l++) n.attachEvent(We[l], () => (this.startBatchAction(), true));
          n.attachEvent("onParse", () => {
            this._undo.clearUndoStack(), this._undo.clearRedoStack(), i();
          }), n.attachEvent("onAfterTaskAdd", (l, d) => {
            this.setInitialTask(l, true), this.onTaskAdded(d);
          }), n.attachEvent("onAfterTaskUpdate", (l, d) => {
            this.onTaskUpdated(d);
          }), n.attachEvent("onAfterParentExpand", (l, d) => {
            this.onTaskUpdated(d);
          }), n.attachEvent("onAfterTaskDelete", (l, d) => {
            this.onTaskDeleted(d);
          }), n.attachEvent("onAfterLinkAdd", (l, d) => {
            this.setInitialLink(l, true), this.onLinkAdded(d);
          }), n.attachEvent("onAfterLinkUpdate", (l, d) => {
            this.onLinkUpdated(d);
          }), n.attachEvent("onAfterLinkDelete", (l, d) => {
            this.onLinkDeleted(d);
          }), n.attachEvent("onRowDragEnd", (l, d) => (this.onTaskMoved(a(l)), this.toggleIgnoreMoveEvents(), true)), n.attachEvent("onBeforeTaskDelete", (l) => {
            this.store(l, n.config.undo_types.task);
            const d = [];
            return i(), n.eachTask((c) => {
              d.push(c.id);
            }, l), this.setNestedTasks(l, d), true;
          });
          const r = n.getDatastore("task");
          r.attachEvent("onBeforeItemMove", (l, d, c) => (this.isMoveEventsIgnored() || i(), true)), r.attachEvent("onAfterItemMove", (l, d, c) => (this.isMoveEventsIgnored() || this.onTaskMoved(a(l)), true)), n.attachEvent("onRowDragStart", (l, d, c) => (this.toggleIgnoreMoveEvents(true), i(), true));
          let s = null, o = false;
          if (n.attachEvent("onBeforeTaskDrag", (l) => {
            if (s = n.getState().drag_id, s === l) {
              const d = n.getTask(l);
              n.isSummaryTask(d) && n.config.drag_project && (o = true);
            }
            if (n.plugins().multiselect) {
              const d = n.getSelectedTasks();
              d.length > 1 && d.forEach((c) => {
                this.store(c, n.config.undo_types.task, true);
              });
            }
            return this.store(l, n.config.undo_types.task);
          }), n.attachEvent("onAfterTaskDrag", (l) => {
            (o || n.plugins().multiselect && n.getSelectedTasks().length > 1) && s === l && (o = false, s = null, this.stopBatchAction()), this.store(l, n.config.undo_types.task, true);
          }), n.attachEvent("onLightbox", (l) => this.store(l, n.config.undo_types.task)), n.attachEvent("onBeforeTaskAutoSchedule", (l) => (this.store(l.id, n.config.undo_types.task, true), true)), n.ext.inlineEditors) {
            let l = null, d = null;
            n.attachEvent("onGanttLayoutReady", () => {
              l && n.ext.inlineEditors.detachEvent(l), d && n.ext.inlineEditors.detachEvent(d), d = n.ext.inlineEditors.attachEvent("onEditStart", (c) => {
                this.store(c.id, n.config.undo_types.task);
              }), l = n.ext.inlineEditors.attachEvent("onBeforeEditStart", (c) => (this.stopBatchAction(), true));
            });
          }
        }
        _storeCommand(e) {
          const n = this._undo;
          if (n.updateConfigs(), n.undoEnabled) if (this._batchMode) this._batchAction.commands.push(e);
          else {
            const i = n.action.create([e]);
            n.logAction(i);
          }
        }
        _storeEntityCommand(e, n, i, a) {
          const r = this._undo.command.create(e, n, i, a);
          this._storeCommand(r);
        }
        _storeTaskCommand(e, n) {
          this._gantt.isTaskExists(e.id) && (e.$local_index = this._gantt.getTaskIndex(e.id)), this._storeEntityCommand(e, this.getInitialTask(e.id), n, this._undo.command.entity.task);
        }
        _storeLinkCommand(e, n) {
          this._storeEntityCommand(e, this.getInitialLink(e.id), n, this._undo.command.entity.link);
        }
        _getLinks(e) {
          return e.$source.concat(e.$target);
        }
        _storeTask(e, n = false) {
          const i = this._gantt;
          return this.setInitialTask(e, n), i.eachTask((a) => {
            this.setInitialTask(a.id);
          }, e), true;
        }
        _storeLink(e, n = false) {
          return this.setInitialLink(e, n), true;
        }
      }
      class Wn {
        constructor(e) {
          this.maxSteps = 100, this.undoEnabled = true, this.redoEnabled = true, this.action = { create: (n) => ({ commands: n ? n.slice() : [] }), invert: (n) => {
            const i = this._gantt.copy(n), a = this.command;
            for (let r = 0; r < n.commands.length; r++) {
              const s = i.commands[r] = a.invert(i.commands[r]);
              s.type !== a.type.update && s.type !== a.type.move || ([s.value, s.oldValue] = [s.oldValue, s.value]);
            }
            return i;
          } }, this.command = { entity: null, type: null, create: (n, i, a, r) => {
            const s = this._gantt;
            return { entity: r, type: a, value: s.copy(n), oldValue: s.copy(i || n) };
          }, invert: (n) => {
            const i = this._gantt.copy(n);
            return i.type = this.command.inverseCommands(n.type), i;
          }, inverseCommands: (n) => {
            const i = this._gantt, a = this.command.type;
            switch (n) {
              case a.update:
                return a.update;
              case a.remove:
                return a.add;
              case a.add:
                return a.remove;
              case a.move:
                return a.move;
              default:
                return i.assert(false, "Invalid command " + n), null;
            }
          } }, this._undoStack = [], this._redoStack = [], this._gantt = e;
        }
        getUndoStack() {
          return this._undoStack;
        }
        setUndoStack(e) {
          this._undoStack = e;
        }
        getRedoStack() {
          return this._redoStack;
        }
        setRedoStack(e) {
          this._redoStack = e;
        }
        clearUndoStack() {
          this._undoStack = [];
        }
        clearRedoStack() {
          this._redoStack = [];
        }
        updateConfigs() {
          const e = this._gantt;
          this.maxSteps = e.config.undo_steps || 100, this.command.entity = e.config.undo_types, this.command.type = e.config.undo_actions, this.undoEnabled = !!e.config.undo, this.redoEnabled = !!e.config.redo;
        }
        undo() {
          const e = this._gantt;
          if (this.updateConfigs(), !this.undoEnabled) return;
          const n = this._pop(this._undoStack);
          if (n && this._reorderCommands(n), e.callEvent("onBeforeUndo", [n]) !== false && n) return this._applyAction(this.action.invert(n)), this._push(this._redoStack, e.copy(n)), void e.callEvent("onAfterUndo", [n]);
          e.callEvent("onAfterUndo", [null]);
        }
        redo() {
          const e = this._gantt;
          if (this.updateConfigs(), !this.redoEnabled) return;
          const n = this._pop(this._redoStack);
          if (n && this._reorderCommands(n), e.callEvent("onBeforeRedo", [n]) !== false && n) return this._applyAction(n), this._push(this._undoStack, e.copy(n)), void e.callEvent("onAfterRedo", [n]);
          e.callEvent("onAfterRedo", [null]);
        }
        logAction(e) {
          this._push(this._undoStack, e), this._redoStack = [];
        }
        _push(e, n) {
          const i = this._gantt;
          if (!n.commands.length) return;
          const a = e === this._undoStack ? "onBeforeUndoStack" : "onBeforeRedoStack";
          if (i.callEvent(a, [n]) !== false && n.commands.length) {
            for (e.push(n); e.length > this.maxSteps; ) e.shift();
            return n;
          }
        }
        _pop(e) {
          return e.pop();
        }
        _reorderCommands(e) {
          const n = { any: 0, link: 1, task: 2 }, i = { move: 1, any: 0 };
          e.commands.sort(function(a, r) {
            if (a.entity === "task" && r.entity === "task") return a.type !== r.type ? (i[r.type] || 0) - (i[a.type] || 0) : a.type === "move" && a.oldValue && r.oldValue && r.oldValue.parent === a.oldValue.parent ? a.oldValue.$index - r.oldValue.$index : 0;
            {
              const s = n[a.entity] || n.any;
              return (n[r.entity] || n.any) - s;
            }
          });
        }
        _applyAction(e) {
          let n = null;
          const i = this.command.entity, a = this.command.type, r = this._gantt, s = {};
          s[i.task] = { add: "addTask", get: "getTask", update: "updateTask", remove: "deleteTask", move: "moveTask", isExists: "isTaskExists" }, s[i.link] = { add: "addLink", get: "getLink", update: "updateLink", remove: "deleteLink", isExists: "isLinkExists" }, r.batchUpdate(function() {
            for (let o = 0; o < e.commands.length; o++) {
              n = e.commands[o];
              const l = s[n.entity][n.type], d = s[n.entity].get, c = s[n.entity].isExists;
              if (n.type === a.add) r[l](n.oldValue, n.oldValue.parent, n.oldValue.$local_index);
              else if (n.type === a.remove) r[c](n.value.id) && r[l](n.value.id);
              else if (n.type === a.update) {
                const u = r[d](n.value.id);
                for (const h in n.value) {
                  let g = !(h.startsWith("$") || h.startsWith("_"));
                  ["$open"].indexOf(h) > -1 && (g = true), g && (u[h] = n.value[h]);
                }
                r[l](n.value.id);
              } else n.type === a.move && (r[l](n.value.id, n.value.$local_index, n.value.parent), r.callEvent("onRowDragEnd", [n.value.id]));
            }
          });
        }
      }
      const jn = { click_drag: function(t) {
        t.ext || (t.ext = {});
        const e = { className: "gantt_click_drag_rect", useRequestAnimationFrame: true, callback: void 0, singleRow: false }, n = new An(t);
        t.ext.clickDrag = n, t.attachEvent("onGanttReady", () => {
          const i = { viewPort: t.$task_data, ...e };
          if (t.config.click_drag) {
            const a = t.config.click_drag;
            i.render = a.render || e.render, i.className = a.className || e.className, i.callback = a.callback || e.callback, i.viewPort = a.viewPort || t.$task_data, i.useRequestAnimationFrame = a.useRequestAnimationFrame === void 0 ? e.useRequestAnimationFrame : a.useRequestAnimationFrame, i.singleRow = a.singleRow === void 0 ? e.singleRow : a.singleRow;
            const r = t.$ui.getView("timeline"), s = new Nn(i, t, r);
            t.ext.clickDrag.attach(s, a.useKey, a.ignore);
          }
        }), t.attachEvent("onDestroy", () => {
          n.destructor();
        });
      }, drag_timeline: function(t) {
        t.ext || (t.ext = {}), t.ext.dragTimeline = { create: () => ie.create(t) }, t.config.drag_timeline = { enabled: true, render: false };
      }, fullscreen: function(t) {
        function e() {
          const c = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
          return !(!c || c !== document.body);
        }
        function n() {
          try {
            return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
          } catch (c) {
            console.error("Fullscreen is not available:", c);
          }
        }
        t.$services.getService("state").registerProvider("fullscreen", () => n() ? { fullscreen: e() } : void 0);
        let i = { overflow: null, padding: null, paddingTop: null, paddingRight: null, paddingBottom: null, paddingLeft: null };
        const a = { width: null, height: null, top: null, left: null, position: null, zIndex: null, modified: false };
        let r = null;
        function s(c, u) {
          u.width = c.width, u.height = c.height, u.top = c.top, u.left = c.left, u.position = c.position, u.zIndex = c.zIndex;
        }
        let o = false;
        function l() {
          if (!t.$container) return;
          let c;
          e() ? o && (c = "onExpand", function() {
            const u = t.ext.fullscreen.getFullscreenElement(), h = document.body;
            s(u.style, a), i = { overflow: h.style.overflow, padding: h.style.padding ? h.style.padding : null, paddingTop: h.style.paddingTop ? h.style.paddingTop : null, paddingRight: h.style.paddingRight ? h.style.paddingRight : null, paddingBottom: h.style.paddingBottom ? h.style.paddingBottom : null, paddingLeft: h.style.paddingLeft ? h.style.paddingLeft : null }, h.style.padding && (h.style.padding = "0"), h.style.paddingTop && (h.style.paddingTop = "0"), h.style.paddingRight && (h.style.paddingRight = "0"), h.style.paddingBottom && (h.style.paddingBottom = "0"), h.style.paddingLeft && (h.style.paddingLeft = "0"), h.style.overflow = "hidden", u.style.width = "100vw", u.style.height = "100vh", u.style.top = "0px", u.style.left = "0px", u.style.position = "absolute", u.style.zIndex = 1, a.modified = true, r = function(g) {
              let f = g.parentNode;
              const y = [];
              for (; f && f.style; ) y.push({ element: f, originalPositioning: f.style.position }), f.style.position = "static", f = f.parentNode;
              return y;
            }(u);
          }()) : o && (o = false, c = "onCollapse", function() {
            const u = t.ext.fullscreen.getFullscreenElement(), h = document.body;
            a.modified && (i.padding && (h.style.padding = i.padding), i.paddingTop && (h.style.paddingTop = i.paddingTop), i.paddingRight && (h.style.paddingRight = i.paddingRight), i.paddingBottom && (h.style.paddingBottom = i.paddingBottom), i.paddingLeft && (h.style.paddingLeft = i.paddingLeft), h.style.overflow = i.overflow, i = { overflow: null, padding: null, paddingTop: null, paddingRight: null, paddingBottom: null, paddingLeft: null }, s(a, u.style), a.modified = false), r.forEach((g) => {
              g.element.style.position = g.originalPositioning;
            }), r = null;
          }()), setTimeout(() => {
            t.render();
          }), setTimeout(() => {
            t.callEvent(c, [t.ext.fullscreen.getFullscreenElement()]);
          });
        }
        function d() {
          return !t.$container || !t.ext.fullscreen.getFullscreenElement() ? true : n() ? false : ((console.warning || console.log)("The `fullscreen` feature not being allowed, or full-screen mode not being supported"), true);
        }
        t.ext.fullscreen = { expand() {
          if (d() || e() || !t.callEvent("onBeforeExpand", [this.getFullscreenElement()])) return;
          o = true;
          const c = document.body, u = c.webkitRequestFullscreen ? [Element.ALLOW_KEYBOARD_INPUT] : [], h = c.msRequestFullscreen || c.mozRequestFullScreen || c.webkitRequestFullscreen || c.requestFullscreen;
          h && h.apply(c, u);
        }, collapse() {
          if (d() || !e() || !t.callEvent("onBeforeCollapse", [this.getFullscreenElement()])) return;
          const c = document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.exitFullscreen;
          c && c.apply(document);
        }, toggle() {
          d() || (e() ? this.collapse() : this.expand());
        }, getFullscreenElement: () => t.$root }, t.expand = function() {
          t.ext.fullscreen.expand();
        }, t.collapse = function() {
          t.ext.fullscreen.collapse();
        }, t.attachEvent("onGanttReady", function() {
          t.event(document, "webkitfullscreenchange", l), t.event(document, "mozfullscreenchange", l), t.event(document, "MSFullscreenChange", l), t.event(document, "fullscreenChange", l), t.event(document, "fullscreenchange", l);
        });
      }, keyboard_navigation: function(t) {
        (function(e) {
          e.config.keyboard_navigation = true, e.config.keyboard_navigation_cells = false, e.$keyboardNavigation = {}, e._compose = function() {
            for (var n = Array.prototype.slice.call(arguments, 0), i = {}, a = 0; a < n.length; a++) {
              var r = n[a];
              for (var s in typeof r == "function" && (r = new r()), r) i[s] = r[s];
            }
            return i;
          }, function(n) {
            n.$keyboardNavigation.shortcuts = { createCommand: function() {
              return { modifiers: { shift: false, alt: false, ctrl: false, meta: false }, keyCode: null };
            }, parse: function(i) {
              for (var a = [], r = this.getExpressions(this.trim(i)), s = 0; s < r.length; s++) {
                for (var o = this.getWords(r[s]), l = this.createCommand(), d = 0; d < o.length; d++) this.commandKeys[o[d]] ? l.modifiers[o[d]] = true : this.specialKeys[o[d]] ? l.keyCode = this.specialKeys[o[d]] : l.keyCode = o[d].charCodeAt(0);
                a.push(l);
              }
              return a;
            }, getCommandFromEvent: function(i) {
              var a = this.createCommand();
              a.modifiers.shift = !!i.shiftKey, a.modifiers.alt = !!i.altKey, a.modifiers.ctrl = !!i.ctrlKey, a.modifiers.meta = !!i.metaKey, a.keyCode = i.which || i.keyCode, a.keyCode >= 96 && a.keyCode <= 105 && (a.keyCode -= 48);
              var r = String.fromCharCode(a.keyCode);
              return r && (a.keyCode = r.toLowerCase().charCodeAt(0)), a;
            }, getHashFromEvent: function(i) {
              return this.getHash(this.getCommandFromEvent(i));
            }, getHash: function(i) {
              var a = [];
              for (var r in i.modifiers) i.modifiers[r] && a.push(r);
              return a.push(i.keyCode), a.join(this.junctionChar);
            }, getExpressions: function(i) {
              return i.split(this.junctionChar);
            }, getWords: function(i) {
              return i.split(this.combinationChar);
            }, trim: function(i) {
              return i.replace(/\s/g, "");
            }, junctionChar: ",", combinationChar: "+", commandKeys: { shift: 16, alt: 18, ctrl: 17, meta: true }, specialKeys: { backspace: 8, tab: 9, enter: 13, esc: 27, space: 32, up: 38, down: 40, left: 37, right: 39, home: 36, end: 35, pageup: 33, pagedown: 34, delete: 46, insert: 45, plus: 107, f1: 112, f2: 113, f3: 114, f4: 115, f5: 116, f6: 117, f7: 118, f8: 119, f9: 120, f10: 121, f11: 122, f12: 123 } };
          }(e), function(n) {
            n.$keyboardNavigation.EventHandler = { _handlers: null, findHandler: function(i) {
              this._handlers || (this._handlers = {});
              var a = n.$keyboardNavigation.shortcuts.getHash(i);
              return this._handlers[a];
            }, doAction: function(i, a) {
              var r = this.findHandler(i);
              if (r) {
                if (n.$keyboardNavigation.facade.callEvent("onBeforeAction", [i, a]) === false) return;
                r.call(this, a), a.preventDefault ? a.preventDefault() : a.returnValue = false;
              }
            }, bind: function(i, a) {
              this._handlers || (this._handlers = {});
              for (var r = n.$keyboardNavigation.shortcuts, s = r.parse(i), o = 0; o < s.length; o++) this._handlers[r.getHash(s[o])] = a;
            }, unbind: function(i) {
              for (var a = n.$keyboardNavigation.shortcuts, r = a.parse(i), s = 0; s < r.length; s++) this._handlers[a.getHash(r[s])] && delete this._handlers[a.getHash(r[s])];
            }, bindAll: function(i) {
              for (var a in i) this.bind(a, i[a]);
            }, initKeys: function() {
              this._handlers || (this._handlers = {}), this.keys && this.bindAll(this.keys);
            } };
          }(e), function(n) {
            n.$keyboardNavigation.getFocusableNodes = Zt, n.$keyboardNavigation.trapFocus = function(i, a) {
              if (a.keyCode != 9) return false;
              for (var r = n.$keyboardNavigation.getFocusableNodes(i), s = ee(), o = -1, l = 0; l < r.length; l++) if (r[l] == s) {
                o = l;
                break;
              }
              if (a.shiftKey) {
                if (o <= 0) {
                  var d = r[r.length - 1];
                  if (d) return d.focus(), a.preventDefault(), true;
                }
              } else if (o >= r.length - 1) {
                var c = r[0];
                if (c) return c.focus(), a.preventDefault(), true;
              }
              return false;
            };
          }(e), function(n) {
            n.$keyboardNavigation.GanttNode = function() {
            }, n.$keyboardNavigation.GanttNode.prototype = n._compose(n.$keyboardNavigation.EventHandler, { focus: function() {
              n.focus();
            }, blur: function() {
            }, isEnabled: function() {
              return n.$container.hasAttribute("tabindex");
            }, scrollHorizontal: function(i) {
              var a = n.dateFromPos(n.getScrollState().x), r = n.getScale(), s = i < 0 ? -r.step : r.step;
              a = n.date.add(a, s, r.unit), n.scrollTo(n.posFromDate(a));
            }, scrollVertical: function(i) {
              var a = n.getScrollState().y, r = n.config.row_height;
              n.scrollTo(null, a + (i < 0 ? -1 : 1) * r);
            }, keys: { "alt+left": function(i) {
              this.scrollHorizontal(-1);
            }, "alt+right": function(i) {
              this.scrollHorizontal(1);
            }, "alt+up": function(i) {
              this.scrollVertical(-1);
            }, "alt+down": function(i) {
              this.scrollVertical(1);
            }, "ctrl+z": function() {
              n.undo && n.undo();
            }, "ctrl+r": function() {
              n.redo && n.redo();
            } } }), n.$keyboardNavigation.GanttNode.prototype.bindAll(n.$keyboardNavigation.GanttNode.prototype.keys);
          }(e), function(n) {
            n.$keyboardNavigation.KeyNavNode = function() {
            }, n.$keyboardNavigation.KeyNavNode.prototype = n._compose(n.$keyboardNavigation.EventHandler, { isValid: function() {
              return true;
            }, fallback: function() {
              return null;
            }, moveTo: function(i) {
              n.$keyboardNavigation.dispatcher.setActiveNode(i);
            }, compareTo: function(i) {
              if (!i) return false;
              for (var a in this) {
                if (!!this[a] != !!i[a]) return false;
                var r = !(!this[a] || !this[a].toString), s = !(!i[a] || !i[a].toString);
                if (s != r) return false;
                if (s && r) {
                  if (i[a].toString() != this[a].toString()) return false;
                } else if (i[a] != this[a]) return false;
              }
              return true;
            }, getNode: function() {
            }, focus: function() {
              var i = this.getNode();
              if (i) {
                var a = n.$keyboardNavigation.facade;
                a.callEvent("onBeforeFocus", [i]) !== false && i && (i.setAttribute("tabindex", "-1"), i.$eventAttached || (i.$eventAttached = true, n.event(i, "focus", function(r) {
                  return r.preventDefault(), false;
                }, false)), n.utils.dom.isChildOf(document.activeElement, i) && (i = document.activeElement), i.focus && i.focus(), a.callEvent("onFocus", [this.getNode()]));
              }
            }, blur: function() {
              var i = this.getNode();
              i && (n.$keyboardNavigation.facade.callEvent("onBlur", [i]), i.setAttribute("tabindex", "-1"));
            } });
          }(e), function(n) {
            n.$keyboardNavigation.HeaderCell = function(i) {
              this.index = i || 0;
            }, n.$keyboardNavigation.HeaderCell.prototype = n._compose(n.$keyboardNavigation.KeyNavNode, { _handlers: null, isValid: function() {
              return !(!n.config.show_grid && n.getVisibleTaskCount() || !n.getGridColumns()[this.index] && n.getVisibleTaskCount());
            }, fallback: function() {
              if (!n.config.show_grid) return n.getVisibleTaskCount() ? new n.$keyboardNavigation.TaskRow() : null;
              for (var i = n.getGridColumns(), a = this.index; a >= 0 && !i[a]; ) a--;
              return i[a] ? new n.$keyboardNavigation.HeaderCell(a) : null;
            }, fromDomElement: function(i) {
              var a = ut(i, "gantt_grid_head_cell");
              if (a) {
                for (var r = 0; a && a.previousSibling; ) a = a.previousSibling, r += 1;
                return new n.$keyboardNavigation.HeaderCell(r);
              }
              return null;
            }, getNode: function() {
              return n.$grid_scale.childNodes[this.index];
            }, keys: { left: function() {
              this.index > 0 && this.moveTo(new n.$keyboardNavigation.HeaderCell(this.index - 1));
            }, right: function() {
              var i = n.getGridColumns();
              this.index < i.length - 1 && this.moveTo(new n.$keyboardNavigation.HeaderCell(this.index + 1));
            }, down: function() {
              var i, a = n.getChildren(n.config.root_id);
              n.isTaskExists(a[0]) && (i = a[0]), i && (n.config.keyboard_navigation_cells ? this.moveTo(new n.$keyboardNavigation.TaskCell(i, this.index)) : this.moveTo(new n.$keyboardNavigation.TaskRow(i)));
            }, end: function() {
              var i = n.getGridColumns();
              this.moveTo(new n.$keyboardNavigation.HeaderCell(i.length - 1));
            }, home: function() {
              this.moveTo(new n.$keyboardNavigation.HeaderCell(0));
            }, "enter, space": function() {
              ee().click();
            }, "ctrl+enter": function() {
              n.isReadonly(this) || n.createTask({}, this.taskId);
            } } }), n.$keyboardNavigation.HeaderCell.prototype.bindAll(n.$keyboardNavigation.HeaderCell.prototype.keys);
          }(e), function(n) {
            n.$keyboardNavigation.TaskRow = function(i) {
              if (!i) {
                var a = n.getChildren(n.config.root_id);
                a[0] && (i = a[0]);
              }
              this.taskId = i, n.isTaskExists(this.taskId) && (this.index = n.getTaskIndex(this.taskId), this.globalIndex = n.getGlobalTaskIndex(this.taskId), this.splitItem = !!n.getTask(this.taskId).$split_subtask, this.parentId = n.getParent(this.taskId));
            }, n.$keyboardNavigation.TaskRow.prototype = n._compose(n.$keyboardNavigation.KeyNavNode, { _handlers: null, isValid: function() {
              return n.isTaskExists(this.taskId) && n.getTaskIndex(this.taskId) > -1;
            }, fallback: function() {
              if (!n.getVisibleTaskCount()) {
                var i = new n.$keyboardNavigation.HeaderCell();
                return i.isValid() ? i : null;
              }
              if (this.splitItem) return new n.$keyboardNavigation.TaskRow(this.parentId);
              var a = -1;
              if (n.getTaskByIndex(this.globalIndex - 1)) a = this.globalIndex - 1;
              else if (n.getTaskByIndex(this.globalIndex + 1)) a = this.globalIndex + 1;
              else for (var r = this.globalIndex; r >= 0; ) {
                if (n.getTaskByIndex(r)) {
                  a = r;
                  break;
                }
                r--;
              }
              return a > -1 ? new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(a).id) : void 0;
            }, fromDomElement: function(i) {
              if (n.config.keyboard_navigation_cells) return null;
              var a = n.locate(i);
              return n.isTaskExists(a) ? new n.$keyboardNavigation.TaskRow(a) : null;
            }, getNode: function() {
              if (n.isTaskExists(this.taskId) && n.isTaskVisible(this.taskId)) return n.config.show_grid ? n.$grid.querySelector(".gantt_row[" + n.config.task_attribute + "='" + this.taskId + "']") : n.getTaskNode(this.taskId);
            }, focus: function(i) {
              if (!i) {
                const a = n.getTaskPosition(n.getTask(this.taskId)), r = n.getTaskHeight(this.taskId), s = n.getScrollState();
                let o, l;
                o = n.$task ? n.$task.offsetWidth : s.inner_width, l = n.$grid_data || n.$task_data ? (n.$grid_data || n.$task_data).offsetHeight : s.inner_height, a.top < s.y || a.top + r > s.y + l ? n.scrollTo(null, a.top - 20) : n.config.scroll_on_click && n.config.show_chart && (a.left > s.x + o ? n.scrollTo(a.left - n.config.task_scroll_offset) : a.left + a.width < s.x && n.scrollTo(a.left + a.width - n.config.task_scroll_offset));
              }
              n.$keyboardNavigation.KeyNavNode.prototype.focus.apply(this, [i]), function() {
                var a = n.$ui.getView("grid"), r = parseInt(a.$grid.scrollLeft), s = parseInt(a.$grid_data.scrollTop), o = a.$config.scrollX;
                if (o && a.$config.scrollable) {
                  var l = n.$ui.getView(o);
                  l && l.scrollTo(r, s);
                }
                var d = a.$config.scrollY;
                if (d) {
                  var c = n.$ui.getView(d);
                  c && c.scrollTo(r, s);
                }
              }();
            }, keys: { pagedown: function() {
              n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(n.getVisibleTaskCount() - 1).id));
            }, pageup: function() {
              n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(0).id));
            }, up: function() {
              var i = null, a = n.getPrev(this.taskId);
              i = n.isTaskExists(a) ? new n.$keyboardNavigation.TaskRow(a) : new n.$keyboardNavigation.HeaderCell(), this.moveTo(i);
            }, down: function() {
              var i = n.getNext(this.taskId);
              n.isTaskExists(i) && this.moveTo(new n.$keyboardNavigation.TaskRow(i));
            }, "shift+down": function() {
              n.hasChild(this.taskId) && !n.getTask(this.taskId).$open && n.open(this.taskId);
            }, "shift+up": function() {
              n.hasChild(this.taskId) && n.getTask(this.taskId).$open && n.close(this.taskId);
            }, "shift+right": function() {
              if (!n.isReadonly(this)) {
                var i = n.getPrevSibling(this.taskId);
                n.isTaskExists(i) && !n.isChildOf(this.taskId, i) && (n.getTask(i).$open = true, n.moveTask(this.taskId, -1, i) !== false && n.updateTask(this.taskId));
              }
            }, "shift+left": function() {
              if (!n.isReadonly(this)) {
                var i = n.getParent(this.taskId);
                n.isTaskExists(i) && n.moveTask(this.taskId, n.getTaskIndex(i) + 1, n.getParent(i)) !== false && n.updateTask(this.taskId);
              }
            }, space: function(i) {
              n.isSelectedTask(this.taskId) ? n.unselectTask(this.taskId) : n.selectTask(this.taskId);
            }, "ctrl+left": function(i) {
              n.close(this.taskId);
            }, "ctrl+right": function(i) {
              n.open(this.taskId);
            }, delete: function(i) {
              n.isReadonly(this) || n.$click.buttons.delete(this.taskId);
            }, enter: function() {
              n.isReadonly(this) || n.showLightbox(this.taskId);
            }, "ctrl+enter": function() {
              n.isReadonly(this) || n.createTask({}, this.taskId);
            } } }), n.$keyboardNavigation.TaskRow.prototype.bindAll(n.$keyboardNavigation.TaskRow.prototype.keys);
          }(e), function(n) {
            n.$keyboardNavigation.TaskCell = function(i, a) {
              if (!(i = it(i, n.config.root_id))) {
                var r = n.getChildren(n.config.root_id);
                r[0] && (i = r[0]);
              }
              this.taskId = i, this.columnIndex = a || 0, n.isTaskExists(this.taskId) && (this.index = n.getTaskIndex(this.taskId), this.globalIndex = n.getGlobalTaskIndex(this.taskId));
            }, n.$keyboardNavigation.TaskCell.prototype = n._compose(n.$keyboardNavigation.TaskRow, { _handlers: null, isValid: function() {
              return n.$keyboardNavigation.TaskRow.prototype.isValid.call(this) && !!n.getGridColumns()[this.columnIndex];
            }, fallback: function() {
              var i = n.$keyboardNavigation.TaskRow.prototype.fallback.call(this), a = i;
              if (i instanceof n.$keyboardNavigation.TaskRow) {
                for (var r = n.getGridColumns(), s = this.columnIndex; s >= 0 && !r[s]; ) s--;
                r[s] && (a = new n.$keyboardNavigation.TaskCell(i.taskId, s));
              }
              return a;
            }, fromDomElement: function(i) {
              if (!n.config.keyboard_navigation_cells) return null;
              var a = n.locate(i);
              if (n.isTaskExists(a)) {
                var r = 0, s = Z(i, "data-column-index");
                return s && (r = 1 * s.getAttribute("data-column-index")), new n.$keyboardNavigation.TaskCell(a, r);
              }
              return null;
            }, getNode: function() {
              if (n.isTaskExists(this.taskId) && n.isTaskVisible(this.taskId)) {
                if (n.config.show_grid) {
                  var i = n.$grid.querySelector(".gantt_row[" + n.config.task_attribute + "='" + this.taskId + "']");
                  return i ? i.querySelector("[data-column-index='" + this.columnIndex + "']") : null;
                }
                return n.getTaskNode(this.taskId);
              }
            }, keys: { up: function() {
              var i = null, a = n.getPrev(this.taskId);
              i = n.isTaskExists(a) ? new n.$keyboardNavigation.TaskCell(a, this.columnIndex) : new n.$keyboardNavigation.HeaderCell(this.columnIndex), this.moveTo(i);
            }, down: function() {
              var i = n.getNext(this.taskId);
              n.isTaskExists(i) && this.moveTo(new n.$keyboardNavigation.TaskCell(i, this.columnIndex));
            }, left: function() {
              this.columnIndex > 0 && this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, this.columnIndex - 1));
            }, right: function() {
              var i = n.getGridColumns();
              this.columnIndex < i.length - 1 && this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, this.columnIndex + 1));
            }, end: function() {
              var i = n.getGridColumns();
              this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, i.length - 1));
            }, home: function() {
              this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, 0));
            }, pagedown: function() {
              n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskCell(n.getTaskByIndex(n.getVisibleTaskCount() - 1).id, this.columnIndex));
            }, pageup: function() {
              n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskCell(n.getTaskByIndex(0).id, this.columnIndex));
            } } }), n.$keyboardNavigation.TaskCell.prototype.bindAll(n.$keyboardNavigation.TaskRow.prototype.keys), n.$keyboardNavigation.TaskCell.prototype.bindAll(n.$keyboardNavigation.TaskCell.prototype.keys);
          }(e), Ln(e), function(n) {
            n.$keyboardNavigation.dispatcher = { isActive: false, activeNode: null, globalNode: new n.$keyboardNavigation.GanttNode(), enable: function() {
              this.isActive = true, this.setActiveNode(this.getActiveNode());
            }, disable: function() {
              this.isActive = false;
            }, isEnabled: function() {
              return !!this.isActive;
            }, getDefaultNode: function() {
              var i;
              return (i = n.config.keyboard_navigation_cells ? new n.$keyboardNavigation.TaskCell() : new n.$keyboardNavigation.TaskRow()).isValid() || (i = i.fallback()), i;
            }, setDefaultNode: function() {
              this.setActiveNode(this.getDefaultNode());
            }, getActiveNode: function() {
              var i = this.activeNode;
              return i && !i.isValid() && (i = i.fallback()), i;
            }, fromDomElement: function(i) {
              for (var a = [n.$keyboardNavigation.TaskRow, n.$keyboardNavigation.TaskCell, n.$keyboardNavigation.HeaderCell], r = 0; r < a.length; r++) if (a[r].prototype.fromDomElement) {
                var s = a[r].prototype.fromDomElement(i);
                if (s) return s;
              }
              return null;
            }, focusGlobalNode: function() {
              this.blurNode(this.globalNode), this.focusNode(this.globalNode);
            }, setActiveNode: function(i) {
              var a = true;
              this.activeNode && this.activeNode.compareTo(i) && (a = false), this.isEnabled() && (a && this.blurNode(this.activeNode), this.activeNode = i, this.focusNode(this.activeNode, !a));
            }, focusNode: function(i, a) {
              i && i.focus && i.focus(a);
            }, blurNode: function(i) {
              i && i.blur && i.blur();
            }, keyDownHandler: function(i) {
              if (!n.$keyboardNavigation.isModal() && this.isEnabled() && !i.defaultPrevented) {
                var a = this.globalNode, r = n.$keyboardNavigation.shortcuts.getCommandFromEvent(i), s = this.getActiveNode();
                n.$keyboardNavigation.facade.callEvent("onKeyDown", [r, i]) !== false && (s ? s.findHandler(r) ? s.doAction(r, i) : a.findHandler(r) && a.doAction(r, i) : this.setDefaultNode());
              }
            }, _timeout: null, awaitsFocus: function() {
              return this._timeout !== null;
            }, delay: function(i, a) {
              clearTimeout(this._timeout), this._timeout = setTimeout(n.bind(function() {
                this._timeout = null, i();
              }, this), a || 1);
            }, clearDelay: function() {
              clearTimeout(this._timeout);
            } };
          }(e), function() {
            var n = e.$keyboardNavigation.dispatcher;
            n.isTaskFocused = function(v) {
              var b = n.activeNode;
              return (b instanceof e.$keyboardNavigation.TaskRow || b instanceof e.$keyboardNavigation.TaskCell) && b.taskId == v;
            };
            var i = function(v) {
              if (e.config.keyboard_navigation && (e.config.keyboard_navigation_cells || !s(v)) && !o(v) && !function(b) {
                return !!ot(b.target, ".gantt_cal_light");
              }(v)) return n.keyDownHandler(v);
            }, a = function(v) {
              if (n.$preventDefault) return v.preventDefault(), e.$container.blur(), false;
              n.awaitsFocus() || n.focusGlobalNode();
            }, r = function() {
              if (!n.isEnabled()) return;
              const v = !G(document.activeElement, e.$container) && document.activeElement.localName != "body";
              var b = n.getActiveNode();
              if (b && !v) {
                var _, m, p = b.getNode();
                p && p.parentNode && (_ = p.parentNode.scrollTop, m = p.parentNode.scrollLeft), b.focus(true), p && p.parentNode && (p.parentNode.scrollTop = _, p.parentNode.scrollLeft = m);
              }
            };
            function s(v) {
              return !!ot(v.target, ".gantt_grid_editor_placeholder");
            }
            function o(v) {
              return !!ot(v.target, ".no_keyboard_navigation");
            }
            function l(v) {
              if (!e.config.keyboard_navigation || !e.config.keyboard_navigation_cells && s(v)) return true;
              if (!o(v)) {
                var b, _ = n.fromDomElement(v);
                _ && (n.activeNode instanceof e.$keyboardNavigation.TaskCell && G(v.target, e.$task) && (_ = new e.$keyboardNavigation.TaskCell(_.taskId, n.activeNode.columnIndex)), b = _), b ? n.isEnabled() ? n.delay(function() {
                  n.setActiveNode(b);
                }) : n.activeNode = b : (n.$preventDefault = true, setTimeout(function() {
                  n.$preventDefault = false;
                }, 300));
              }
            }
            e.attachEvent("onDataRender", function() {
              e.config.keyboard_navigation && r();
            }), e.attachEvent("onGanttRender", function() {
              e.$root && (e.eventRemove(e.$root, "keydown", i), e.eventRemove(e.$container, "focus", a), e.eventRemove(e.$container, "mousedown", l), e.config.keyboard_navigation ? (e.event(e.$root, "keydown", i), e.event(e.$container, "focus", a), e.event(e.$container, "mousedown", l), e.$container.setAttribute("tabindex", "0")) : e.$container.removeAttribute("tabindex"));
            });
            var d = e.attachEvent("onGanttReady", function() {
              if (e.detachEvent(d), e.$data.tasksStore.attachEvent("onStoreUpdated", function(b) {
                if (e.config.keyboard_navigation && n.isEnabled()) {
                  const _ = n.getActiveNode(), m = e.$ui.getView("grid"), p = m.getItemTop(b), k = m.$grid_data.scrollTop, $ = k + m.$grid_data.getBoundingClientRect().height;
                  _ && _.taskId == b && k <= p && $ >= p && r();
                }
              }), e._smart_render) {
                var v = e._smart_render._redrawTasks;
                e._smart_render._redrawTasks = function(b, _) {
                  if (e.config.keyboard_navigation && n.isEnabled()) {
                    var m = n.getActiveNode();
                    if (m && m.taskId !== void 0) {
                      for (var p = false, k = 0; k < _.length; k++) if (_[k].id == m.taskId && _[k].start_date) {
                        p = true;
                        break;
                      }
                      p || _.push(e.getTask(m.taskId));
                    }
                  }
                  return v.apply(this, arguments);
                };
              }
            });
            let c = null, u = false;
            e.attachEvent("onTaskCreated", function(v) {
              return c = v.id, true;
            }), e.attachEvent("onAfterTaskAdd", function(v, b) {
              if (!e.config.keyboard_navigation) return true;
              if (n.isEnabled()) {
                if (v == c && (u = true, setTimeout(() => {
                  u = false, c = null;
                })), u && b.type == e.config.types.placeholder) return;
                var _ = 0, m = n.activeNode;
                m instanceof e.$keyboardNavigation.TaskCell && (_ = m.columnIndex);
                var p = e.config.keyboard_navigation_cells ? e.$keyboardNavigation.TaskCell : e.$keyboardNavigation.TaskRow;
                b.type == e.config.types.placeholder && e.config.placeholder_task.focusOnCreate === false || n.setActiveNode(new p(v, _));
              }
            }), e.attachEvent("onTaskIdChange", function(v, b) {
              if (!e.config.keyboard_navigation) return true;
              var _ = n.activeNode;
              return n.isTaskFocused(v) && (_.taskId = b), true;
            });
            var h = setInterval(function() {
              e.config.keyboard_navigation && (n.isEnabled() || n.enable());
            }, 500);
            function g(v) {
              var b = { gantt: e.$keyboardNavigation.GanttNode, headerCell: e.$keyboardNavigation.HeaderCell, taskRow: e.$keyboardNavigation.TaskRow, taskCell: e.$keyboardNavigation.TaskCell };
              return b[v] || b.gantt;
            }
            function f(v) {
              for (var b = e.getGridColumns(), _ = 0; _ < b.length; _++) if (b[_].name == v) return _;
              return 0;
            }
            e.attachEvent("onDestroy", function() {
              clearInterval(h);
            });
            var y = {};
            nt(y), e.mixin(y, { addShortcut: function(v, b, _) {
              var m = g(_);
              m && m.prototype.bind(v, b);
            }, getShortcutHandler: function(v, b) {
              var _ = e.$keyboardNavigation.shortcuts.parse(v);
              if (_.length) return y.getCommandHandler(_[0], b);
            }, getCommandHandler: function(v, b) {
              var _ = g(b);
              if (_ && v) return _.prototype.findHandler(v);
            }, removeShortcut: function(v, b) {
              var _ = g(b);
              _ && _.prototype.unbind(v);
            }, focus: function(v) {
              var b, _ = v ? v.type : null, m = g(_);
              switch (_) {
                case "taskCell":
                  b = new m(v.id, f(v.column));
                  break;
                case "taskRow":
                  b = new m(v.id);
                  break;
                case "headerCell":
                  b = new m(f(v.column));
              }
              n.delay(function() {
                b ? n.setActiveNode(b) : (n.enable(), n.getActiveNode() ? n.awaitsFocus() || n.enable() : n.setDefaultNode());
              });
            }, getActiveNode: function() {
              if (n.isEnabled()) {
                var v = n.getActiveNode(), b = (m = v) instanceof e.$keyboardNavigation.GanttNode ? "gantt" : m instanceof e.$keyboardNavigation.HeaderCell ? "headerCell" : m instanceof e.$keyboardNavigation.TaskRow ? "taskRow" : m instanceof e.$keyboardNavigation.TaskCell ? "taskCell" : null, _ = e.getGridColumns();
                switch (b) {
                  case "taskCell":
                    return { type: "taskCell", id: v.taskId, column: _[v.columnIndex].name };
                  case "taskRow":
                    return { type: "taskRow", id: v.taskId };
                  case "headerCell":
                    return { type: "headerCell", column: _[v.index].name };
                }
              }
              var m;
              return null;
            } }), e.$keyboardNavigation.facade = y, e.ext.keyboardNavigation = y, e.focus = function() {
              y.focus();
            }, e.addShortcut = y.addShortcut, e.getShortcutHandler = y.getShortcutHandler, e.removeShortcut = y.removeShortcut;
          }();
        })(t);
      }, quick_info: function(t) {
        t.ext || (t.ext = {}), t.ext.quickInfo = new Pn(t), t.config.quickinfo_buttons = ["icon_edit", "icon_delete"], t.config.quick_info_detached = true, t.config.show_quick_info = true, t.templates.quick_info_title = function(a, r, s) {
          return s.text.substr(0, 50);
        }, t.templates.quick_info_content = function(a, r, s) {
          return s.details || s.text;
        }, t.templates.quick_info_date = function(a, r, s) {
          return t.templates.task_time(a, r, s);
        }, t.templates.quick_info_class = function(a, r, s) {
          return "";
        }, t.attachEvent("onTaskClick", function(a, r) {
          return t.utils.dom.closest(r.target, ".gantt_add") || setTimeout(function() {
            t.ext.quickInfo.show(a);
          }, 0), true;
        });
        const e = ["onViewChange", "onLightbox", "onBeforeTaskDelete", "onBeforeDrag"], n = function() {
          return t.ext.quickInfo.hide(), true;
        };
        for (let a = 0; a < e.length; a++) t.attachEvent(e[a], n);
        function i() {
          return t.ext.quickInfo.hide(), t.ext.quickInfo._quickInfoBox = null, true;
        }
        t.attachEvent("onEmptyClick", function(a) {
          let r = true;
          const s = document.querySelector(".gantt_cal_quick_info");
          s && t.utils.dom.isChildOf(a.target, s) && (r = false), r && n();
        }), t.attachEvent("onGanttReady", i), t.attachEvent("onDestroy", i), t.event(window, "keydown", function(a) {
          a.keyCode === 27 && t.ext.quickInfo.hide();
        }), t.showQuickInfo = function() {
          t.ext.quickInfo.show.apply(t.ext.quickInfo, arguments);
        }, t.hideQuickInfo = function() {
          t.ext.quickInfo.hide.apply(t.ext.quickInfo, arguments);
        };
      }, tooltip: function(t) {
        t.config.tooltip_timeout = 30, t.config.tooltip_offset_y = 20, t.config.tooltip_offset_x = 10, t.config.tooltip_hide_timeout = 30;
        const e = new Bn(t);
        t.ext.tooltips = e, t.attachEvent("onGanttReady", function() {
          t.$root && e.tooltipFor({ selector: "[" + t.config.task_attribute + "]:not(.gantt_task_row)", html: (n) => {
            if (t.config.touch && !t.config.touch_tooltip) return;
            const i = t.locate(n);
            if (t.isTaskExists(i)) {
              const a = t.getTask(i);
              return t.templates.tooltip_text(a.start_date, a.end_date, a);
            }
            return null;
          }, global: false });
        }), t.attachEvent("onDestroy", function() {
          e.destructor();
        }), t.attachEvent("onLightbox", function() {
          e.hideTooltip();
        }), t.attachEvent("onBeforeTooltip", function() {
          if (t.getState().link_source_id) return false;
        }), t.attachEvent("onGanttScroll", function() {
          e.hideTooltip();
        });
      }, undo: function(t) {
        const e = new Wn(t), n = new zn(e, t);
        function i(d, c, u) {
          d && (d.id === c && (d.id = u), d.parent === c && (d.parent = u));
        }
        function a(d, c, u) {
          i(d.value, c, u), i(d.oldValue, c, u);
        }
        function r(d, c, u) {
          d && (d.source === c && (d.source = u), d.target === c && (d.target = u));
        }
        function s(d, c, u) {
          r(d.value, c, u), r(d.oldValue, c, u);
        }
        function o(d, c, u) {
          const h = e;
          for (let g = 0; g < d.length; g++) {
            const f = d[g];
            for (let y = 0; y < f.commands.length; y++) f.commands[y].entity === h.command.entity.task ? a(f.commands[y], c, u) : f.commands[y].entity === h.command.entity.link && s(f.commands[y], c, u);
          }
        }
        function l(d, c, u) {
          const h = e;
          for (let g = 0; g < d.length; g++) {
            const f = d[g];
            for (let y = 0; y < f.commands.length; y++) {
              const v = f.commands[y];
              v.entity === h.command.entity.link && (v.value && v.value.id === c && (v.value.id = u), v.oldValue && v.oldValue.id === c && (v.oldValue.id = u));
            }
          }
        }
        t.config.undo = true, t.config.redo = true, t.config.undo_types = { link: "link", task: "task" }, t.config.undo_actions = { update: "update", remove: "remove", add: "add", move: "move" }, t.ext || (t.ext = {}), t.ext.undo = { undo: () => e.undo(), redo: () => e.redo(), getUndoStack: () => e.getUndoStack(), setUndoStack: (d) => e.setUndoStack(d), getRedoStack: () => e.getRedoStack(), setRedoStack: (d) => e.setRedoStack(d), clearUndoStack: () => e.clearUndoStack(), clearRedoStack: () => e.clearRedoStack(), saveState: (d, c) => n.store(d, c, true), getInitialState: (d, c) => c === t.config.undo_types.link ? n.getInitialLink(d) : n.getInitialTask(d) }, t.undo = t.ext.undo.undo, t.redo = t.ext.undo.redo, t.getUndoStack = t.ext.undo.getUndoStack, t.getRedoStack = t.ext.undo.getRedoStack, t.clearUndoStack = t.ext.undo.clearUndoStack, t.clearRedoStack = t.ext.undo.clearRedoStack, t.attachEvent("onTaskIdChange", (d, c) => {
          const u = e;
          o(u.getUndoStack(), d, c), o(u.getRedoStack(), d, c);
        }), t.attachEvent("onLinkIdChange", (d, c) => {
          const u = e;
          l(u.getUndoStack(), d, c), l(u.getRedoStack(), d, c);
        }), t.attachEvent("onGanttReady", () => {
          e.updateConfigs();
        });
      }, marker: function(t) {
        function e(i) {
          if (!t.config.show_markers || !i.start_date) return false;
          var a = t.getState();
          if (+i.start_date > +a.max_date || (!i.end_date || +i.end_date < +a.min_date) && +i.start_date < +a.min_date) return;
          var r = document.createElement("div");
          r.setAttribute("data-marker-id", i.id);
          var s = "gantt_marker";
          t.templates.marker_class && (s += " " + t.templates.marker_class(i)), i.css && (s += " " + i.css), t.templates.marker_class && (s += " " + t.templates.marker_class(i)), i.title && (r.title = i.title), r.className = s;
          var o = t.posFromDate(i.start_date);
          r.style.left = o + "px";
          let l = Math.max(t.getRowTop(t.getVisibleTaskCount()), 0) + "px";
          if (t.config.timeline_placeholder && t.$task_data && (l = t.$task_data.scrollHeight + "px"), r.style.height = l, i.end_date) {
            var d = t.posFromDate(i.end_date);
            r.style.width = Math.max(d - o, 0) + "px";
          }
          return i.text && (r.innerHTML = "<div class='gantt_marker_content' >" + i.text + "</div>"), r;
        }
        function n() {
          if (t.$task_data) {
            var i = document.createElement("div");
            i.className = "gantt_marker_area", t.$task_data.appendChild(i), t.$marker_area = i;
          }
        }
        t._markers || (t._markers = t.createDatastore({ name: "marker", initItem: function(i) {
          return i.id = i.id || t.uid(), i;
        } })), t.config.show_markers = true, t.attachEvent("onBeforeGanttRender", function() {
          t.$marker_area || n();
        }), t.attachEvent("onDataRender", function() {
          t.$marker_area || (n(), t.renderMarkers());
        }), t.attachEvent("onGanttLayoutReady", function() {
          t.attachEvent("onBeforeGanttRender", function() {
            n(), t.$services.getService("layers").createDataRender({ name: "marker", defaultContainer: function() {
              return t.$marker_area;
            } }).addLayer(e);
          }, { once: true });
        }), t.getMarker = function(i) {
          return this._markers ? this._markers.getItem(i) : null;
        }, t.addMarker = function(i) {
          return this._markers.addItem(i);
        }, t.deleteMarker = function(i) {
          return !!this._markers.exists(i) && (this._markers.removeItem(i), true);
        }, t.updateMarker = function(i) {
          this._markers.refresh(i);
        }, t._getMarkers = function() {
          return this._markers.getItems();
        }, t.renderMarkers = function() {
          this._markers.refresh();
        };
      }, multiselect: function(t) {
        t.config.multiselect = true, t.config.multiselect_one_level = false, t._multiselect = { _selected: {}, _one_level: false, _active: true, _first_selected_when_shift: null, getDefaultSelected: function() {
          var e = this.getSelected();
          return e.length ? e[e.length - 1] : null;
        }, setFirstSelected: function(e) {
          this._first_selected_when_shift = e;
        }, getFirstSelected: function() {
          return this._first_selected_when_shift;
        }, isActive: function() {
          return this.updateState(), this._active;
        }, updateState: function() {
          this._one_level = t.config.multiselect_one_level;
          var e = this._active;
          this._active = t.config.select_task, this._active != e && this.reset();
        }, reset: function() {
          this._selected = {};
        }, setLastSelected: function(e) {
          t.$data.tasksStore.silent(function() {
            var n = t.$data.tasksStore;
            e ? n.select(e + "") : n.unselect(null);
          });
        }, getLastSelected: function() {
          var e = t.$data.tasksStore.getSelectedId();
          return e && t.isTaskExists(e) ? e : null;
        }, select: function(e, n) {
          return !!(e && t.callEvent("onBeforeTaskMultiSelect", [e, true, n]) && t.callEvent("onBeforeTaskSelected", [e])) && (this._selected[e] = true, this.setLastSelected(e), this.afterSelect(e), t.callEvent("onTaskMultiSelect", [e, true, n]), t.callEvent("onTaskSelected", [e]), true);
        }, toggle: function(e, n) {
          this._selected[e] ? this.unselect(e, n) : this.select(e, n);
        }, unselect: function(e, n) {
          e && t.callEvent("onBeforeTaskMultiSelect", [e, false, n]) && (this._selected[e] = false, this.getLastSelected() == e && this.setLastSelected(this.getDefaultSelected()), this.afterSelect(e), t.callEvent("onTaskMultiSelect", [e, false, n]), t.callEvent("onTaskUnselected", [e]));
        }, isSelected: function(e) {
          return !(!t.isTaskExists(e) || !this._selected[e]);
        }, getSelected: function() {
          var e = [];
          for (var n in this._selected) this._selected[n] && t.isTaskExists(n) ? e.push(n) : this._selected[n] = false;
          return e.sort(function(i, a) {
            return t.getGlobalTaskIndex(i) > t.getGlobalTaskIndex(a) ? 1 : -1;
          }), e;
        }, forSelected: function(e) {
          for (var n = this.getSelected(), i = 0; i < n.length; i++) e(n[i]);
        }, isSameLevel: function(e) {
          if (!this._one_level) return true;
          var n = this.getLastSelected();
          return !n || !t.isTaskExists(n) || !t.isTaskExists(e) || t.calculateTaskLevel(t.getTask(n)) == t.calculateTaskLevel(t.getTask(e));
        }, afterSelect: function(e) {
          t.isTaskExists(e) && t._quickRefresh(function() {
            t.refreshTask(e);
          });
        }, doSelection: function(e) {
          if (!this.isActive() || t._is_icon_open_click(e)) return false;
          var n = t.locate(e);
          if (!n || !t.callEvent("onBeforeMultiSelect", [e])) return false;
          var i = this.getSelected(), a = this.getFirstSelected(), r = false, s = this.getLastSelected(), o = t.config.multiselect, l = function() {
            var c = t.ext.inlineEditors, u = c.getState(), h = c.locateCell(e.target);
            t.config.inline_editors_multiselect_open && h && c.getEditorConfig(h.columnName) && (c.isVisible() && u.id == h.id && u.columnName == h.columnName || c.startEdit(h.id, h.columnName)), this.setFirstSelected(n), this.isSelected(n) || this.select(n, e), i = this.getSelected();
            for (var g = 0; g < i.length; g++) i[g] !== n && this.unselect(i[g], e);
          }.bind(this), d = function() {
            if (s) {
              if (n) {
                var c = t.getGlobalTaskIndex(this.getFirstSelected()), u = t.getGlobalTaskIndex(n), h = t.getGlobalTaskIndex(s);
                c != -1 && h != -1 || (c = u, this.reset());
                for (var g = s; t.getGlobalTaskIndex(g) !== c; ) this.unselect(g, e), g = c > h ? t.getNext(g) : t.getPrev(g);
                for (g = n; t.getGlobalTaskIndex(g) !== c; ) this.select(g, e) && !r && (r = true, a = g), g = c > u ? t.getNext(g) : t.getPrev(g);
              }
            } else s = n;
          }.bind(this);
          return o && (e.ctrlKey || e.metaKey) ? (this.isSelected(n) || this.setFirstSelected(n), n && this.toggle(n, e)) : o && e.shiftKey ? (t.isTaskExists(this.getFirstSelected()) && this.getFirstSelected() !== null || this.setFirstSelected(n), i.length ? d() : l()) : l(), this.isSelected(n) ? this.setLastSelected(n) : a ? n == s && this.setLastSelected(e.shiftKey ? a : this.getDefaultSelected()) : this.setLastSelected(null), this.getSelected().length || this.setLastSelected(null), this.getLastSelected() && this.isSelected(this.getFirstSelected()) || this.setFirstSelected(this.getLastSelected()), true;
        } }, function() {
          var e = t.selectTask;
          t.selectTask = function(i) {
            if (!(i = it(i, this.config.root_id))) return false;
            var a = t._multiselect, r = i;
            return a.isActive() ? (a.select(i, null) && a.setLastSelected(i), a.setFirstSelected(a.getLastSelected())) : r = e.call(this, i), r;
          };
          var n = t.unselectTask;
          t.unselectTask = function(i) {
            var a = t._multiselect, r = a.isActive();
            (i = i || a.getLastSelected()) && r && (a.unselect(i, null), i == a.getLastSelected() && a.setLastSelected(null), t.refreshTask(i), a.setFirstSelected(a.getLastSelected()));
            var s = i;
            return r || (s = n.call(this, i)), s;
          }, t.toggleTaskSelection = function(i) {
            var a = t._multiselect;
            i && a.isActive() && (a.toggle(i), a.setFirstSelected(a.getLastSelected()));
          }, t.getSelectedTasks = function() {
            var i = t._multiselect;
            return i.isActive(), i.getSelected();
          }, t.eachSelectedTask = function(i) {
            return this._multiselect.forSelected(i);
          }, t.isSelectedTask = function(i) {
            return this._multiselect.isSelected(i);
          }, t.getLastSelectedTask = function() {
            return this._multiselect.getLastSelected();
          }, t.attachEvent("onGanttReady", function() {
            var i = t.$data.tasksStore.isSelected;
            t.$data.tasksStore.isSelected = function(a) {
              return t._multiselect.isActive() ? t._multiselect.isSelected(a) : i.call(this, a);
            };
          });
        }(), t.attachEvent("onTaskIdChange", function(e, n) {
          var i = t._multiselect;
          if (!i.isActive()) return true;
          t.isSelectedTask(e) && (i.unselect(e, null), i.select(n, null));
        }), t.attachEvent("onAfterTaskDelete", function(e, n) {
          var i = t._multiselect;
          if (!i.isActive()) return true;
          i._selected[e] && (i._selected[e] = false, i.setLastSelected(i.getDefaultSelected())), i.forSelected(function(a) {
            t.isTaskExists(a) || i.unselect(a, null);
          });
        }), t.attachEvent("onBeforeTaskMultiSelect", function(e, n, i) {
          const a = t._multiselect;
          if (n && a.isActive()) {
            let r = t.getSelectedId(), s = null;
            r && (s = t.getTask(r));
            let o = t.getTask(e), l = false;
            if (s && s.$level != o.$level && (l = true), t.config.multiselect_one_level && l && !i.ctrlKey && !i.shiftKey) return true;
            if (a._one_level) return a.isSameLevel(e);
          }
          return true;
        }), t.attachEvent("onTaskClick", function(e, n) {
          return t._multiselect.doSelection(n) && t.callEvent("onMultiSelect", [n]), true;
        });
      }, export_api: function(t) {
        return t.ext = t.ext || {}, t.ext.export_api = t.ext.export_api || { _apiUrl: "https://export.dhtmlx.com/gantt", _preparePDFConfigRaw(e, n) {
          let i = null;
          e.start && e.end && (i = { start_date: t.config.start_date, end_date: t.config.end_date }, t.config.start_date = t.date.str_to_date(t.config.date_format)(e.start), t.config.end_date = t.date.str_to_date(t.config.date_format)(e.end)), e = t.mixin(e, { name: "gantt." + n, data: t.ext.export_api._serializeHtml() }), i && (t.config.start_date = i.start_date, t.config.end_date = i.end_date);
        }, _prepareConfigPDF: (e, n) => (e = t.mixin(e || {}, { name: "gantt." + n, data: t.ext.export_api._serializeAll(), config: t.config }), t.ext.export_api._fixColumns(e.config.columns), e), _pdfExportRouter(e, n) {
          e && e.raw ? t.ext.export_api._preparePDFConfigRaw(e, n) : e = t.ext.export_api._prepareConfigPDF(e, n), e.version = t.version, t.ext.export_api._sendToExport(e, n);
        }, exportToPDF(e) {
          t.ext.export_api._pdfExportRouter(e, "pdf");
        }, exportToPNG(e) {
          t.ext.export_api._pdfExportRouter(e, "png");
        }, exportToICal(e) {
          e = t.mixin(e || {}, { name: "gantt.ical", data: t.ext.export_api._serializePlain().data, version: t.version }), t.ext.export_api._sendToExport(e, "ical");
        }, exportToExcel(e) {
          let n, i, a, r;
          e = e || {};
          const s = t.config.smart_rendering;
          if (e.visual === "base-colors" && (t.config.smart_rendering = false), e.start || e.end) {
            a = t.getState(), i = [t.config.start_date, t.config.end_date], r = t.getScrollState();
            const o = t.date.str_to_date(t.config.date_format);
            n = t.eachTask, e.start && (t.config.start_date = o(e.start)), e.end && (t.config.end_date = o(e.end)), t.render(), t.config.smart_rendering = s, t.eachTask = t.ext.export_api._eachTaskTimed(t.config.start_date, t.config.end_date);
          } else e.visual === "base-colors" && (t.render(), t.config.smart_rendering = s);
          t._no_progress_colors = e.visual === "base-colors", (e = t.mixin(e, { name: "gantt.xlsx", title: "Tasks", data: t.ext.export_api._serializeTimeline(e).data, columns: t.ext.export_api._serializeGrid({ rawDates: true }), version: t.version })).visual && (e.scales = t.ext.export_api._serializeScales(e)), t.ext.export_api._sendToExport(e, "excel"), (e.start || e.end) && (t.config.start_date = a.min_date, t.config.end_date = a.max_date, t.eachTask = n, t.render(), t.scrollTo(r.x, r.y), t.config.start_date = i[0], t.config.end_date = i[1]);
        }, exportToJSON(e) {
          e = t.mixin(e || {}, { name: "gantt.json", data: t.ext.export_api._serializeAll(), config: t.config, columns: t.ext.export_api._serializeGrid(), worktime: t.ext.export_api._getWorktimeSettings(), version: t.version }), t.ext.export_api._sendToExport(e, "json");
        }, importFromExcel(e) {
          try {
            const n = e.data;
            if (n instanceof File) {
              const i = new FormData();
              i.append("file", n), e.data = i;
            }
          } catch {
          }
          t.ext.export_api._sendImportAjaxExcel(e);
        }, importFromMSProject(e) {
          const n = e.data;
          try {
            if (n instanceof File) {
              const i = new FormData();
              i.append("file", n), e.data = i;
            }
          } catch {
          }
          t.ext.export_api._sendImportAjaxMSP(e);
        }, importFromPrimaveraP6: (e) => (e.type = "primaveraP6-parse", t.importFromMSProject(e)), exportToMSProject(e) {
          (e = e || {}).skip_circular_links = e.skip_circular_links === void 0 || !!e.skip_circular_links;
          const n = t.templates.xml_format, i = t.templates.format_date, a = t.config.xml_date, r = t.config.date_format, s = "%d-%m-%Y %H:%i:%s";
          t.config.xml_date = s, t.config.date_format = s, t.templates.xml_format = t.date.date_to_str(s), t.templates.format_date = t.date.date_to_str(s);
          const o = t.ext.export_api._serializeAll();
          t.ext.export_api._customProjectProperties(o, e), t.ext.export_api._customTaskProperties(o, e), e.skip_circular_links && t.ext.export_api._clearRecLinks(o), e = t.ext.export_api._exportConfig(o, e), t.ext.export_api._sendToExport(e, e.type || "msproject"), t.config.xml_date = a, t.config.date_format = r, t.templates.xml_format = n, t.templates.format_date = i, t.config.$custom_data = null, t.config.custom = null;
        }, exportToPrimaveraP6: (e) => ((e = e || {}).type = "primaveraP6", t.exportToMSProject(e)), _fixColumns(e) {
          for (let n = 0; n < e.length; n++) e[n].label = e[n].label || t.locale.labels["column_" + e[n].name], typeof e[n].width == "string" && (e[n].width = 1 * e[n].width);
        }, _xdr(e, n, i) {
          t.ajax.post(e, n, i);
        }, _markColumns(e) {
          const n = e.config.columns;
          if (n) for (let i = 0; i < n.length; i++) n[i].template && (n[i].$template = true);
        }, _sendImportAjaxExcel(e) {
          const n = e.server || t.ext.export_api._apiUrl, i = e.store || 0, a = e.data, r = e.callback;
          a.append("type", "excel-parse"), a.append("data", JSON.stringify({ sheet: e.sheet || 0 })), i && a.append("store", i);
          const s = new XMLHttpRequest();
          s.onreadystatechange = function(o) {
            s.readyState === 4 && s.status === 0 && r && r(null);
          }, s.onload = function() {
            let o = null;
            if (!(s.status > 400)) try {
              o = JSON.parse(s.responseText);
            } catch {
            }
            r && r(o);
          }, s.open("POST", n, true), s.setRequestHeader("X-Requested-With", "XMLHttpRequest"), s.send(a);
        }, _ajaxToExport(e, n, i) {
          delete e.callback;
          const a = e.server || t.ext.export_api._apiUrl, r = "type=" + n + "&store=1&data=" + encodeURIComponent(JSON.stringify(e));
          t.ext.export_api._xdr(a, r, function(s) {
            const o = s.xmlDoc || s;
            let l = null;
            if (!(o.status > 400)) try {
              l = JSON.parse(o.responseText);
            } catch {
            }
            i(l);
          });
        }, _serializableGanttConfig(e) {
          const n = t.mixin({}, e);
          return n.columns && (n.columns = n.columns.map(function(i) {
            const a = t.mixin({}, i);
            return delete a.editor, a;
          })), delete n.editor_types, n;
        }, _sendToExport(e, n) {
          const i = t.date.date_to_str(t.config.date_format || t.config.xml_date);
          if (e.skin || (e.skin = t.skin), e.config && (e.config = t.copy(t.ext.export_api._serializableGanttConfig(e.config)), t.ext.export_api._markColumns(e, n), e.config.start_date && e.config.end_date && (e.config.start_date instanceof Date && (e.config.start_date = i(e.config.start_date)), e.config.end_date instanceof Date && (e.config.end_date = i(e.config.end_date)))), e.callback) return t.ext.export_api._ajaxToExport(e, n, e.callback);
          const a = t.ext.export_api._createHiddenForm();
          a.firstChild.action = e.server || t.ext.export_api._apiUrl, a.firstChild.childNodes[0].value = JSON.stringify(e), a.firstChild.childNodes[1].value = n, a.firstChild.submit();
        }, _createHiddenForm() {
          if (!t.ext.export_api._hidden_export_form) {
            const e = t.ext.export_api._hidden_export_form = document.createElement("div");
            e.style.display = "none", e.innerHTML = "<form method='POST' target='_blank'><textarea name='data' style='width:0px; height:0px;' readonly='true'></textarea><input type='hidden' name='type' value=''></form>", document.body.appendChild(e);
          }
          return t.ext.export_api._hidden_export_form;
        }, _copyObjectBase(e) {
          const n = { start_date: void 0, end_date: void 0, constraint_date: void 0, deadline: void 0 };
          for (const a in e) a.charAt(0) !== "$" && a !== "baselines" && (n[a] = e[a]);
          const i = t.templates.xml_format || t.templates.format_date;
          return n.start_date = i(n.start_date), n.end_date && (n.end_date = i(n.end_date)), n.constraint_date && (n.constraint_date = i(n.constraint_date)), n.deadline && (n.deadline = i(n.deadline)), n;
        }, _color_box: null, _color_hash: {}, _getStyles(e) {
          if (t.ext.export_api._color_box || (t.ext.export_api._color_box = document.createElement("DIV"), t.ext.export_api._color_box.style.cssText = "position:absolute; display:none;", document.body.appendChild(t.ext.export_api._color_box)), t.ext.export_api._color_hash[e]) return t.ext.export_api._color_hash[e];
          t.ext.export_api._color_box.className = e;
          const n = t.ext.export_api._getColor(t.ext.export_api._color_box, "color"), i = t.ext.export_api._getColor(t.ext.export_api._color_box, "backgroundColor");
          return t.ext.export_api._color_hash[e] = n + ";" + i;
        }, _getMinutesWorktimeSettings(e) {
          const n = [];
          return e.forEach(function(i) {
            n.push(i.startMinute), n.push(i.endMinute);
          }), n;
        }, _getWorktimeSettings() {
          const e = { hours: [0, 24], minutes: null, dates: { 0: true, 1: true, 2: true, 3: true, 4: true, 5: true, 6: true } };
          let n;
          if (t.config.work_time) {
            const i = t._working_time_helper;
            if (i && i.get_calendar) n = i.get_calendar();
            else if (i) n = { hours: i.hours, minutes: null, dates: i.dates };
            else if (t.config.worktimes && t.config.worktimes.global) {
              const a = t.config.worktimes.global;
              if (a.parsed) {
                n = { hours: null, minutes: t.ext.export_api._getMinutesWorktimeSettings(a.parsed.hours), dates: {} };
                for (const r in a.parsed.dates) Array.isArray(a.parsed.dates[r]) ? n.dates[r] = t.ext.export_api._getMinutesWorktimeSettings(a.parsed.dates[r]) : n.dates[r] = a.parsed.dates[r];
              } else n = { hours: a.hours, minutes: null, dates: a.dates };
            } else n = e;
          } else n = e;
          return n;
        }, _eachTaskTimed: (e, n) => function(i, a, r) {
          a = a || t.config.root_id, r = r || t;
          const s = t.getChildren(a);
          if (s) for (let o = 0; o < s.length; o++) {
            const l = t._pull[s[o]];
            (!e || l.end_date > e) && (!n || l.start_date < n) && i.call(r, l), t.hasChild(l.id) && t.eachTask(i, l.id, r);
          }
        }, _originalCopyObject: t.json._copyObject, _copyObjectPlain(e) {
          const n = t.templates.task_text(e.start_date, e.end_date, e), i = t.ext.export_api._copyObjectBase(e);
          return i.text = n || i.text, i;
        }, _getColor(e, n) {
          const i = e.currentStyle ? e.currentStyle[n] : getComputedStyle(e, null)[n], a = i.replace(/\s/g, "").match(/^rgba?\((\d+),(\d+),(\d+)/i);
          return (a && a.length === 4 ? ("0" + parseInt(a[1], 10).toString(16)).slice(-2) + ("0" + parseInt(a[2], 10).toString(16)).slice(-2) + ("0" + parseInt(a[3], 10).toString(16)).slice(-2) : i).replace("#", "");
        }, _copyObjectTable(e) {
          const n = t.date.date_to_str("%Y-%m-%dT%H:%i:%s.000Z"), i = t.ext.export_api._copyObjectColumns(e, t.ext.export_api._copyObjectPlain(e));
          i.start_date && (i.start_date = n(e.start_date)), i.end_date && (i.end_date = n(e.end_date));
          const a = t._day_index_by_date ? t._day_index_by_date : t.columnIndexByDate;
          i.$start = a.call(t, e.start_date), i.$end = a.call(t, e.end_date);
          let r = 0;
          const s = t.getScale().width;
          if (s.indexOf(0) > -1) {
            let l = 0;
            for (; l < i.$start; l++) s[l] || r++;
            for (i.$start -= r; l < i.$end; l++) s[l] || r++;
            i.$end -= r;
          }
          i.$level = e.$level, i.$type = e.$rendered_type;
          const o = t.templates;
          return i.$text = o.task_text(e.start, e.end_date, e), i.$left = o.leftside_text ? o.leftside_text(e.start, e.end_date, e) : "", i.$right = o.rightside_text ? o.rightside_text(e.start, e.end_date, e) : "", i;
        }, _copyObjectColors(e) {
          const n = t.ext.export_api._copyObjectTable(e), i = t.getTaskNode(e.id);
          if (i && i.firstChild) {
            let a = t.ext.export_api._getColor(t._no_progress_colors ? i : i.firstChild, "backgroundColor");
            a === "363636" && (a = t.ext.export_api._getColor(i, "backgroundColor")), n.$color = a;
          } else e.color && (n.$color = e.color);
          return n;
        }, _copyObjectColumns(e, n) {
          for (let i = 0; i < t.config.columns.length; i++) {
            const a = t.config.columns[i].template;
            if (a) {
              let r = a(e);
              r instanceof Date && (r = t.templates.date_grid(r, e)), n["_" + i] = r;
            }
          }
          return n;
        }, _copyObjectAll(e) {
          const n = t.ext.export_api._copyObjectBase(e), i = ["leftside_text", "rightside_text", "task_text", "progress_text", "task_class"];
          for (let a = 0; a < i.length; a++) {
            const r = t.templates[i[a]];
            r && (n["$" + a] = r(e.start_date, e.end_date, e));
          }
          return t.ext.export_api._copyObjectColumns(e, n), n.open = e.$open, n;
        }, _serializeHtml() {
          const e = t.config.smart_scales, n = t.config.smart_rendering;
          (e || n) && (t.config.smart_rendering = false, t.config.smart_scales = false, t.render());
          const i = t.$container.parentNode.innerHTML;
          return (e || n) && (t.config.smart_scales = e, t.config.smart_rendering = n, t.render()), i;
        }, _serializeAll() {
          t.json._copyObject = t.ext.export_api._copyObjectAll;
          const e = t.ext.export_api._exportSerialize();
          return t.json._copyObject = t.ext.export_api._originalCopyObject, e;
        }, _serializePlain() {
          const e = t.templates.xml_format, n = t.templates.format_date;
          t.templates.xml_format = t.date.date_to_str("%Y%m%dT%H%i%s", true), t.templates.format_date = t.date.date_to_str("%Y%m%dT%H%i%s", true), t.json._copyObject = t.ext.export_api._copyObjectPlain;
          const i = t.ext.export_api._exportSerialize();
          return t.templates.xml_format = e, t.templates.format_date = n, t.json._copyObject = t.ext.export_api._originalCopyObject, delete i.links, i;
        }, _getRaw() {
          if (t._scale_helpers) {
            const e = t._get_scales(), n = t.config.min_column_width, i = t._get_resize_options().x ? Math.max(t.config.autosize_min_width, 0) : t.config.$task.offsetWidth, a = t.config.config.scale_height - 1;
            return t._scale_helpers.prepareConfigs(e, n, i, a);
          }
          {
            const e = t.$ui.getView("timeline");
            if (e) {
              let n = e.$config.width;
              t.config.autosize !== "x" && t.config.autosize !== "xy" || (n = Math.max(t.config.autosize_min_width, 0));
              const i = t.getState(), a = e._getScales(), r = t.config.min_column_width, s = t.config.scale_height - 1, o = t.config.rtl;
              return e.$scaleHelper.prepareConfigs(a, r, n, s, i.min_date, i.max_date, o);
            }
          }
        }, _serializeTimeline(e) {
          t.json._copyObject = e.visual ? t.ext.export_api._copyObjectColors : t.ext.export_api._copyObjectTable;
          const n = t.ext.export_api._exportSerialize();
          if (t.json._copyObject = t.ext.export_api._originalCopyObject, delete n.links, e.cellColors) {
            const i = t.templates.timeline_cell_class || t.templates.task_cell_class;
            if (i) {
              const a = t.ext.export_api._getRaw();
              let r = a[0].trace_x;
              for (let s = 1; s < a.length; s++) a[s].trace_x.length > r.length && (r = a[s].trace_x);
              for (let s = 0; s < n.data.length; s++) {
                n.data[s].styles = [];
                const o = t.getTask(n.data[s].id);
                for (let l = 0; l < r.length; l++) {
                  const d = i(o, r[l]);
                  d && n.data[s].styles.push({ index: l, styles: t.ext.export_api._getStyles(d) });
                }
              }
            }
          }
          return n;
        }, _serializeScales(e) {
          const n = [], i = t.ext.export_api._getRaw();
          let a = 1 / 0, r = 0;
          for (let s = 0; s < i.length; s++) a = Math.min(a, i[s].col_width);
          for (let s = 0; s < i.length; s++) {
            let o = 0, l = 0;
            const d = [];
            n.push(d);
            const c = i[s];
            r = Math.max(r, c.trace_x.length);
            const u = c.format || c.template || (c.date ? t.date.date_to_str(c.date) : t.config.date_scale);
            for (let h = 0; h < c.trace_x.length; h++) {
              const g = c.trace_x[h];
              l = o + Math.round(c.width[h] / a);
              const f = { text: u(g), start: o, end: l, styles: "" };
              if (e.cellColors) {
                const y = c.css || t.templates.scaleCell_class;
                if (y) {
                  const v = y(g);
                  v && (f.styles = t.ext.export_api._getStyles(v));
                }
              }
              d.push(f), o = l;
            }
          }
          return { width: r, height: n.length, data: n };
        }, _serializeGrid(e) {
          t.exportMode = true;
          const n = [], i = t.config.columns;
          let a = 0;
          for (let r = 0; r < i.length; r++) i[r].name !== "add" && i[r].name !== "buttons" && (n[a] = { id: i[r].template ? "_" + r : i[r].name, header: i[r].label || t.locale.labels["column_" + i[r].name], width: i[r].width ? Math.floor(i[r].width / 4) : "", tree: i[r].tree || false }, i[r].name === "duration" && (n[a].type = "number"), i[r].name !== "start_date" && i[r].name !== "end_date" || (n[a].type = "date", e && e.rawDates && (n[a].id = i[r].name)), a++);
          return t.exportMode = false, n;
        }, _exportSerialize() {
          t.exportMode = true;
          const e = t.templates.xml_format, n = t.templates.format_date;
          t.templates.xml_format = t.templates.format_date = t.date.date_to_str(t.config.date_format || t.config.xml_date);
          const i = t.serialize();
          return t.templates.xml_format = e, t.templates.format_date = n, t.exportMode = false, i;
        }, _setLevel(e) {
          for (let n = 0; n < e.length; n++) {
            e[n].parent == 0 && (e[n]._lvl = 1);
            for (let i = n + 1; i < e.length; i++) e[n].id == e[i].parent && (e[i]._lvl = e[n]._lvl + 1);
          }
        }, _clearLevel(e) {
          for (let n = 0; n < e.length; n++) delete e[n]._lvl;
        }, _clearRecLinks(e) {
          t.ext.export_api._setLevel(e.data);
          const n = {};
          for (let r = 0; r < e.data.length; r++) n[e.data[r].id] = e.data[r];
          const i = {};
          for (let r = 0; r < e.links.length; r++) {
            const s = e.links[r];
            t.isTaskExists(s.source) && t.isTaskExists(s.target) && n[s.source] && n[s.target] && (i[s.id] = s);
          }
          for (const r in i) t.ext.export_api._makeLinksSameLevel(i[r], n);
          const a = {};
          for (const r in n) t.ext.export_api._clearCircDependencies(n[r], i, n, {}, a, null);
          Object.keys(i) && t.ext.export_api._clearLinksSameLevel(i, n);
          for (let r = 0; r < e.links.length; r++) i[e.links[r].id] || (e.links.splice(r, 1), r--);
          t.ext.export_api._clearLevel(e.data);
        }, _clearCircDependencies(e, n, i, a, r, s) {
          const o = e.$_source;
          if (!o) return;
          a[e.id] && t.ext.export_api._onCircDependencyFind(s, n, a, r), a[e.id] = true;
          const l = {};
          for (let d = 0; d < o.length; d++) {
            if (r[o[d]]) continue;
            const c = n[o[d]], u = i[c._target];
            l[u.id] && t.ext.export_api._onCircDependencyFind(c, n, a, r), l[u.id] = true, t.ext.export_api._clearCircDependencies(u, n, i, a, r, c);
          }
          a[e.id] = false;
        }, _onCircDependencyFind(e, n, i, a) {
          e && (t.callEvent("onExportCircularDependency", [e.id, e]) && delete n[e.id], delete i[e._source], delete i[e._target], a[e.id] = true);
        }, _makeLinksSameLevel(e, n) {
          let i, a;
          const r = { target: n[e.target], source: n[e.source] };
          if (r.target._lvl != r.source._lvl) {
            r.target._lvl < r.source._lvl ? (i = "source", a = r.target._lvl) : (i = "target", a = r.source._lvl);
            do {
              const l = n[r[i].parent];
              if (!l) break;
              r[i] = l;
            } while (r[i]._lvl < a);
            let s = n[r.source.parent], o = n[r.target.parent];
            for (; s && o && s.id != o.id; ) r.source = s, r.target = o, s = n[r.source.parent], o = n[r.target.parent];
          }
          e._target = r.target.id, e._source = r.source.id, r.target.$_target || (r.target.$_target = []), r.target.$_target.push(e.id), r.source.$_source || (r.source.$_source = []), r.source.$_source.push(e.id);
        }, _clearLinksSameLevel(e, n) {
          for (const i in e) delete e[i]._target, delete e[i]._source;
          for (const i in n) delete n[i].$_source, delete n[i].$_target;
        }, _customProjectProperties(e, n) {
          if (n && n.project) {
            for (const i in n.project) t.config.$custom_data || (t.config.$custom_data = {}), t.config.$custom_data[i] = typeof n.project[i] == "function" ? n.project[i](t.config) : n.project[i];
            delete n.project;
          }
        }, _customTaskProperties(e, n) {
          n && n.tasks && (e.data.forEach(function(i) {
            for (const a in n.tasks) i.$custom_data || (i.$custom_data = {}), i.$custom_data[a] = typeof n.tasks[a] == "function" ? n.tasks[a](i, t.config) : n.tasks[a];
          }), delete n.tasks);
        }, _exportConfig(e, n) {
          const i = n.name || "gantt.xml";
          delete n.name, t.config.custom = n;
          const a = t.ext.export_api._getWorktimeSettings(), r = t.getSubtaskDates();
          if (r.start_date && r.end_date) {
            const l = t.templates.format_date || t.templates.xml_format;
            t.config.start_end = { start_date: l(r.start_date), end_date: l(r.end_date) };
          }
          const s = n.auto_scheduling !== void 0 && !!n.auto_scheduling, o = { callback: n.callback || null, config: t.config, data: e, manual: s, name: i, worktime: a };
          for (const l in n) o[l] = n[l];
          return o;
        }, _sendImportAjaxMSP(e) {
          const n = e.server || t.ext.export_api._apiUrl, i = e.store || 0, a = e.data, r = e.callback, s = { durationUnit: e.durationUnit || void 0, projectProperties: e.projectProperties || void 0, taskProperties: e.taskProperties || void 0 };
          a.append("type", e.type || "msproject-parse"), a.append("data", JSON.stringify(s)), i && a.append("store", i);
          const o = new XMLHttpRequest();
          o.onreadystatechange = function(l) {
            o.readyState === 4 && o.status === 0 && r && r(null);
          }, o.onload = function() {
            let l = null;
            if (!(o.status > 400)) try {
              l = JSON.parse(o.responseText);
            } catch {
            }
            r && r(l);
          }, o.open("POST", n, true), o.setRequestHeader("X-Requested-With", "XMLHttpRequest"), o.send(a);
        } }, t.exportToPDF = t.ext.export_api.exportToPDF, t.exportToPNG = t.ext.export_api.exportToPNG, t.exportToICal = t.ext.export_api.exportToICal, t.exportToExcel = t.ext.export_api.exportToExcel, t.exportToJSON = t.ext.export_api.exportToJSON, t.importFromExcel = t.ext.export_api.importFromExcel, t.importFromMSProject = t.ext.export_api.importFromMSProject, t.exportToMSProject = t.ext.export_api.exportToMSProject, t.importFromPrimaveraP6 = t.ext.export_api.importFromPrimaveraP6, t.exportToPrimaveraP6 = t.ext.export_api.exportToPrimaveraP6, t.ext.export_api;
      } }, Fn = { KEY_CODES: { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39, SPACE: 32, ENTER: 13, DELETE: 46, ESC: 27, TAB: 9 } };
      class Vn {
        constructor(e) {
          this.addExtension = (n, i) => {
            this._extensions[n] = i;
          }, this.getExtension = (n) => this._extensions[n], this._extensions = {};
          for (const n in e) this._extensions[n] = e[n];
        }
      }
      const Un = () => ({ layout: { css: "gantt_container", rows: [{ cols: [{ view: "grid", scrollX: "scrollHor", scrollY: "scrollVer" }, { resizer: true, width: 1 }, { view: "timeline", scrollX: "scrollHor", scrollY: "scrollVer" }, { view: "scrollbar", id: "scrollVer" }] }, { view: "scrollbar", id: "scrollHor", height: 20 }] }, links: { finish_to_start: "0", start_to_start: "1", finish_to_finish: "2", start_to_finish: "3" }, types: { task: "task", project: "project", milestone: "milestone" }, auto_types: false, duration_unit: "day", work_time: false, correct_work_time: false, skip_off_time: false, cascade_delete: true, autosize: false, autosize_min_width: 0, autoscroll: true, autoscroll_speed: 30, deepcopy_on_parse: false, show_links: true, show_task_cells: true, static_background: false, static_background_cells: true, branch_loading: false, branch_loading_property: "$has_child", show_loading: false, show_chart: true, show_grid: true, min_duration: 36e5, date_format: "%d-%m-%Y %H:%i", xml_date: void 0, start_on_monday: true, server_utc: false, show_progress: true, fit_tasks: false, select_task: true, scroll_on_click: true, smart_rendering: true, preserve_scroll: true, readonly: false, container_resize_timeout: 20, deadlines: true, date_grid: "%Y-%m-%d", drag_links: true, drag_progress: true, drag_resize: true, drag_project: false, drag_move: true, drag_mode: { resize: "resize", progress: "progress", move: "move", ignore: "ignore" }, round_dnd_dates: true, link_wrapper_width: 20, link_arrow_size: 12, root_id: 0, autofit: false, columns: [{ name: "text", tree: true, width: "*", resize: true }, { name: "start_date", align: "center", resize: true }, { name: "duration", align: "center" }, { name: "add", width: 44 }], scale_offset_minimal: true, inherit_scale_class: false, scales: [{ unit: "day", step: 1, date: "%d %M" }], time_step: 60, duration_step: 1, task_date: "%d %F %Y", time_picker: "%H:%i", task_attribute: "data-task-id", link_attribute: "data-link-id", layer_attribute: "data-layer", buttons_left: ["gantt_save_btn", "gantt_cancel_btn"], _migrate_buttons: { dhx_save_btn: "gantt_save_btn", dhx_cancel_btn: "gantt_cancel_btn", dhx_delete_btn: "gantt_delete_btn" }, buttons_right: ["gantt_delete_btn"], lightbox: { sections: [{ name: "description", height: 70, map_to: "text", type: "textarea", focus: true }, { name: "time", type: "duration", map_to: "auto" }], project_sections: [{ name: "description", height: 70, map_to: "text", type: "textarea", focus: true }, { name: "type", type: "typeselect", map_to: "type" }, { name: "time", type: "duration", readonly: true, map_to: "auto" }], milestone_sections: [{ name: "description", height: 70, map_to: "text", type: "textarea", focus: true }, { name: "type", type: "typeselect", map_to: "type" }, { name: "time", type: "duration", single_date: true, map_to: "auto" }] }, drag_lightbox: true, sort: false, details_on_create: true, details_on_dblclick: true, initial_scroll: true, task_scroll_offset: 100, order_branch: false, order_branch_free: false, task_height: void 0, bar_height: "full", bar_height_padding: 9, min_column_width: 70, min_grid_column_width: 70, grid_resizer_column_attribute: "data-column-index", keep_grid_width: false, grid_resize: false, grid_elastic_columns: false, show_tasks_outside_timescale: false, show_unscheduled: true, resize_rows: false, task_grid_row_resizer_attribute: "data-row-index", min_task_grid_row_height: 30, row_height: 36, readonly_property: "readonly", editable_property: "editable", calendar_property: "calendar_id", resource_calendars: {}, dynamic_resource_calendars: false, inherit_calendar: false, type_renderers: {}, open_tree_initially: false, optimize_render: true, prevent_default_scroll: false, show_errors: true, wai_aria_attributes: true, smart_scales: true, rtl: false, placeholder_task: false, horizontal_scroll_key: "shiftKey", drag_timeline: { useKey: void 0, ignore: ".gantt_task_line, .gantt_task_link", render: false }, drag_multiple: true, csp: "auto" });
      var rt = typeof window < "u";
      const ht = { isIE: rt && (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0), isIE6: rt && !XMLHttpRequest && navigator.userAgent.indexOf("MSIE") >= 0, isIE7: rt && navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") < 0, isIE8: rt && navigator.userAgent.indexOf("MSIE 8.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0, isOpera: rt && navigator.userAgent.indexOf("Opera") >= 0, isChrome: rt && navigator.userAgent.indexOf("Chrome") >= 0, isKHTML: rt && (navigator.userAgent.indexOf("Safari") >= 0 || navigator.userAgent.indexOf("Konqueror") >= 0), isFF: rt && navigator.userAgent.indexOf("Firefox") >= 0, isIPad: rt && navigator.userAgent.search(/iPad/gi) >= 0, isEdge: rt && navigator.userAgent.indexOf("Edge") != -1, isNode: !rt || typeof navigator > "u" || false };
      function je(t) {
        if (typeof t == "string" || typeof t == "number") return t;
        let e = "";
        for (const n in t) {
          let i = "";
          t.hasOwnProperty(n) && (i = typeof t[n] == "string" ? encodeURIComponent(t[n]) : typeof t[n] == "number" ? String(t[n]) : encodeURIComponent(JSON.stringify(t[n])), i = n + "=" + i, e.length && (i = "&" + i), e += i);
        }
        return e;
      }
      function $t(t, e) {
        var n = { method: t };
        if (e.length === 0) throw new Error("Arguments list of query is wrong.");
        if (e.length === 1) return typeof e[0] == "string" ? (n.url = e[0], n.async = true) : (n.url = e[0].url, n.async = e[0].async || true, n.callback = e[0].callback, n.headers = e[0].headers), e[0].data ? typeof e[0].data != "string" ? n.data = je(e[0].data) : n.data = e[0].data : n.data = "", n;
        switch (n.url = e[0], t) {
          case "GET":
          case "DELETE":
            n.callback = e[1], n.headers = e[2];
            break;
          case "POST":
          case "PUT":
            e[1] ? typeof e[1] != "string" ? n.data = je(e[1]) : n.data = e[1] : n.data = "", n.callback = e[2], n.headers = e[3];
        }
        return n;
      }
      const Fe = { date_to_str: (t, e, n) => {
        t = t.replace(/%[a-zA-Z]/g, (a) => {
          switch (a) {
            case "%d":
              return `"+to_fixed(date.get${e ? "UTC" : ""}Date())+"`;
            case "%m":
              return `"+to_fixed((date.get${e ? "UTC" : ""}Month()+1))+"`;
            case "%j":
              return `"+date.get${e ? "UTC" : ""}Date()+"`;
            case "%n":
              return `"+(date.get${e ? "UTC" : ""}Month()+1)+"`;
            case "%y":
              return `"+to_fixed(date.get${e ? "UTC" : ""}FullYear()%100)+"`;
            case "%Y":
              return `"+date.get${e ? "UTC" : ""}FullYear()+"`;
            case "%D":
              return `"+locale.date.day_short[date.get${e ? "UTC" : ""}Day()]+"`;
            case "%l":
              return `"+locale.date.day_full[date.get${e ? "UTC" : ""}Day()]+"`;
            case "%M":
              return `"+locale.date.month_short[date.get${e ? "UTC" : ""}Month()]+"`;
            case "%F":
              return `"+locale.date.month_full[date.get${e ? "UTC" : ""}Month()]+"`;
            case "%h":
              return `"+to_fixed((date.get${e ? "UTC" : ""}Hours()+11)%12+1)+"`;
            case "%g":
              return `"+((date.get${e ? "UTC" : ""}Hours()+11)%12+1)+"`;
            case "%G":
              return `"+date.get${e ? "UTC" : ""}Hours()+"`;
            case "%H":
              return `"+to_fixed(date.get${e ? "UTC" : ""}Hours())+"`;
            case "%i":
              return `"+to_fixed(date.get${e ? "UTC" : ""}Minutes())+"`;
            case "%a":
              return `"+(date.get${e ? "UTC" : ""}Hours()>11?"pm":"am")+"`;
            case "%A":
              return `"+(date.get${e ? "UTC" : ""}Hours()>11?"PM":"AM")+"`;
            case "%s":
              return `"+to_fixed(date.get${e ? "UTC" : ""}Seconds())+"`;
            case "%W":
              return '"+to_fixed(getISOWeek(date))+"';
            case "%w":
              return '"+to_fixed(getWeek(date))+"';
            default:
              return a;
          }
        });
        const i = new Function("date", "to_fixed", "locale", "getISOWeek", "getWeek", `return "${t}";`);
        return (a) => i(a, n.date.to_fixed, n.locale, n.date.getISOWeek, n.date.getWeek);
      }, str_to_date: (t, e, n) => {
        let i = "var temp=date.match(/[a-zA-Z]+|[0-9]+/g);";
        const a = t.match(/%[a-zA-Z]/g);
        for (let o = 0; o < a.length; o++) switch (a[o]) {
          case "%j":
          case "%d":
            i += `set[2]=temp[${o}]||1;`;
            break;
          case "%n":
          case "%m":
            i += `set[1]=(temp[${o}]||1)-1;`;
            break;
          case "%y":
            i += `set[0]=temp[${o}]*1+(temp[${o}]>50?1900:2000);`;
            break;
          case "%g":
          case "%G":
          case "%h":
          case "%H":
            i += `set[3]=temp[${o}]||0;`;
            break;
          case "%i":
            i += `set[4]=temp[${o}]||0;`;
            break;
          case "%Y":
            i += `set[0]=temp[${o}]||0;`;
            break;
          case "%a":
          case "%A":
            i += `set[3]=set[3]%12+((temp[${o}]||'').toLowerCase()=='am'?0:12);`;
            break;
          case "%s":
            i += `set[5]=temp[${o}]||0;`;
            break;
          case "%M":
            i += `set[1]=locale.date.month_short_hash[temp[${o}]]||0;`;
            break;
          case "%F":
            i += `set[1]=locale.date.month_full_hash[temp[${o}]]||0;`;
        }
        let r = "set[0],set[1],set[2],set[3],set[4],set[5]";
        e && (r = ` Date.UTC(${r})`);
        const s = new Function("date", "locale", `var set=[0,0,1,0,0,0]; ${i} return new Date(${r});`);
        return (o) => s(o, n.locale);
      } }, Ve = { date_to_str: (t, e, n) => (i) => t.replace(/%[a-zA-Z]/g, (a) => {
        switch (a) {
          case "%d":
            return e ? n.date.to_fixed(i.getUTCDate()) : n.date.to_fixed(i.getDate());
          case "%m":
            return e ? n.date.to_fixed(i.getUTCMonth() + 1) : n.date.to_fixed(i.getMonth() + 1);
          case "%j":
            return e ? i.getUTCDate() : i.getDate();
          case "%n":
            return e ? i.getUTCMonth() + 1 : i.getMonth() + 1;
          case "%y":
            return e ? n.date.to_fixed(i.getUTCFullYear() % 100) : n.date.to_fixed(i.getFullYear() % 100);
          case "%Y":
            return e ? i.getUTCFullYear() : i.getFullYear();
          case "%D":
            return e ? n.locale.date.day_short[i.getUTCDay()] : n.locale.date.day_short[i.getDay()];
          case "%l":
            return e ? n.locale.date.day_full[i.getUTCDay()] : n.locale.date.day_full[i.getDay()];
          case "%M":
            return e ? n.locale.date.month_short[i.getUTCMonth()] : n.locale.date.month_short[i.getMonth()];
          case "%F":
            return e ? n.locale.date.month_full[i.getUTCMonth()] : n.locale.date.month_full[i.getMonth()];
          case "%h":
            return e ? n.date.to_fixed((i.getUTCHours() + 11) % 12 + 1) : n.date.to_fixed((i.getHours() + 11) % 12 + 1);
          case "%g":
            return e ? (i.getUTCHours() + 11) % 12 + 1 : (i.getHours() + 11) % 12 + 1;
          case "%G":
            return e ? i.getUTCHours() : i.getHours();
          case "%H":
            return e ? n.date.to_fixed(i.getUTCHours()) : n.date.to_fixed(i.getHours());
          case "%i":
            return e ? n.date.to_fixed(i.getUTCMinutes()) : n.date.to_fixed(i.getMinutes());
          case "%a":
            return e ? i.getUTCHours() > 11 ? "pm" : "am" : i.getHours() > 11 ? "pm" : "am";
          case "%A":
            return e ? i.getUTCHours() > 11 ? "PM" : "AM" : i.getHours() > 11 ? "PM" : "AM";
          case "%s":
            return e ? n.date.to_fixed(i.getUTCSeconds()) : n.date.to_fixed(i.getSeconds());
          case "%W":
            return e ? n.date.to_fixed(n.date.getUTCISOWeek(i)) : n.date.to_fixed(n.date.getISOWeek(i));
          default:
            return a;
        }
      }), str_to_date: (t, e, n) => (i) => {
        const a = [0, 0, 1, 0, 0, 0], r = i.match(/[a-zA-Z]+|[0-9]+/g), s = t.match(/%[a-zA-Z]/g);
        for (let o = 0; o < s.length; o++) switch (s[o]) {
          case "%j":
          case "%d":
            a[2] = r[o] || 1;
            break;
          case "%n":
          case "%m":
            a[1] = (r[o] || 1) - 1;
            break;
          case "%y":
            a[0] = 1 * r[o] + (r[o] > 50 ? 1900 : 2e3);
            break;
          case "%g":
          case "%G":
          case "%h":
          case "%H":
            a[3] = r[o] || 0;
            break;
          case "%i":
            a[4] = r[o] || 0;
            break;
          case "%Y":
            a[0] = r[o] || 0;
            break;
          case "%a":
          case "%A":
            a[3] = a[3] % 12 + ((r[o] || "").toLowerCase() === "am" ? 0 : 12);
            break;
          case "%s":
            a[5] = r[o] || 0;
            break;
          case "%M":
            a[1] = n.locale.date.month_short_hash[r[o]] || 0;
            break;
          case "%F":
            a[1] = n.locale.date.month_full_hash[r[o]] || 0;
        }
        return e ? new Date(Date.UTC(a[0], a[1], a[2], a[3], a[4], a[5])) : new Date(a[0], a[1], a[2], a[3], a[4], a[5]);
      } };
      function qn(t) {
        var e = null;
        function n() {
          var a = false;
          return t.config.csp === "auto" ? (e === null && function() {
            try {
              new Function("canUseCsp = false;");
            } catch {
              e = true;
            }
          }(), a = e) : a = t.config.csp, a;
        }
        var i = { init: function() {
          for (var a = t.locale, r = a.date.month_short, s = a.date.month_short_hash = {}, o = 0; o < r.length; o++) s[r[o]] = o;
          for (r = a.date.month_full, s = a.date.month_full_hash = {}, o = 0; o < r.length; o++) s[r[o]] = o;
        }, date_part: function(a) {
          var r = new Date(a);
          return a.setHours(0), this.hour_start(a), a.getHours() && (a.getDate() < r.getDate() || a.getMonth() < r.getMonth() || a.getFullYear() < r.getFullYear()) && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())), a;
        }, time_part: function(a) {
          return (a.valueOf() / 1e3 - 60 * a.getTimezoneOffset()) % 86400;
        }, week_start: function(a) {
          var r = a.getDay();
          return t.config.start_on_monday && (r === 0 ? r = 6 : r--), this.date_part(this.add(a, -1 * r, "day"));
        }, month_start: function(a) {
          return a.setDate(1), this.date_part(a);
        }, quarter_start: function(a) {
          this.month_start(a);
          var r, s = a.getMonth();
          return r = s >= 9 ? 9 : s >= 6 ? 6 : s >= 3 ? 3 : 0, a.setMonth(r), a;
        }, year_start: function(a) {
          return a.setMonth(0), this.month_start(a);
        }, day_start: function(a) {
          return this.date_part(a);
        }, hour_start: function(a) {
          return a.getMinutes() && a.setMinutes(0), this.minute_start(a), a;
        }, minute_start: function(a) {
          return a.getSeconds() && a.setSeconds(0), a.getMilliseconds() && a.setMilliseconds(0), a;
        }, _add_days: function(a, r, s) {
          a.setDate(a.getDate() + r);
          var o = r >= 0, l = !s.getHours() && a.getHours(), d = a.getDate() <= s.getDate() || a.getMonth() < s.getMonth() || a.getFullYear() < s.getFullYear();
          return o && l && d && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())), r > 1 && l && a.setHours(0), a;
        }, add: function(a, r, s) {
          var o = new Date(a.valueOf());
          switch (s) {
            case "day":
              o = this._add_days(o, r, a);
              break;
            case "week":
              o = this._add_days(o, 7 * r, a);
              break;
            case "month":
              o.setMonth(o.getMonth() + r);
              break;
            case "year":
              o.setYear(o.getFullYear() + r);
              break;
            case "hour":
              o.setTime(o.getTime() + 60 * r * 60 * 1e3);
              break;
            case "minute":
              o.setTime(o.getTime() + 60 * r * 1e3);
              break;
            default:
              return this["add_" + s](a, r, s);
          }
          return o;
        }, add_quarter: function(a, r) {
          return this.add(a, 3 * r, "month");
        }, to_fixed: function(a) {
          return a < 10 ? "0" + a : a;
        }, copy: function(a) {
          return new Date(a.valueOf());
        }, date_to_str: function(a, r) {
          var s = Fe;
          return n() && (s = Ve), s.date_to_str(a, r, t);
        }, str_to_date: function(a, r) {
          var s = Fe;
          return n() && (s = Ve), s.str_to_date(a, r, t);
        }, getISOWeek: function(a) {
          return t.date._getWeekNumber(a, true);
        }, _getWeekNumber: function(a, r) {
          if (!a) return false;
          var s = a.getDay();
          r && s === 0 && (s = 7);
          var o = new Date(a.valueOf());
          o.setDate(a.getDate() + (4 - s));
          var l = o.getFullYear(), d = Math.round((o.getTime() - new Date(l, 0, 1).getTime()) / 864e5);
          return 1 + Math.floor(d / 7);
        }, getWeek: function(a) {
          return t.date._getWeekNumber(a, t.config.start_on_monday);
        }, getUTCISOWeek: function(a) {
          return t.date.getISOWeek(a);
        }, convert_to_utc: function(a) {
          return new Date(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate(), a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds());
        }, parseDate: function(a, r) {
          return a && !a.getFullYear && (typeof r != "function" && (r = typeof r == "string" ? r === "parse_date" || r === "xml_date" ? t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date : t.defined(t.templates[r]) ? t.templates[r] : t.date.str_to_date(r) : t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date), a = a ? r(a) : null), a;
        } };
        return i;
      }
      class Gn {
        constructor(e) {
          const { url: n, token: i } = e;
          this._url = n, this._token = i, this._mode = 1, this._seed = 1, this._queue = [], this.data = {}, this.api = {}, this._events = {};
        }
        headers() {
          return { Accept: "application/json", "Content-Type": "application/json", "Remote-Token": this._token };
        }
        fetch(e, n) {
          const i = { credentials: "include", headers: this.headers() };
          return n && (i.method = "POST", i.body = n), fetch(e, i).then((a) => a.json());
        }
        load(e) {
          return e && (this._url = e), this.fetch(this._url).then((n) => this.parse(n));
        }
        parse(e) {
          const { key: n, websocket: i } = e;
          n && (this._token = e.key);
          for (const a in e.data) this.data[a] = e.data[a];
          for (const a in e.api) {
            const r = this.api[a] = {}, s = e.api[a];
            for (const o in s) r[o] = this._wrapper(a + "." + o);
          }
          return i && this.connect(), this;
        }
        connect() {
          const e = this._socket;
          e && (this._socket = null, e.onclose = function() {
          }, e.close()), this._mode = 2, this._socket = function(n, i, a, r) {
            let s = i;
            s[0] === "/" && (s = document.location.protocol + "//" + document.location.host + i), s = s.replace(/^http(s|):/, "ws$1:");
            const o = s.indexOf("?") != -1 ? "&" : "?";
            s = `${s}${o}token=${a}&ws=1`;
            const l = new WebSocket(s);
            return l.onclose = () => setTimeout(() => n.connect(), 2e3), l.onmessage = (d) => {
              const c = JSON.parse(d.data);
              switch (c.action) {
                case "result":
                  n.result(c.body, []);
                  break;
                case "event":
                  n.fire(c.body.name, c.body.value);
                  break;
                case "start":
                  r();
                  break;
                default:
                  n.onError(c.data);
              }
            }, l;
          }(this, this._url, this._token, () => (this._mode = 3, this._send(), this._resubscribe(), this));
        }
        _wrapper(e) {
          return function() {
            const n = [].slice.call(arguments);
            let i = null;
            const a = new Promise((r, s) => {
              i = { data: { id: this._uid(), name: e, args: n }, status: 1, resolve: r, reject: s }, this._queue.push(i);
            });
            return this.onCall(i, a), this._mode === 3 ? this._send(i) : setTimeout(() => this._send(), 1), a;
          }.bind(this);
        }
        _uid() {
          return (this._seed++).toString();
        }
        _send(e) {
          if (this._mode == 2) return void setTimeout(() => this._send(), 100);
          const n = e ? [e] : this._queue.filter((a) => a.status === 1);
          if (!n.length) return;
          const i = n.map((a) => (a.status = 2, a.data));
          this._mode !== 3 ? this.fetch(this._url, JSON.stringify(i)).catch((a) => this.onError(a)).then((a) => this.result(a, i)) : this._socket.send(JSON.stringify({ action: "call", body: i }));
        }
        result(e, n) {
          const i = {};
          if (e) for (let a = 0; a < e.length; a++) i[e[a].id] = e[a];
          else for (let a = 0; a < n.length; a++) i[n[a].id] = { id: n[a].id, error: "Network Error", data: null };
          for (let a = this._queue.length - 1; a >= 0; a--) {
            const r = this._queue[a], s = i[r.data.id];
            s && (this.onResponse(r, s), s.error ? r.reject(s.error) : r.resolve(s.data), this._queue.splice(a, 1));
          }
        }
        on(e, n) {
          const i = this._uid();
          let a = this._events[e];
          const r = !!a;
          return r || (a = this._events[e] = []), a.push({ id: i, handler: n }), r || this._mode != 3 || this._socket.send(JSON.stringify({ action: "subscribe", name: e })), { name: e, id: i };
        }
        _resubscribe() {
          if (this._mode == 3) for (const e in this._events) this._socket.send(JSON.stringify({ action: "subscribe", name: e }));
        }
        detach(e) {
          if (!e) {
            if (this._mode == 3) for (const r in this._events) this._socket.send(JSON.stringify({ action: "unsubscribe", key: r }));
            return void (this._events = {});
          }
          const { id: n, name: i } = e, a = this._events[i];
          if (a) {
            const r = a.filter((s) => s.id != n);
            r.length ? this._events[i] = r : (delete this._events[i], this._mode == 3 && this._socket.send(JSON.stringify({ action: "unsubscribe", name: i })));
          }
        }
        fire(e, n) {
          const i = this._events[e];
          if (i) for (let a = 0; a < i.length; a++) i[a].handler(n);
        }
        onError(e) {
          return null;
        }
        onCall(e, n) {
        }
        onResponse(e, n) {
        }
      }
      const Yn = function(t, e) {
        const n = new Gn({ url: t, token: e });
        n.fetch = function(i, a) {
          const r = { headers: this.headers() };
          return a && (r.method = "POST", r.body = a), fetch(i, r).then((s) => s.json());
        }, this._ready = n.load().then((i) => this._remote = i), this.ready = function() {
          return this._ready;
        }, this.on = function(i, a) {
          this.ready().then((r) => {
            if (typeof i == "string") r.on(i, a);
            else for (const s in i) r.on(s, i[s]);
          });
        };
      };
      function Ue(t, e) {
        if (!e) return true;
        if (t._on_timeout) return false;
        var n = Math.ceil(1e3 / e);
        return n < 2 || (setTimeout(function() {
          delete t._on_timeout;
        }, n), t._on_timeout = true), true;
      }
      var Jn = function() {
        var t = {};
        return { getState: function(e) {
          if (t[e]) return t[e].method();
          var n = {};
          for (var i in t) t[i].internal || N(n, t[i].method(), true);
          return n;
        }, registerProvider: function(e, n, i) {
          t[e] = { method: n, internal: i };
        }, unregisterProvider: function(e) {
          delete t[e];
        } };
      };
      const Kn = Promise;
      var Q = { $create: function(t) {
        return N(t || [], this);
      }, $removeAt: function(t, e) {
        t >= 0 && this.splice(t, e || 1);
      }, $remove: function(t) {
        this.$removeAt(this.$find(t));
      }, $insertAt: function(t, e) {
        if (e || e === 0) {
          var n = this.splice(e, this.length - e);
          this[e] = t, this.push.apply(this, n);
        } else this.push(t);
      }, $find: function(t) {
        for (var e = 0; e < this.length; e++) if (t == this[e]) return e;
        return -1;
      }, $each: function(t, e) {
        for (var n = 0; n < this.length; n++) t.call(e || this, this[n]);
      }, $map: function(t, e) {
        for (var n = 0; n < this.length; n++) this[n] = t.call(e || this, this[n]);
        return this;
      }, $filter: function(t, e) {
        for (var n = 0; n < this.length; n++) t.call(e || this, this[n]) || (this.splice(n, 1), n--);
        return this;
      } };
      function Et(t, e, n, i) {
        return (i = e ? e.config : i) && i.placeholder_task && n.exists(t) ? n.getItem(t).type === i.types.placeholder : false;
      }
      var st = function(t) {
        return this.pull = {}, this.$initItem = t.initItem, this.visibleOrder = Q.$create(), this.fullOrder = Q.$create(), this._skip_refresh = false, this._filterRule = null, this._searchVisibleOrder = {}, this._indexRangeCache = {}, this._getItemsCache = null, this.$config = t, nt(this), this._attachDataChange(function() {
          return this._indexRangeCache = {}, this._getItemsCache = null, true;
        }), this;
      };
      st.prototype = { _attachDataChange: function(t) {
        this.attachEvent("onClearAll", t), this.attachEvent("onBeforeParse", t), this.attachEvent("onBeforeUpdate", t), this.attachEvent("onBeforeDelete", t), this.attachEvent("onBeforeAdd", t), this.attachEvent("onParse", t), this.attachEvent("onBeforeFilter", t);
      }, _parseInner: function(t) {
        for (var e = null, n = [], i = 0, a = t.length; i < a; i++) e = t[i], this.$initItem && (this.$config.copyOnParse() && (e = V(e)), e = this.$initItem(e)), this.callEvent("onItemLoading", [e]) && (this.pull.hasOwnProperty(e.id) || this.fullOrder.push(e.id), n.push(e), this.pull[e.id] = e);
        return n;
      }, parse: function(t) {
        this.isSilent() || this.callEvent("onBeforeParse", [t]);
        var e = this._parseInner(t);
        this.isSilent() || (this.refresh(), this.callEvent("onParse", [e]));
      }, getItem: function(t) {
        return this.pull[t];
      }, _updateOrder: function(t) {
        t.call(this.visibleOrder), t.call(this.fullOrder);
      }, updateItem: function(t, e) {
        if (j(e) || (e = this.getItem(t)), !this.isSilent() && this.callEvent("onBeforeUpdate", [e.id, e]) === false) return false;
        N(this.pull[t], e, true), this.isSilent() || (this.callEvent("onAfterUpdate", [e.id, e]), this.callEvent("onStoreUpdated", [e.id, e, "update"]));
      }, _removeItemInner: function(t) {
        this._updateOrder(function() {
          this.$remove(t);
        }), delete this.pull[t];
      }, removeItem: function(t) {
        var e = this.getItem(t);
        if (!this.isSilent() && this.callEvent("onBeforeDelete", [e.id, e]) === false) return false;
        this.callEvent("onAfterDeleteConfirmed", [e.id, e]), this._removeItemInner(t), this.isSilent() && this.callEvent("onAfterSilentDelete", [e.id, e]), this.isSilent() || (this.filter(), this.callEvent("onAfterDelete", [e.id, e]), this.callEvent("onStoreUpdated", [e.id, e, "delete"]));
      }, _addItemInner: function(t, e) {
        if (this.exists(t.id)) this.silent(function() {
          this.updateItem(t.id, t);
        });
        else {
          var n = this.visibleOrder, i = n.length;
          (!j(e) || e < 0) && (e = i), e > i && (e = Math.min(n.length, e));
        }
        this.pull[t.id] = t, this.isSilent() || this._updateOrder(function() {
          this.$find(t.id) === -1 && this.$insertAt(t.id, e);
        }), this.filter();
      }, isVisible: function(t) {
        return this.visibleOrder.$find(t) > -1;
      }, getVisibleItems: function() {
        return this.getIndexRange();
      }, addItem: function(t, e) {
        return j(t.id) || (t.id = at()), this.$initItem && (t = this.$initItem(t)), !(!this.isSilent() && this.callEvent("onBeforeAdd", [t.id, t]) === false) && (this._addItemInner(t, e), this.isSilent() || (this.callEvent("onAfterAdd", [t.id, t]), this.callEvent("onStoreUpdated", [t.id, t, "add"])), t.id);
      }, _changeIdInner: function(t, e) {
        this.pull[t] && (this.pull[e] = this.pull[t]);
        var n = this._searchVisibleOrder[t];
        this.pull[e].id = e, this._updateOrder(function() {
          this[this.$find(t)] = e;
        }), this._searchVisibleOrder[e] = n, delete this._searchVisibleOrder[t], delete this.pull[t];
      }, changeId: function(t, e) {
        this._changeIdInner(t, e), this.callEvent("onIdChange", [t, e]);
      }, exists: function(t) {
        return !!this.pull[t];
      }, _moveInner: function(t, e) {
        var n = this.getIdByIndex(t);
        this._updateOrder(function() {
          this.$removeAt(t), this.$insertAt(n, Math.min(this.length, e));
        });
      }, move: function(t, e) {
        var n = this.getIdByIndex(t), i = this.getItem(n);
        this._moveInner(t, e), this.isSilent() || this.callEvent("onStoreUpdated", [i.id, i, "move"]);
      }, clearAll: function() {
        this.$destroyed || (this.silent(function() {
          this.unselect();
        }), this.pull = {}, this.visibleOrder = Q.$create(), this.fullOrder = Q.$create(), this.isSilent() || (this.callEvent("onClearAll", []), this.refresh()));
      }, silent: function(t, e) {
        var n = false;
        this.isSilent() && (n = true), this._skip_refresh = true, t.call(e || this), n || (this._skip_refresh = false);
      }, isSilent: function() {
        return !!this._skip_refresh;
      }, arraysEqual: function(t, e) {
        if (t.length !== e.length) return false;
        for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return false;
        return true;
      }, refresh: function(t, e) {
        var n, i;
        if (!this.isSilent() && (t && (n = this.getItem(t)), i = t ? [t, n, "paint"] : [null, null, null], this.callEvent("onBeforeStoreUpdate", i) !== false)) {
          var a = this._quick_refresh && !this._mark_recompute;
          if (this._mark_recompute = false, t) {
            if (!e && !a) {
              var r = this.visibleOrder;
              this.filter(), this.arraysEqual(r, this.visibleOrder) || (t = void 0);
            }
          } else a || this.filter();
          i = t ? [t, n, "paint"] : [null, null, null], this.callEvent("onStoreUpdated", i);
        }
      }, count: function() {
        return this.fullOrder.length;
      }, countVisible: function() {
        return this.visibleOrder.length;
      }, sort: function(t) {
      }, serialize: function() {
      }, eachItem: function(t) {
        for (var e = 0; e < this.fullOrder.length; e++) {
          var n = this.getItem(this.fullOrder[e]);
          t.call(this, n);
        }
      }, find: function(t) {
        var e = [];
        return this.eachItem(function(n) {
          t(n) && e.push(n);
        }), e;
      }, filter: function(t) {
        this.isSilent() || this.callEvent("onBeforeFilter", []), this.callEvent("onPreFilter", []);
        var e = Q.$create(), n = [];
        this.eachItem(function(a) {
          this.callEvent("onFilterItem", [a.id, a]) && (Et(a.id, null, this, this._ganttConfig) ? n.push(a.id) : e.push(a.id));
        });
        for (var i = 0; i < n.length; i++) e.push(n[i]);
        for (this.visibleOrder = e, this._searchVisibleOrder = {}, i = 0; i < this.visibleOrder.length; i++) this._searchVisibleOrder[this.visibleOrder[i]] = i;
        this.isSilent() || this.callEvent("onFilter", []);
      }, getIndexRange: function(t, e) {
        var n = Math.min(e || 1 / 0, this.countVisible() - 1), i = t || 0, a = i + "-" + n;
        if (this._indexRangeCache[a]) return this._indexRangeCache[a].slice();
        for (var r = [], s = i; s <= n; s++) r.push(this.getItem(this.visibleOrder[s]));
        return this._indexRangeCache[a] = r.slice(), r;
      }, getItems: function() {
        if (this._getItemsCache) return this._getItemsCache.slice();
        var t = [];
        for (var e in this.pull) t.push(this.pull[e]);
        return this._getItemsCache = t.slice(), t;
      }, getIdByIndex: function(t) {
        return this.visibleOrder[t];
      }, getIndexById: function(t) {
        var e = this._searchVisibleOrder[t];
        return e === void 0 && (e = -1), e;
      }, _getNullIfUndefined: function(t) {
        return t === void 0 ? null : t;
      }, getFirst: function() {
        return this._getNullIfUndefined(this.visibleOrder[0]);
      }, getLast: function() {
        return this._getNullIfUndefined(this.visibleOrder[this.visibleOrder.length - 1]);
      }, getNext: function(t) {
        return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) + 1]);
      }, getPrev: function(t) {
        return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) - 1]);
      }, destructor: function() {
        this.callEvent("onDestroy", []), this.detachAllEvents(), this.$destroyed = true, this.pull = null, this.$initItem = null, this.visibleOrder = null, this.fullOrder = null, this._skip_refresh = null, this._filterRule = null, this._searchVisibleOrder = null, this._indexRangeCache = {};
      } };
      var qe = function(t) {
        var e;
        st.apply(this, [t]), this._branches = {}, this.pull = {}, this.$initItem = function(o) {
          var l = o;
          t.initItem && (l = t.initItem(l));
          var d = this.getItem(o.id);
          return d && d.parent != l.parent && this.move(l.id, l.$index || -1, l.parent || this._ganttConfig.root_id), l;
        }, this.$parentProperty = t.parentProperty || "parent", typeof t.rootId != "function" ? this.$getRootId = (e = t.rootId || 0, function() {
          return e;
        }) : this.$getRootId = t.rootId, this.$openInitially = t.openInitially, this.visibleOrder = Q.$create(), this.fullOrder = Q.$create(), this._searchVisibleOrder = {}, this._indexRangeCache = {}, this._eachItemMainRangeCache = null, this._getItemsCache = null, this._skip_refresh = false, this._ganttConfig = null, t.getConfig && (this._ganttConfig = t.getConfig());
        var n = {}, i = {}, a = {}, r = {}, s = false;
        return this._attachDataChange(function() {
          return this._indexRangeCache = {}, this._eachItemMainRangeCache = null, this._getItemsCache = null, true;
        }), this.attachEvent("onPreFilter", function() {
          this._indexRangeCache = {}, this._eachItemMainRangeCache = null, n = {}, i = {}, a = {}, r = {}, s = false, this.eachItem(function(o) {
            var l = this.getParent(o.id);
            o.$open && a[l] !== false ? a[o.id] = true : a[o.id] = false, this._isSplitItem(o) && (s = true, n[o.id] = true, i[o.id] = true), s && i[l] && (i[o.id] = true), a[l] || a[l] === void 0 ? r[o.id] = true : r[o.id] = false;
          });
        }), this.attachEvent("onFilterItem", function(o, l) {
          var d = false;
          this._ganttConfig && (d = this._ganttConfig.open_split_tasks);
          var c = r[l.id];
          return s && (c && i[l.id] && !n[l.id] && (c = !!d), i[l.id] && !n[l.id] && (l.$split_subtask = true)), l.$expanded_branch = !!r[l.id], !!c;
        }), this.attachEvent("onFilter", function() {
          n = {}, i = {}, a = {}, r = {};
        }), this;
      };
      function F(t) {
        return ht.isNode || !t.$root;
      }
      qe.prototype = N({ _buildTree: function(t) {
        for (var e = null, n = this.$getRootId(), i = 0, a = t.length; i < a; i++) e = t[i], this.setParent(e, it(this.getParent(e), n) || n);
        for (i = 0, a = t.length; i < a; i++) e = t[i], this._add_branch(e), e.$level = this.calculateItemLevel(e), e.$local_index = this.getBranchIndex(e.id), j(e.$open) || (e.$open = j(e.open) ? e.open : this.$openInitially());
        this._updateOrder();
      }, _isSplitItem: function(t) {
        return t.render == "split" && this.hasChild(t.id);
      }, parse: function(t) {
        this._skip_refresh || this.callEvent("onBeforeParse", [t]);
        var e = this._parseInner(t);
        this._buildTree(e), this.filter(), this._skip_refresh || this.callEvent("onParse", [e]);
      }, _addItemInner: function(t, e) {
        var n = this.getParent(t);
        j(n) || (n = this.$getRootId(), this.setParent(t, n));
        var i = this.getIndexById(n) + Math.min(Math.max(e, 0), this.visibleOrder.length);
        1 * i !== i && (i = void 0), st.prototype._addItemInner.call(this, t, i), this.setParent(t, n), t.hasOwnProperty("$rendered_parent") && this._move_branch(t, t.$rendered_parent), this._add_branch(t, e);
      }, _changeIdInner: function(t, e) {
        var n = this.getChildren(t), i = this._searchVisibleOrder[t];
        st.prototype._changeIdInner.call(this, t, e);
        var a = this.getParent(e);
        this._replace_branch_child(a, t, e), this._branches[t] && (this._branches[e] = this._branches[t]);
        for (var r = 0; r < n.length; r++) {
          var s = this.getItem(n[r]);
          s[this.$parentProperty] = e, s.$rendered_parent = e;
        }
        this._searchVisibleOrder[e] = i, delete this._branches[t];
      }, _traverseBranches: function(t, e) {
        j(e) || (e = this.$getRootId());
        var n = this._branches[e];
        if (n) for (var i = 0; i < n.length; i++) {
          var a = n[i];
          t.call(this, a), this._branches[a] && this._traverseBranches(t, a);
        }
      }, _updateOrder: function(t) {
        this.fullOrder = Q.$create(), this._traverseBranches(function(e) {
          this.fullOrder.push(e);
        }), t && st.prototype._updateOrder.call(this, t);
      }, _removeItemInner: function(t) {
        var e = [];
        this.eachItem(function(i) {
          e.push(i);
        }, t), e.push(this.getItem(t));
        for (var n = 0; n < e.length; n++) this._move_branch(e[n], this.getParent(e[n]), null), st.prototype._removeItemInner.call(this, e[n].id), this._move_branch(e[n], this.getParent(e[n]), null);
      }, move: function(t, e, n) {
        var i = arguments[3], a = (this._ganttConfig || {}).root_id || 0;
        if (i = it(i, a)) {
          if (i === t) return;
          n = this.getParent(i), e = this.getBranchIndex(i);
        }
        if (t != n) {
          j(n) || (n = this.$getRootId());
          var r = this.getItem(t), s = this.getParent(r.id), o = this.getChildren(n);
          if (e == -1 && (e = o.length + 1), s == n && this.getBranchIndex(t) == e) return;
          if (this.callEvent("onBeforeItemMove", [t, n, e]) === false) return false;
          for (var l = [], d = 0; d < o.length; d++) Et(o[d], null, this, this._ganttConfig) && (l.push(o[d]), o.splice(d, 1), d--);
          this._replace_branch_child(s, t);
          var c = (o = this.getChildren(n))[e];
          (c = it(c, a)) ? o = o.slice(0, e).concat([t]).concat(o.slice(e)) : o.push(t), l.length && (o = o.concat(l)), r.$rendered_parent !== s && s !== n && (r.$rendered_parent = s), this.setParent(r, n), this._branches[n] = o;
          var u = this.calculateItemLevel(r) - r.$level;
          r.$level += u, this.eachItem(function(h) {
            h.$level += u;
          }, r.id, this), this._moveInner(this.getIndexById(t), this.getIndexById(n) + e), this.callEvent("onAfterItemMove", [t, n, e]), this.refresh();
        }
      }, getBranchIndex: function(t) {
        var e = this.getChildren(this.getParent(t));
        let n = e.indexOf(t + "");
        return n == -1 && (n = e.indexOf(+t)), n;
      }, hasChild: function(t) {
        var e = this._branches[t];
        return e && e.length;
      }, getChildren: function(t) {
        var e = this._branches[t];
        return e || Q.$create();
      }, isChildOf: function(t, e) {
        if (!this.exists(t)) return false;
        if (e === this.$getRootId()) return true;
        if (!this.hasChild(e)) return false;
        var n = this.getItem(t), i = this.getParent(t);
        if (this.getItem(e).$level >= n.$level) return false;
        for (; n && this.exists(i); ) {
          if ((n = this.getItem(i)) && n.id == e) return true;
          i = this.getParent(n);
        }
        return false;
      }, getSiblings: function(t) {
        if (!this.exists(t)) return Q.$create();
        var e = this.getParent(t);
        return this.getChildren(e);
      }, getNextSibling: function(t) {
        for (var e = this.getSiblings(t), n = 0, i = e.length; n < i; n++) if (e[n] == t) {
          var a = e[n + 1];
          return a === 0 && n > 0 && (a = "0"), a || null;
        }
        return null;
      }, getPrevSibling: function(t) {
        for (var e = this.getSiblings(t), n = 0, i = e.length; n < i; n++) if (e[n] == t) {
          var a = e[n - 1];
          return a === 0 && n > 0 && (a = "0"), a || null;
        }
        return null;
      }, getParent: function(t) {
        var e = null;
        return (e = t.id !== void 0 ? t : this.getItem(t)) ? e[this.$parentProperty] : this.$getRootId();
      }, clearAll: function() {
        this._branches = {}, st.prototype.clearAll.call(this);
      }, calculateItemLevel: function(t) {
        var e = 0;
        return this.eachParent(function() {
          e++;
        }, t), e;
      }, _setParentInner: function(t, e, n) {
        n || (t.hasOwnProperty("$rendered_parent") ? this._move_branch(t, t.$rendered_parent, e) : this._move_branch(t, t[this.$parentProperty], e));
      }, setParent: function(t, e, n) {
        this._setParentInner(t, e, n), t[this.$parentProperty] = e;
      }, _eachItemCached: function(t, e) {
        for (var n = 0, i = e.length; n < i; n++) t.call(this, e[n]);
      }, _eachItemIterate: function(t, e, n) {
        var i = this.getChildren(e);
        for (i.length && (i = i.slice().reverse()); i.length; ) {
          var a = i.pop(), r = this.getItem(a);
          if (t.call(this, r), n && n.push(r), this.hasChild(r.id)) for (var s = this.getChildren(r.id), o = s.length - 1; o >= 0; o--) i.push(s[o]);
        }
      }, eachItem: function(t, e) {
        var n = this.$getRootId();
        j(e) || (e = n);
        var i = it(e, n) || n, a = false, r = false, s = null;
        i === n && (this._eachItemMainRangeCache ? (a = true, s = this._eachItemMainRangeCache) : (r = true, s = this._eachItemMainRangeCache = [])), a ? this._eachItemCached(t, s) : this._eachItemIterate(t, i, r ? s : null);
      }, eachParent: function(t, e) {
        for (var n = {}, i = e, a = this.getParent(i); this.exists(a); ) {
          if (n[a]) throw new Error("Invalid tasks tree. Cyclic reference has been detected on task " + a);
          n[a] = true, i = this.getItem(a), t.call(this, i), a = this.getParent(i);
        }
      }, _add_branch: function(t, e, n) {
        var i = n === void 0 ? this.getParent(t) : n;
        this.hasChild(i) || (this._branches[i] = Q.$create());
        var a = this.getChildren(i);
        a.indexOf(t.id + "") > -1 || a.indexOf(+t.id) > -1 || (1 * e == e ? a.splice(e, 0, t.id) : a.push(t.id), t.$rendered_parent = i);
      }, _move_branch: function(t, e, n) {
        this._eachItemMainRangeCache = null, this._replace_branch_child(e, t.id), this.exists(n) || n == this.$getRootId() ? this._add_branch(t, void 0, n) : delete this._branches[t.id], t.$level = this.calculateItemLevel(t), this.eachItem(function(i) {
          i.$level = this.calculateItemLevel(i);
        }, t.id);
      }, _replace_branch_child: function(t, e, n) {
        var i = this.getChildren(t);
        if (i && t !== void 0) {
          var a = Q.$create();
          let r = i.indexOf(e + "");
          r != -1 || isNaN(+e) || (r = i.indexOf(+e)), r > -1 && (n ? i.splice(r, 1, n) : i.splice(r, 1)), a = i, this._branches[t] = a;
        }
      }, sort: function(t, e, n) {
        this.exists(n) || (n = this.$getRootId()), t || (t = "order");
        var i = typeof t == "string" ? function(l, d) {
          return l[t] == d[t] || J(l[t]) && J(d[t]) && l[t].valueOf() == d[t].valueOf() ? 0 : l[t] > d[t] ? 1 : -1;
        } : t;
        if (e) {
          var a = i;
          i = function(l, d) {
            return a(d, l);
          };
        }
        var r = this.getChildren(n);
        if (r) {
          for (var s = [], o = r.length - 1; o >= 0; o--) s[o] = this.getItem(r[o]);
          for (s.sort(i), o = 0; o < s.length; o++) r[o] = s[o].id, this.sort(t, e, r[o]);
        }
      }, filter: function(t) {
        for (let e in this.pull) {
          const n = this.pull[e].$rendered_parent, i = this.getParent(this.pull[e]);
          n !== i && this._move_branch(this.pull[e], n, i);
        }
        return st.prototype.filter.apply(this, arguments);
      }, open: function(t) {
        this.exists(t) && (this.getItem(t).$open = true, this._skipTaskRecalculation = true, this.callEvent("onItemOpen", [t]));
      }, close: function(t) {
        this.exists(t) && (this.getItem(t).$open = false, this._skipTaskRecalculation = true, this.callEvent("onItemClose", [t]));
      }, destructor: function() {
        st.prototype.destructor.call(this), this._branches = null, this._indexRangeCache = {}, this._eachItemMainRangeCache = null;
      } }, st.prototype);
      const Xn = function(t, e) {
        const n = e.getDatastore(t), i = function(o, l) {
          const d = l.getLayers(), c = n.getItem(o);
          if (c && n.isVisible(o)) for (let u = 0; u < d.length; u++) d[u].render_item(c);
        }, a = function(o) {
          const l = o.getLayers();
          for (let g = 0; g < l.length; g++) l[g].clear();
          let d = null;
          const c = {};
          for (let g = 0; g < l.length; g++) {
            const f = l[g];
            let y;
            if (f.get_visible_range) {
              var u = f.get_visible_range(n);
              if (u.start !== void 0 && u.end !== void 0) {
                var h = u.start + " - " + u.end;
                c[h] ? y = c[h] : (y = n.getIndexRange(u.start, u.end), c[h] = y);
              } else {
                if (u.ids === void 0) throw new Error("Invalid range returned from 'getVisibleRange' of the layer");
                y = u.ids.map(function(v) {
                  return n.getItem(v);
                });
              }
            } else d || (d = n.getVisibleItems()), y = d;
            f.prepare_data && f.prepare_data(y), l[g].render_items(y);
          }
        }, r = function(o) {
          if (o.update_items) {
            let d = [];
            if (o.get_visible_range) {
              var l = o.get_visible_range(n);
              if (l.start !== void 0 && l.end !== void 0 && (d = n.getIndexRange(l.start, l.end)), l.ids !== void 0) {
                let c = l.ids.map(function(u) {
                  return n.getItem(u);
                });
                c.length > 0 && (c = c.filter((u) => u !== void 0), d = d.concat(c));
              }
              if ((l.start == null || l.end == null) && l.ids == null) throw new Error("Invalid range returned from 'getVisibleRange' of the layer");
            } else d = n.getVisibleItems();
            o.prepare_data && o.prepare_data(d, o), o.update_items(d);
          }
        };
        function s(o) {
          return !!o.$services.getService("state").getState("batchUpdate").batch_update;
        }
        n.attachEvent("onStoreUpdated", function(o, l, d) {
          if (F(e)) return true;
          const c = e.$services.getService("layers").getDataRender(t);
          c && (c.onUpdateRequest = function(u) {
            r(u);
          });
        }), n.attachEvent("onStoreUpdated", function(o, l, d) {
          s(e) || (o && d != "move" && d != "delete" ? (n.callEvent("onBeforeRefreshItem", [l.id]), n.callEvent("onAfterRefreshItem", [l.id])) : (n.callEvent("onBeforeRefreshAll", []), n.callEvent("onAfterRefreshAll", [])));
        }), n.attachEvent("onAfterRefreshAll", function() {
          if (F(e)) return true;
          const o = e.$services.getService("layers").getDataRender(t);
          o && !s(e) && a(o);
        }), n.attachEvent("onAfterRefreshItem", function(o) {
          if (F(e)) return true;
          const l = e.$services.getService("layers").getDataRender(t);
          l && i(o, l);
        }), n.attachEvent("onItemOpen", function() {
          if (F(e)) return true;
          e.render();
        }), n.attachEvent("onItemClose", function() {
          if (F(e)) return true;
          e.render();
        }), n.attachEvent("onIdChange", function(o, l) {
          if (F(e)) return true;
          if (n.callEvent("onBeforeIdChange", [o, l]), !s(e) && !n.isSilent()) {
            const d = e.$services.getService("layers").getDataRender(t);
            d ? (function(c, u, h) {
              for (let g = 0; g < c.length; g++) c[g].change_id(u, h);
            }(d.getLayers(), o, l, n.getItem(l)), i(l, d)) : e.render();
          }
        });
      };
      function se() {
        for (var t = this.$services.getService("datastores"), e = [], n = 0; n < t.length; n++) {
          var i = this.getDatastore(t[n]);
          i.$destroyed || e.push(i);
        }
        return e;
      }
      const Zn = { create: function() {
        var t = N({}, { createDatastore: function(e) {
          var n = (e.type || "").toLowerCase() == "treedatastore" ? qe : st;
          if (e) {
            var i = this;
            e.openInitially = function() {
              return i.config.open_tree_initially;
            }, e.copyOnParse = function() {
              return i.config.deepcopy_on_parse;
            };
          }
          var a = new n(e);
          if (this.mixin(a, function(o) {
            var l = null, d = o._removeItemInner;
            function c(u) {
              l = null, this.callEvent("onAfterUnselect", [u]);
            }
            return o._removeItemInner = function(u) {
              return l == u && c.call(this, u), l && this.eachItem && this.eachItem(function(h) {
                h.id == l && c.call(this, h.id);
              }, u), d.apply(this, arguments);
            }, o.attachEvent("onIdChange", function(u, h) {
              o.getSelectedId() == u && o.silent(function() {
                o.unselect(u), o.select(h);
              });
            }), { select: function(u) {
              if (u) {
                if (l == u) return l;
                if (!this._skip_refresh && !this.callEvent("onBeforeSelect", [u])) return false;
                this.unselect(), l = u, this._skip_refresh || (this.refresh(u), this.callEvent("onAfterSelect", [u]));
              }
              return l;
            }, getSelectedId: function() {
              return l;
            }, isSelected: function(u) {
              return u == l;
            }, unselect: function(u) {
              (u = u || l) && (l = null, this._skip_refresh || (this.refresh(u), c.call(this, u)));
            } };
          }(a)), e.name) {
            var r = "datastore:" + e.name;
            a.attachEvent("onDestroy", function() {
              this.$services.dropService(r);
              for (var o = this.$services.getService("datastores"), l = 0; l < o.length; l++) if (o[l] === e.name) {
                o.splice(l, 1);
                break;
              }
            }.bind(this)), this.$services.dropService(r), this.$services.setService(r, function() {
              return a;
            });
            var s = this.$services.getService("datastores");
            s ? s.indexOf(e.name) < 0 && s.push(e.name) : (s = [], this.$services.setService("datastores", function() {
              return s;
            }), s.push(e.name)), Xn(e.name, this);
          }
          return a;
        }, getDatastore: function(e) {
          return this.$services.getService("datastore:" + e);
        }, _getDatastores: se, refreshData: function() {
          var e;
          F(this) || (e = this.getScrollState()), this.callEvent("onBeforeDataRender", []);
          for (var n = se.call(this), i = 0; i < n.length; i++) n[i].refresh();
          this.config.preserve_scroll && !F(this) && (e.x || e.y) && this.scrollTo(e.x, e.y), this.callEvent("onDataRender", []);
        }, isChildOf: function(e, n) {
          return this.$data.tasksStore.isChildOf(e, n);
        }, refreshTask: function(e, n) {
          var i = this.getTask(e), a = this;
          function r() {
            if (n === void 0 || n) {
              for (var o = 0; o < i.$source.length; o++) a.refreshLink(i.$source[o]);
              for (o = 0; o < i.$target.length; o++) a.refreshLink(i.$target[o]);
            }
          }
          if (i && this.isTaskVisible(e)) this.$data.tasksStore.refresh(e, !!this.getState("tasksDnd").drag_id || n === false), r();
          else if (this.isTaskExists(e) && this.isTaskExists(this.getParent(e)) && !this._bulk_dnd) {
            this.refreshTask(this.getParent(e));
            var s = false;
            this.eachParent(function(o) {
              (s || this.isSplitTask(o)) && (s = true);
            }, e), s && r();
          }
        }, refreshLink: function(e) {
          this.$data.linksStore.refresh(e, !!this.getState("tasksDnd").drag_id);
        }, silent: function(e) {
          var n = this;
          n.$data.tasksStore.silent(function() {
            n.$data.linksStore.silent(function() {
              e();
            });
          });
        }, clearAll: function() {
          for (var e = se.call(this), n = 0; n < e.length; n++) e[n].silent(function() {
            e[n].clearAll();
          });
          for (n = 0; n < e.length; n++) e[n].clearAll();
          this._update_flags(), this.userdata = {}, this.callEvent("onClear", []), this.render();
        }, _clear_data: function() {
          this.$data.tasksStore.clearAll(), this.$data.linksStore.clearAll(), this._update_flags(), this.userdata = {};
        }, selectTask: function(e) {
          var n = this.$data.tasksStore;
          if (!this.config.select_task) return false;
          if (e = it(e, this.config.root_id)) {
            let i = this.getSelectedId();
            n._skipResourceRepaint = true, n.select(e), n._skipResourceRepaint = false, i && n.pull[i].$split_subtask && i != e && this.refreshTask(i), n.pull[e].$split_subtask && i != e && this.refreshTask(e);
          }
          return n.getSelectedId();
        }, unselectTask: function(e) {
          var n = this.$data.tasksStore;
          n.unselect(e), e && n.pull[e].$split_subtask && this.refreshTask(e);
        }, isSelectedTask: function(e) {
          return this.$data.tasksStore.isSelected(e);
        }, getSelectedId: function() {
          return this.$data.tasksStore.getSelectedId();
        } });
        return N(t, { getTask: function(e) {
          e = it(e, this.config.root_id), this.assert(e, "Invalid argument for gantt.getTask");
          var n = this.$data.tasksStore.getItem(e);
          return this.assert(n, "Task not found id=" + e), n;
        }, getTaskByTime: function(e, n) {
          var i = this.$data.tasksStore.getItems(), a = [];
          if (e || n) {
            e = +e || -1 / 0, n = +n || 1 / 0;
            for (var r = 0; r < i.length; r++) {
              var s = i[r];
              +s.start_date < n && +s.end_date > e && a.push(s);
            }
          } else a = i;
          return a;
        }, isTaskExists: function(e) {
          return !(!this.$data || !this.$data.tasksStore) && this.$data.tasksStore.exists(e);
        }, updateTask: function(e, n) {
          j(n) || (n = this.getTask(e)), this.$data.tasksStore.updateItem(e, n), this.isTaskExists(e) && this.refreshTask(e);
        }, addTask: function(e, n, i) {
          if (j(e.id) || (e.id = at()), this.isTaskExists(e.id) && this.getTask(e.id).$index != e.$index) return e.start_date && typeof e.start_date == "string" && (e.start_date = this.date.parseDate(e.start_date, "parse_date")), e.end_date && typeof e.end_date == "string" && (e.end_date = this.date.parseDate(e.end_date, "parse_date")), this.$data.tasksStore.updateItem(e.id, e);
          if (j(n) || (n = this.getParent(e) || 0), this.isTaskExists(n) || (n = this.config.root_id), this.setParent(e, n), this.getState().lightbox && this.isTaskExists(n)) {
            var a = this.getTask(n);
            this.callEvent("onAfterParentExpand", [n, a]);
          }
          return this.$data.tasksStore.addItem(e, i, n);
        }, deleteTask: function(e) {
          return e = it(e, this.config.root_id), this.$data.tasksStore.removeItem(e);
        }, getTaskCount: function() {
          return this.$data.tasksStore.count();
        }, getVisibleTaskCount: function() {
          return this.$data.tasksStore.countVisible();
        }, getTaskIndex: function(e) {
          return this.$data.tasksStore.getBranchIndex(e);
        }, getGlobalTaskIndex: function(e) {
          return e = it(e, this.config.root_id), this.assert(e, "Invalid argument"), this.$data.tasksStore.getIndexById(e);
        }, eachTask: function(e, n, i) {
          return this.$data.tasksStore.eachItem(R(e, i || this), n);
        }, eachParent: function(e, n, i) {
          return this.$data.tasksStore.eachParent(R(e, i || this), n);
        }, changeTaskId: function(e, n) {
          this.$data.tasksStore.changeId(e, n);
          var i = this.$data.tasksStore.getItem(n), a = [];
          i.$source && (a = a.concat(i.$source)), i.$target && (a = a.concat(i.$target));
          for (var r = 0; r < a.length; r++) {
            var s = this.getLink(a[r]);
            s.source == e && (s.source = n), s.target == e && (s.target = n);
          }
        }, calculateTaskLevel: function(e) {
          return this.$data.tasksStore.calculateItemLevel(e);
        }, getNext: function(e) {
          return this.$data.tasksStore.getNext(e);
        }, getPrev: function(e) {
          return this.$data.tasksStore.getPrev(e);
        }, getParent: function(e) {
          return this.$data.tasksStore.getParent(e);
        }, setParent: function(e, n, i) {
          return this.$data.tasksStore.setParent(e, n, i);
        }, getSiblings: function(e) {
          return this.$data.tasksStore.getSiblings(e).slice();
        }, getNextSibling: function(e) {
          return this.$data.tasksStore.getNextSibling(e);
        }, getPrevSibling: function(e) {
          return this.$data.tasksStore.getPrevSibling(e);
        }, getTaskByIndex: function(e) {
          var n = this.$data.tasksStore.getIdByIndex(e);
          return this.isTaskExists(n) ? this.getTask(n) : null;
        }, getChildren: function(e) {
          return this.hasChild(e) ? this.$data.tasksStore.getChildren(e).slice() : [];
        }, hasChild: function(e) {
          return this.$data.tasksStore.hasChild(e);
        }, open: function(e) {
          this.$data.tasksStore.open(e);
        }, close: function(e) {
          this.$data.tasksStore.close(e);
        }, moveTask: function(e, n, i) {
          return i = it(i, this.config.root_id), this.$data.tasksStore.move.apply(this.$data.tasksStore, arguments);
        }, sort: function(e, n, i, a) {
          var r = !a;
          this.$data.tasksStore.sort(e, n, i), this.callEvent("onAfterSort", [e, n, i]), r && this.render();
        } }), N(t, { getLinkCount: function() {
          return this.$data.linksStore.count();
        }, getLink: function(e) {
          return this.$data.linksStore.getItem(e);
        }, getLinks: function() {
          return this.$data.linksStore.getItems();
        }, isLinkExists: function(e) {
          return this.$data.linksStore.exists(e);
        }, addLink: function(e) {
          const n = this.$data.linksStore.addItem(e);
          return this.$data.linksStore.isSilent() && this.$data.linksStore.fullOrder.push(n), n;
        }, updateLink: function(e, n) {
          j(n) || (n = this.getLink(e)), this.$data.linksStore.updateItem(e, n);
        }, deleteLink: function(e) {
          return this.$data.linksStore.removeItem(e);
        }, changeLinkId: function(e, n) {
          return this.$data.linksStore.changeId(e, n);
        } }), t;
      } };
      function oe(t) {
        var e = t.date, n = t.$services;
        return { getSum: function(i, a, r) {
          r === void 0 && (r = i.length - 1), a === void 0 && (a = 0);
          for (var s = 0, o = a; o <= r; o++) s += i[o];
          return s;
        }, setSumWidth: function(i, a, r, s) {
          var o = a.width;
          s === void 0 && (s = o.length - 1), r === void 0 && (r = 0);
          var l = s - r + 1;
          if (!(r > o.length - 1 || l <= 0 || s > o.length - 1)) {
            var d = i - this.getSum(o, r, s);
            this.adjustSize(d, o, r, s), this.adjustSize(-d, o, s + 1), a.full_width = this.getSum(o);
          }
        }, splitSize: function(i, a) {
          for (var r = [], s = 0; s < a; s++) r[s] = 0;
          return this.adjustSize(i, r), r;
        }, adjustSize: function(i, a, r, s) {
          r || (r = 0), s === void 0 && (s = a.length - 1);
          for (var o = s - r + 1, l = this.getSum(a, r, s), d = r; d <= s; d++) {
            var c = Math.floor(i * (l ? a[d] / l : 1 / o));
            l -= a[d], i -= c, o--, a[d] += c;
          }
          a[a.length - 1] += i;
        }, sortScales: function(i) {
          function a(s, o) {
            var l = new Date(1970, 0, 1);
            return e.add(l, o, s) - l;
          }
          i.sort(function(s, o) {
            return a(s.unit, s.step) < a(o.unit, o.step) ? 1 : a(s.unit, s.step) > a(o.unit, o.step) ? -1 : 0;
          });
          for (var r = 0; r < i.length; r++) i[r].index = r;
        }, _isLegacyMode: function(i) {
          var a = i || t.config;
          return a.scale_unit || a.date_scale || a.subscales;
        }, _prepareScaleObject: function(i) {
          var a = i.format;
          return a || (a = i.template || i.date || "%d %M"), typeof a == "string" && (a = t.date.date_to_str(a)), { unit: i.unit || "day", step: i.step || 1, format: a, css: i.css };
        }, primaryScale: function(i) {
          var a, r = n.getService("templateLoader"), s = this._isLegacyMode(i), o = i || t.config;
          if (s) r.initTemplate("date_scale", void 0, void 0, o, t.config.templates), a = { unit: t.config.scale_unit, step: t.config.step, template: t.templates.date_scale, date: t.config.date_scale, css: t.templates.scale_cell_class };
          else {
            var l = o.scales[0];
            a = { unit: l.unit, step: l.step, template: l.template, format: l.format, date: l.date, css: l.css || t.templates.scale_cell_class };
          }
          return this._prepareScaleObject(a);
        }, getSubScales: function(i) {
          var a, r = this._isLegacyMode(i), s = i || t.config;
          if (r) {
            let o = "https://docs.dhtmlx.com/gantt/migrating.html#:~:text=%3D%20false%3B-,Time%20scale%20settings,-Configuration%20of%20time";
            t.env.isFF && (o = "https://docs.dhtmlx.com/gantt/migrating.html#6162"), console.warn(`You are using the obsolete scale configuration.
It will stop working in the future versions.
Please migrate the configuration to the newer version:
${o}`), a = s.subscales || [];
          } else a = s.scales.slice(1);
          return a.map(function(o) {
            return this._prepareScaleObject(o);
          }.bind(this));
        }, prepareConfigs: function(i, a, r, s, o, l, d) {
          for (var c = this.splitSize(s, i.length), u = r, h = [], g = i.length - 1; g >= 0; g--) {
            var f = g == i.length - 1, y = this.initScaleConfig(i[g], o, l);
            f && this.processIgnores(y), this.initColSizes(y, a, u, c[g]), this.limitVisibleRange(y), f && (u = y.full_width), h.unshift(y);
          }
          for (g = 0; g < h.length - 1; g++) this.alineScaleColumns(h[h.length - 1], h[g]);
          for (g = 0; g < h.length; g++) d && this.reverseScale(h[g]), this.setPosSettings(h[g]);
          return h;
        }, reverseScale: function(i) {
          i.width = i.width.reverse(), i.trace_x = i.trace_x.reverse();
          var a = i.trace_indexes;
          i.trace_indexes = {}, i.trace_index_transition = {}, i.rtl = true;
          for (var r = 0; r < i.trace_x.length; r++) i.trace_indexes[i.trace_x[r].valueOf()] = r, i.trace_index_transition[a[i.trace_x[r].valueOf()]] = r;
          return i;
        }, setPosSettings: function(i) {
          for (var a = 0, r = i.trace_x.length; a < r; a++) i.left.push((i.width[a - 1] || 0) + (i.left[a - 1] || 0));
        }, _ignore_time_config: function(i, a) {
          if (t.config.skip_off_time) {
            for (var r = true, s = i, o = 0; o < a.step; o++) o && (s = e.add(i, o, a.unit)), r = r && !this.isWorkTime(s, a.unit);
            return r;
          }
          return false;
        }, processIgnores: function(i) {
          i.ignore_x = {}, i.display_count = i.count;
        }, initColSizes: function(i, a, r, s) {
          var o = r;
          i.height = s;
          var l = i.display_count === void 0 ? i.count : i.display_count;
          l || (l = 1), i.col_width = Math.floor(o / l), a && i.col_width < a && (i.col_width = a, o = i.col_width * l), i.width = [];
          for (var d = i.ignore_x || {}, c = 0; c < i.trace_x.length; c++) if (d[i.trace_x[c].valueOf()] || i.display_count == i.count) i.width[c] = 0;
          else {
            var u = 1;
            i.unit == "month" && (u = Math.round((e.add(i.trace_x[c], i.step, i.unit) - i.trace_x[c]) / 864e5)), i.width[c] = u;
          }
          this.adjustSize(o - this.getSum(i.width), i.width), i.full_width = this.getSum(i.width);
        }, initScaleConfig: function(i, a, r) {
          var s = N({ count: 0, col_width: 0, full_width: 0, height: 0, width: [], left: [], trace_x: [], trace_indexes: {}, min_date: new Date(a), max_date: new Date(r) }, i);
          return this.eachColumn(i.unit, i.step, a, r, function(o) {
            s.count++, s.trace_x.push(new Date(o)), s.trace_indexes[o.valueOf()] = s.trace_x.length - 1;
          }), s.trace_x_ascending = s.trace_x.slice(), s;
        }, iterateScales: function(i, a, r, s, o) {
          for (var l = a.trace_x, d = i.trace_x, c = r || 0, u = s || d.length - 1, h = 0, g = 1; g < l.length; g++) {
            var f = i.trace_indexes[+l[g]];
            f !== void 0 && f <= u && (o && o.apply(this, [h, g, c, f]), c = f, h = g);
          }
        }, alineScaleColumns: function(i, a, r, s) {
          this.iterateScales(i, a, r, s, function(o, l, d, c) {
            var u = this.getSum(i.width, d, c - 1);
            this.getSum(a.width, o, l - 1) != u && this.setSumWidth(u, a, o, l - 1);
          });
        }, eachColumn: function(i, a, r, s, o) {
          var l = new Date(r), d = new Date(s);
          e[i + "_start"] && (l = e[i + "_start"](l));
          var c = new Date(l);
          for (+c >= +d && (d = e.add(c, a, i)); +c < +d; ) {
            o.call(this, new Date(c));
            var u = c.getTimezoneOffset();
            c = e.add(c, a, i), c = t._correct_dst_change(c, u, a, i), e[i + "_start"] && (c = e[i + "_start"](c));
          }
        }, limitVisibleRange: function(i) {
          var a = i.trace_x, r = i.width.length - 1, s = 0;
          if (+a[0] < +i.min_date && r != 0) {
            var o = Math.floor(i.width[0] * ((a[1] - i.min_date) / (a[1] - a[0])));
            s += i.width[0] - o, i.width[0] = o, a[0] = new Date(i.min_date);
          }
          var l = a.length - 1, d = a[l], c = e.add(d, i.step, i.unit);
          if (+c > +i.max_date && l > 0 && (o = i.width[l] - Math.floor(i.width[l] * ((c - i.max_date) / (c - d))), s += i.width[l] - o, i.width[l] = o), s) {
            for (var u = this.getSum(i.width), h = 0, g = 0; g < i.width.length; g++) {
              var f = Math.floor(s * (i.width[g] / u));
              i.width[g] += f, h += f;
            }
            this.adjustSize(s - h, i.width);
          }
        } };
      }
      function Qn(t) {
        var e = function(c) {
          var u = new oe(c).primaryScale(), h = u.unit, g = u.step;
          if (c.config.scale_offset_minimal) {
            var f = new oe(c), y = [f.primaryScale()].concat(f.getSubScales());
            f.sortScales(y), h = y[y.length - 1].unit, g = y[y.length - 1].step || 1;
          }
          return { unit: h, step: g };
        }(t), n = e.unit, i = e.step, a = function(c, u) {
          var h = { start_date: null, end_date: null };
          if (u.config.start_date && u.config.end_date) {
            h.start_date = u.date[c + "_start"](new Date(u.config.start_date));
            var g = new Date(u.config.end_date), f = u.date[c + "_start"](new Date(g));
            g = +g != +f ? u.date.add(f, 1, c) : f, h.end_date = g;
          }
          return h;
        }(n, t);
        if (!a.start_date || !a.end_date) {
          for (var r = true, s = t.getTaskByTime(), o = 0; o < s.length; o++) if (s[o].type !== t.config.types.project) {
            r = false;
            break;
          }
          if (s.length && r) {
            var l = s[0].start_date, d = t.date.add(l, 1, t.config.duration_unit);
            a = { start_date: new Date(l), end_date: new Date(d) };
          } else a = t.getSubtaskDates();
          a.start_date && a.end_date || (a = { start_date: /* @__PURE__ */ new Date(), end_date: /* @__PURE__ */ new Date() }), t.eachTask(function(c) {
            t.config.deadlines !== false && c.deadline && le(a, c.deadline, c.deadline), c.constraint_date && c.constraint_type && t.config.constraint_types && c.constraint_type !== t.config.constraint_types.ASAP && c.constraint_type !== t.config.constraint_types.ALAP && le(a, c.constraint_date, c.constraint_date), t.config.baselines !== false && c.baselines && c.baselines.forEach(function(u) {
              le(a, u.start_date, u.end_date);
            });
          }), a.start_date = t.date[n + "_start"](a.start_date), a.start_date = t.calculateEndDate({ start_date: t.date[n + "_start"](a.start_date), duration: -1, unit: n, step: i }), a.end_date = t.date[n + "_start"](a.end_date), a.end_date = t.calculateEndDate({ start_date: a.end_date, duration: 2, unit: n, step: i });
        }
        t._min_date = a.start_date, t._max_date = a.end_date;
      }
      function le(t, e, n) {
        e < t.start_date && (t.start_date = new Date(e)), n > t.end_date && (t.end_date = new Date(n));
      }
      function de(t) {
        Qn(t), function(e) {
          if (e.config.fit_tasks) {
            var n = +e._min_date, i = +e._max_date;
            if (+e._min_date != n || +e._max_date != i) return e.render(), e.callEvent("onScaleAdjusted", []), true;
          }
        }(t);
      }
      function Ge(t, e, n) {
        for (var i = 0; i < e.length; i++) t.isLinkExists(e[i]) && (n[e[i]] = t.getLink(e[i]));
      }
      function Ye(t, e, n) {
        Ge(t, e.$source, n), Ge(t, e.$target, n);
      }
      const ce = { getSubtreeLinks: function(t, e) {
        var n = {};
        return t.isTaskExists(e) && Ye(t, t.getTask(e), n), t.eachTask(function(i) {
          Ye(t, i, n);
        }, e), n;
      }, getSubtreeTasks: function(t, e) {
        var n = {};
        return t.eachTask(function(i) {
          n[i.id] = i;
        }, e), n;
      } };
      class ti {
        constructor(e, n) {
          this.$gantt = e, this.$dp = n, this._dataProcessorHandlers = [];
        }
        attach() {
          const e = this.$dp, n = this.$gantt, i = {}, a = (o) => this.clientSideDelete(o, e, n);
          this._dataProcessorHandlers.push(n.attachEvent("onAfterTaskAdd", function(o, l) {
            n.isTaskExists(o) && (e.setGanttMode("tasks"), e.setUpdated(o, true, "inserted"));
          })), this._dataProcessorHandlers.push(n.attachEvent("onAfterTaskUpdate", function(o, l) {
            n.isTaskExists(o) && (e.setGanttMode("tasks"), e.setUpdated(o, true), n._sendTaskOrder && n._sendTaskOrder(o, l));
          })), this._dataProcessorHandlers.push(n.attachEvent("onBeforeTaskDelete", function(o, l) {
            return n.config.cascade_delete && (i[o] = { tasks: ce.getSubtreeTasks(n, o), links: ce.getSubtreeLinks(n, o) }), !e.deleteAfterConfirmation || (e.setGanttMode("tasks"), e.setUpdated(o, true, "deleted"), false);
          })), this._dataProcessorHandlers.push(n.attachEvent("onAfterTaskDelete", function(o, l) {
            e.setGanttMode("tasks");
            const d = !a(o), c = n.config.cascade_delete && i[o];
            if (d || c) {
              if (c) {
                const u = e.updateMode;
                e.setUpdateMode("off");
                const h = i[o];
                for (const g in h.tasks) a(g) || (e.storeItem(h.tasks[g]), e.setUpdated(g, true, "deleted"));
                e.setGanttMode("links");
                for (const g in h.links) a(g) || (e.storeItem(h.links[g]), e.setUpdated(g, true, "deleted"));
                i[o] = null, u !== "off" && e.sendAllData(), e.setGanttMode("tasks"), e.setUpdateMode(u);
              }
              d && (e.storeItem(l), e.deleteAfterConfirmation || e.setUpdated(o, true, "deleted")), e.updateMode === "off" || e._tSend || e.sendAllData();
            }
          })), this._dataProcessorHandlers.push(n.attachEvent("onAfterLinkUpdate", function(o, l) {
            n.isLinkExists(o) && (e.setGanttMode("links"), e.setUpdated(o, true));
          })), this._dataProcessorHandlers.push(n.attachEvent("onAfterLinkAdd", function(o, l) {
            n.isLinkExists(o) && (e.setGanttMode("links"), e.setUpdated(o, true, "inserted"));
          })), this._dataProcessorHandlers.push(n.attachEvent("onAfterLinkDelete", function(o, l) {
            e.setGanttMode("links"), !a(o) && (e.storeItem(l), e.setUpdated(o, true, "deleted"));
          })), this._dataProcessorHandlers.push(n.attachEvent("onRowDragEnd", function(o, l) {
            n._sendTaskOrder(o, n.getTask(o));
          }));
          let r = null, s = null;
          this._dataProcessorHandlers.push(n.attachEvent("onTaskIdChange", function(o, l) {
            if (!e._waitMode) return;
            const d = n.getChildren(l);
            if (d.length) {
              r = r || {};
              for (let u = 0; u < d.length; u++) {
                const h = this.getTask(d[u]);
                r[h.id] = h;
              }
            }
            const c = function(u) {
              let h = [];
              return u.$source && (h = h.concat(u.$source)), u.$target && (h = h.concat(u.$target)), h;
            }(this.getTask(l));
            if (c.length) {
              s = s || {};
              for (let u = 0; u < c.length; u++) {
                const h = this.getLink(c[u]);
                s[h.id] = h;
              }
            }
          })), e.attachEvent("onAfterUpdateFinish", function() {
            (r || s) && (n.batchUpdate(function() {
              for (const o in r) n.updateTask(r[o].id);
              for (const o in s) n.updateLink(s[o].id);
              r = null, s = null;
            }), r ? n._dp.setGanttMode("tasks") : n._dp.setGanttMode("links"));
          }), e.attachEvent("onBeforeDataSending", function() {
            if (this._tMode === "CUSTOM") return true;
            let o = this._serverProcessor;
            if (this._tMode === "REST-JSON" || this._tMode === "REST") {
              const l = this._ganttMode;
              o = o.substring(0, o.indexOf("?") > -1 ? o.indexOf("?") : o.length), this.serverProcessor = o + (o.slice(-1) === "/" ? "" : "/") + l;
            } else {
              const l = this._ganttMode + "s";
              this.serverProcessor = o + n.ajax.urlSeparator(o) + "gantt_mode=" + l;
            }
            return true;
          }), e.attachEvent("insertCallback", function(o, l, d, c) {
            const u = o.data || n.xml._xmlNodeToJSON(o.firstChild), h = { add: n.addTask, isExist: n.isTaskExists };
            c === "links" && (h.add = n.addLink, h.isExist = n.isLinkExists), h.isExist.call(n, l) || (u.id = l, h.add.call(n, u));
          }), e.attachEvent("updateCallback", function(o, l) {
            const d = o.data || n.xml._xmlNodeToJSON(o.firstChild);
            if (!n.isTaskExists(l)) return;
            const c = n.getTask(l);
            for (const u in d) {
              let h = d[u];
              switch (u) {
                case "id":
                  continue;
                case "start_date":
                case "end_date":
                  h = n.defined(n.templates.xml_date) ? n.templates.xml_date(h) : n.templates.parse_date(h);
                  break;
                case "duration":
                  c.end_date = n.calculateEndDate({ start_date: c.start_date, duration: h, task: c });
              }
              c[u] = h;
            }
            n.updateTask(l), n.refreshData();
          }), e.attachEvent("deleteCallback", function(o, l, d, c) {
            const u = { delete: n.deleteTask, isExist: n.isTaskExists };
            c === "links" ? (u.delete = n.deleteLink, u.isExist = n.isLinkExists) : c === "assignment" && (u.delete = function(h) {
              n.$data.assignmentsStore.remove(h);
            }, u.isExist = function(h) {
              return n.$data.assignmentsStore.exists(h);
            }), u.isExist.call(n, l) && u.delete.call(n, l);
          }), this.handleResourceCRUD(e, n), this.handleResourceAssignmentCRUD(e, n), this.handleBaselineCRUD(e, n);
        }
        clientSideDelete(e, n, i) {
          const a = n.updatedRows.slice();
          let r = false;
          i.getUserData(e, "!nativeeditor_status", n._ganttMode) === "true_deleted" && (r = true, n.setUpdated(e, false));
          for (let s = 0; s < a.length && !n._in_progress[e]; s++) a[s] === e && (i.getUserData(e, "!nativeeditor_status", n._ganttMode) === "inserted" && (r = true), n.setUpdated(e, false));
          return r;
        }
        handleResourceAssignmentCRUD(e, n) {
          if (!n.config.resources || n.config.resources.dataprocessor_assignments !== true) return;
          const i = n.getDatastore(n.config.resource_assignment_store), a = {}, r = {};
          function s(o) {
            const l = o.id;
            i.exists(l) && (e.setGanttMode("assignment"), e.setUpdated(l, true, "inserted")), delete r[l];
          }
          n.attachEvent("onBeforeTaskAdd", function(o, l) {
            return a[o] = true, true;
          }), n.attachEvent("onTaskIdChange", function(o, l) {
            delete a[o];
          }), i.attachEvent("onAfterAdd", (o, l) => {
            a[l.task_id] ? function(d) {
              r[d.id] = d, a[d.task_id] = true;
            }(l) : s(l);
          }), i.attachEvent("onAfterUpdate", (o, l) => {
            i.exists(o) && (r[o] ? s(l) : (e.setGanttMode("assignment"), e.setUpdated(o, true)));
          }), i.attachEvent("onAfterDelete", (o, l) => {
            e.setGanttMode("assignment"), !this.clientSideDelete(o, e, n) && (e.storeItem(l), e.setUpdated(o, true, "deleted"));
          });
        }
        handleResourceCRUD(e, n) {
          if (!n.config.resources || n.config.resources.dataprocessor_resources !== true) return;
          const i = n.getDatastore(n.config.resource_store);
          i.attachEvent("onAfterAdd", (a, r) => {
            (function(s) {
              const o = s.id;
              i.exists(o) && (e.setGanttMode("resource"), e.setUpdated(o, true, "inserted"));
            })(r);
          }), i.attachEvent("onAfterUpdate", (a, r) => {
            i.exists(a) && (e.setGanttMode("resource"), e.setUpdated(a, true));
          }), i.attachEvent("onAfterDelete", (a, r) => {
            e.setGanttMode("resource"), !this.clientSideDelete(a, e, n) && (e.storeItem(r), e.setUpdated(a, true, "deleted"));
          });
        }
        handleBaselineCRUD(e, n) {
          if (!n.config.baselines || n.config.baselines.dataprocessor_baselines !== true) return;
          const i = n.getDatastore(n.config.baselines.datastore);
          i.attachEvent("onAfterAdd", (a, r) => {
            (function(s) {
              const o = s.id;
              i.exists(o) && (e.setGanttMode("baseline"), e.setUpdated(o, true, "inserted"));
            })(r);
          }), i.attachEvent("onAfterUpdate", (a, r) => {
            i.exists(a) && (e.setGanttMode("baseline"), e.setUpdated(a, true));
          }), i.attachEvent("onAfterDelete", (a, r) => {
            e.setGanttMode("baseline"), !this.clientSideDelete(a, e, n) && (e.storeItem(r), e.setUpdated(a, true, "deleted"));
          });
        }
        detach() {
          kt(this._dataProcessorHandlers, (e) => {
            this.$gantt.detachEvent(e);
          }), this._dataProcessorHandlers = [];
        }
      }
      const Yt = class Yt {
        constructor() {
          this.clear = () => {
            this._storage = {};
          }, this.storeItem = (e) => {
            this._storage[e.id] = V(e);
          }, this.getStoredItem = (e) => this._storage[e] || null, this._storage = {};
        }
      };
      Yt.create = () => new Yt();
      let Wt = Yt, Je = class {
        constructor(t) {
          this.serverProcessor = t, this.action_param = "!nativeeditor_status", this.updatedRows = [], this.autoUpdate = true, this.updateMode = "cell", this._headers = null, this._payload = null, this._postDelim = "_", this._routerParametersFormat = "parameters", this._waitMode = 0, this._in_progress = {}, this._storage = Wt.create(), this._invalid = {}, this.messages = [], this.styles = { updated: "font-weight:bold;", inserted: "font-weight:bold;", deleted: "text-decoration : line-through;", invalid: "background-color:FFE0E0;", invalid_cell: "border-bottom:2px solid red;", error: "color:red;", clear: "font-weight:normal;text-decoration:none;" }, this.enableUTFencoding(true), nt(this);
        }
        setTransactionMode(t, e) {
          typeof t == "object" ? (this._tMode = t.mode || this._tMode, j(t.headers) && (this._headers = t.headers), j(t.payload) && (this._payload = t.payload), this._tSend = !!e) : (this._tMode = t, this._tSend = e), this._tMode === "REST" && (this._tSend = false), this._tMode === "JSON" || this._tMode === "REST-JSON" ? (this._tSend = false, this._serializeAsJson = true, this._headers = this._headers || {}, this._headers["Content-Type"] = "application/json") : this._headers && !this._headers["Content-Type"] && (this._headers["Content-Type"] = "application/x-www-form-urlencoded"), this._tMode === "CUSTOM" && (this._tSend = false, this._router = t.router);
        }
        escape(t) {
          return this._utf ? encodeURIComponent(t) : escape(t);
        }
        enableUTFencoding(t) {
          this._utf = !!t;
        }
        getSyncState() {
          return !this.updatedRows.length;
        }
        setUpdateMode(t, e) {
          this.autoUpdate = t === "cell", this.updateMode = t, this.dnd = e;
        }
        ignore(t, e) {
          this._silent_mode = true, t.call(e || lt), this._silent_mode = false;
        }
        setUpdated(t, e, n) {
          if (this._silent_mode) return;
          const i = this.findRow(t);
          n = n || "updated";
          const a = this.$gantt.getUserData(t, this.action_param, this._ganttMode);
          a && n === "updated" && (n = a), e ? (this.set_invalid(t, false), this.updatedRows[i] = t, this.$gantt.setUserData(t, this.action_param, n, this._ganttMode), this._in_progress[t] && (this._in_progress[t] = "wait")) : this.is_invalid(t) || (this.updatedRows.splice(i, 1), this.$gantt.setUserData(t, this.action_param, "", this._ganttMode)), this.markRow(t, e, n), e && this.autoUpdate && this.sendData(t);
        }
        markRow(t, e, n) {
          let i = "";
          const a = this.is_invalid(t);
          if (a && (i = this.styles[a], e = true), this.callEvent("onRowMark", [t, e, n, a]) && (i = this.styles[e ? n : "clear"] + " " + i, this.$gantt[this._methods[0]](t, i), a && a.details)) {
            i += this.styles[a + "_cell"];
            for (let r = 0; r < a.details.length; r++) a.details[r] && this.$gantt[this._methods[1]](t, r, i);
          }
        }
        getActionByState(t) {
          return t === "inserted" ? "create" : t === "updated" ? "update" : t === "deleted" ? "delete" : "update";
        }
        getState(t) {
          return this.$gantt.getUserData(t, this.action_param, this._ganttMode);
        }
        is_invalid(t) {
          return this._invalid[t];
        }
        set_invalid(t, e, n) {
          n && (e = { value: e, details: n, toString: function() {
            return this.value.toString();
          } }), this._invalid[t] = e;
        }
        checkBeforeUpdate(t) {
          return true;
        }
        sendData(t) {
          if (this.$gantt.editStop && this.$gantt.editStop(), t === void 0 || this._tSend) {
            const e = [];
            if (this.modes && ["task", "link", "assignment", "baseline"].forEach((n) => {
              this.modes[n] && this.modes[n].updatedRows.length && e.push(n);
            }), e.length) {
              for (let n = 0; n < e.length; n++) this.setGanttMode(e[n]), this.sendAllData();
              return;
            }
            return this.sendAllData();
          }
          return !this._in_progress[t] && (this.messages = [], !(!this.checkBeforeUpdate(t) && this.callEvent("onValidationError", [t, this.messages])) && void this._beforeSendData(this._getRowData(t), t));
        }
        serialize(t, e) {
          if (this._serializeAsJson) return this._serializeAsJSON(t);
          if (typeof t == "string") return t;
          if (e !== void 0) return this.serialize_one(t, "");
          {
            const n = [], i = [];
            for (const a in t) t.hasOwnProperty(a) && (n.push(this.serialize_one(t[a], a + this._postDelim)), i.push(a));
            return n.push("ids=" + this.escape(i.join(","))), this.$gantt.security_key && n.push("dhx_security=" + this.$gantt.security_key), n.join("&");
          }
        }
        serialize_one(t, e) {
          if (typeof t == "string") return t;
          const n = [];
          let i = "";
          for (const a in t) if (t.hasOwnProperty(a)) {
            if ((a === "id" || a == this.action_param) && this._tMode === "REST") continue;
            i = typeof t[a] == "string" || typeof t[a] == "number" ? String(t[a]) : JSON.stringify(t[a]), n.push(this.escape((e || "") + a) + "=" + this.escape(i));
          }
          return n.join("&");
        }
        sendAllData() {
          if (!this.updatedRows.length) return;
          this.messages = [];
          let t = true;
          if (this._forEachUpdatedRow(function(e) {
            t = t && this.checkBeforeUpdate(e);
          }), !t && !this.callEvent("onValidationError", ["", this.messages])) return false;
          this._tSend ? this._sendData(this._getAllData()) : this._forEachUpdatedRow(function(e) {
            if (!this._in_progress[e]) {
              if (this.is_invalid(e)) return;
              this._beforeSendData(this._getRowData(e), e);
            }
          });
        }
        findRow(t) {
          let e = 0;
          for (e = 0; e < this.updatedRows.length && t != this.updatedRows[e]; e++) ;
          return e;
        }
        defineAction(t, e) {
          this._uActions || (this._uActions = {}), this._uActions[t] = e;
        }
        afterUpdateCallback(t, e, n, i, a) {
          if (!this.$gantt) return;
          this.setGanttMode(a);
          const r = t, s = n !== "error" && n !== "invalid";
          if (s || this.set_invalid(t, n), this._uActions && this._uActions[n] && !this._uActions[n](i)) return delete this._in_progress[r];
          this._in_progress[r] !== "wait" && this.setUpdated(t, false);
          const o = t;
          switch (n) {
            case "inserted":
            case "insert":
              e != t && (this.setUpdated(t, false), this.$gantt[this._methods[2]](t, e), t = e);
              break;
            case "delete":
            case "deleted":
              if (this.deleteAfterConfirmation && this._ganttMode === "task") {
                if (this._ganttMode === "task" && this.$gantt.isTaskExists(t)) {
                  this.$gantt.setUserData(t, this.action_param, "true_deleted", this._ganttMode);
                  const l = this.$gantt.getTask(t);
                  this.$gantt.silent(() => {
                    this.$gantt.deleteTask(t);
                  }), this.$gantt.callEvent("onAfterTaskDelete", [t, l]), this.$gantt.render(), delete this._in_progress[r];
                }
                return this.callEvent("onAfterUpdate", [t, n, e, i]);
              }
              return this.$gantt.setUserData(t, this.action_param, "true_deleted", this._ganttMode), this.$gantt[this._methods[3]](t), delete this._in_progress[r], this.callEvent("onAfterUpdate", [t, n, e, i]);
          }
          this._in_progress[r] !== "wait" ? (s && this.$gantt.setUserData(t, this.action_param, "", this._ganttMode), delete this._in_progress[r]) : (delete this._in_progress[r], this.setUpdated(e, true, this.$gantt.getUserData(t, this.action_param, this._ganttMode))), this.callEvent("onAfterUpdate", [o, n, e, i]);
        }
        afterUpdate(t, e, n) {
          let i;
          i = arguments.length === 3 ? arguments[1] : arguments[4];
          let a = this.getGanttMode();
          const r = i.filePath || i.url;
          a = this._tMode !== "REST" && this._tMode !== "REST-JSON" ? r.indexOf("gantt_mode=links") !== -1 ? "link" : r.indexOf("gantt_mode=assignments") !== -1 ? "assignment" : r.indexOf("gantt_mode=baselines") !== -1 ? "baseline" : "task" : r.indexOf("/link") >= 0 ? "link" : r.indexOf("/assignment") >= 0 ? "assignment" : r.indexOf("/baseline") >= 0 ? "baseline" : "task", this.setGanttMode(a);
          const s = this.$gantt.ajax;
          let o;
          try {
            o = JSON.parse(e.xmlDoc.responseText);
          } catch {
            e.xmlDoc.responseText.length || (o = {});
          }
          const l = (u) => {
            const h = o.action || this.getState(u) || "updated", g = o.sid || u[0], f = o.tid || u[0];
            t.afterUpdateCallback(g, f, h, o, a);
          };
          if (o) return Array.isArray(n) && n.length > 1 ? n.forEach((u) => l(u)) : l(n), t.finalizeUpdate(), void this.setGanttMode(a);
          const d = s.xmltop("data", e.xmlDoc);
          if (!d) return this.cleanUpdate(n);
          const c = s.xpath("//data/action", d);
          if (!c.length) return this.cleanUpdate(n);
          for (let u = 0; u < c.length; u++) {
            const h = c[u], g = h.getAttribute("type"), f = h.getAttribute("sid"), y = h.getAttribute("tid");
            t.afterUpdateCallback(f, y, g, h, a);
          }
          t.finalizeUpdate();
        }
        cleanUpdate(t) {
          if (t) for (let e = 0; e < t.length; e++) delete this._in_progress[t[e]];
        }
        finalizeUpdate() {
          this._waitMode && this._waitMode--, this.callEvent("onAfterUpdateFinish", []), this.updatedRows.length || this.callEvent("onFullSync", []);
        }
        init(t) {
          if (this._initialized) return;
          this.$gantt = t, this.$gantt._dp_init && this.$gantt._dp_init(this), this._setDefaultTransactionMode(), this.styles = { updated: "gantt_updated", order: "gantt_updated", inserted: "gantt_inserted", deleted: "gantt_deleted", delete_confirmation: "gantt_deleted", invalid: "gantt_invalid", error: "gantt_error", clear: "" }, this._methods = ["_row_style", "setCellTextStyle", "_change_id", "_delete_task"], function(n, i) {
            n.getUserData = function(a, r, s) {
              return this.userdata || (this.userdata = {}), this.userdata[s] = this.userdata[s] || {}, this.userdata[s][a] && this.userdata[s][a][r] ? this.userdata[s][a][r] : "";
            }, n.setUserData = function(a, r, s, o) {
              this.userdata || (this.userdata = {}), this.userdata[o] = this.userdata[o] || {}, this.userdata[o][a] = this.userdata[o][a] || {}, this.userdata[o][a][r] = s;
            }, n._change_id = function(a, r) {
              switch (this._dp._ganttMode) {
                case "task":
                  this.changeTaskId(a, r);
                  break;
                case "link":
                  this.changeLinkId(a, r);
                  break;
                case "assignment":
                  this.$data.assignmentsStore.changeId(a, r);
                  break;
                case "resource":
                  this.$data.resourcesStore.changeId(a, r);
                  break;
                case "baseline":
                  this.$data.baselineStore.changeId(a, r);
                  break;
                default:
                  throw new Error(`Invalid mode of the dataProcessor after database id is received: ${this._dp._ganttMode}, new id: ${r}`);
              }
            }, n._row_style = function(a, r) {
              this._dp._ganttMode === "task" && n.isTaskExists(a) && (n.getTask(a).$dataprocessor_class = r, n.refreshTask(a));
            }, n._delete_task = function(a, r) {
            }, n._sendTaskOrder = function(a, r) {
              r.$drop_target && (this._dp.setGanttMode("task"), this.getTask(a).target = r.$drop_target, this._dp.setUpdated(a, true, "order"), delete this.getTask(a).$drop_target);
            }, n.setDp = function() {
              this._dp = i;
            }, n.setDp();
          }(this.$gantt, this);
          const e = new ti(this.$gantt, this);
          e.attach(), this.attachEvent("onDestroy", function() {
            delete this.setGanttMode, delete this._getRowData, delete this.$gantt._dp, delete this.$gantt._change_id, delete this.$gantt._row_style, delete this.$gantt._delete_task, delete this.$gantt._sendTaskOrder, delete this.$gantt, e.detach();
          }), this.$gantt.callEvent("onDataProcessorReady", [this]), this._initialized = true;
        }
        setOnAfterUpdate(t) {
          this.attachEvent("onAfterUpdate", t);
        }
        setOnBeforeUpdateHandler(t) {
          this.attachEvent("onBeforeDataSending", t);
        }
        setAutoUpdate(t, e) {
          t = t || 2e3, this._user = e || (/* @__PURE__ */ new Date()).valueOf(), this._needUpdate = false, this._updateBusy = false, this.attachEvent("onAfterUpdate", this.afterAutoUpdate), this.attachEvent("onFullSync", this.fullSync), setInterval(() => {
            this.loadUpdate();
          }, t);
        }
        afterAutoUpdate(t, e, n, i) {
          return e !== "collision" || (this._needUpdate = true, false);
        }
        fullSync() {
          return this._needUpdate && (this._needUpdate = false, this.loadUpdate()), true;
        }
        getUpdates(t, e) {
          const n = this.$gantt.ajax;
          if (this._updateBusy) return false;
          this._updateBusy = true, n.get(t, e);
        }
        loadUpdate() {
          const t = this.$gantt.ajax, e = this.$gantt.getUserData(0, "version", this._ganttMode);
          let n = this.serverProcessor + t.urlSeparator(this.serverProcessor) + ["dhx_user=" + this._user, "dhx_version=" + e].join("&");
          n = n.replace("editing=true&", ""), this.getUpdates(n, (i) => {
            const a = t.xpath("//userdata", i);
            this.$gantt.setUserData(0, "version", this._getXmlNodeValue(a[0]), this._ganttMode);
            const r = t.xpath("//update", i);
            if (r.length) {
              this._silent_mode = true;
              for (let s = 0; s < r.length; s++) {
                const o = r[s].getAttribute("status"), l = r[s].getAttribute("id"), d = r[s].getAttribute("parent");
                switch (o) {
                  case "inserted":
                    this.callEvent("insertCallback", [r[s], l, d]);
                    break;
                  case "updated":
                    this.callEvent("updateCallback", [r[s], l, d]);
                    break;
                  case "deleted":
                    this.callEvent("deleteCallback", [r[s], l, d]);
                }
              }
              this._silent_mode = false;
            }
            this._updateBusy = false;
          });
        }
        destructor() {
          this.callEvent("onDestroy", []), this.detachAllEvents(), this.updatedRows = [], this._in_progress = {}, this._invalid = {}, this._storage.clear(), this._storage = null, this._headers = null, this._payload = null, delete this._initialized;
        }
        setGanttMode(t) {
          t === "tasks" ? t = "task" : t === "links" && (t = "link");
          const e = this.modes || {}, n = this.getGanttMode();
          n && (e[n] = { _in_progress: this._in_progress, _invalid: this._invalid, _storage: this._storage, updatedRows: this.updatedRows });
          let i = e[t];
          i || (i = e[t] = { _in_progress: {}, _invalid: {}, _storage: Wt.create(), updatedRows: [] }), this._in_progress = i._in_progress, this._invalid = i._invalid, this._storage = i._storage, this.updatedRows = i.updatedRows, this.modes = e, this._ganttMode = t;
        }
        getGanttMode() {
          return this._ganttMode;
        }
        storeItem(t) {
          this._storage.storeItem(t);
        }
        url(t) {
          this.serverProcessor = this._serverProcessor = t;
        }
        _beforeSendData(t, e) {
          if (!this.callEvent("onBeforeUpdate", [e, this.getState(e), t])) return false;
          this._sendData(t, e);
        }
        _serializeAsJSON(t) {
          if (typeof t == "string") return t;
          const e = V(t);
          return this._tMode === "REST-JSON" && (delete e.id, delete e[this.action_param]), JSON.stringify(e);
        }
        _applyPayload(t) {
          const e = this.$gantt.ajax;
          if (this._payload) for (const n in this._payload) t = t + e.urlSeparator(t) + this.escape(n) + "=" + this.escape(this._payload[n]);
          return t;
        }
        _cleanupArgumentsBeforeSend(t) {
          let e;
          if (t[this.action_param] === void 0) {
            e = {};
            for (const n in t) e[n] = this._cleanupArgumentsBeforeSend(t[n]);
          } else e = this._cleanupItemBeforeSend(t);
          return e;
        }
        _cleanupItemBeforeSend(t) {
          let e = null;
          return t && (t[this.action_param] === "deleted" ? (e = {}, e.id = t.id, e[this.action_param] = t[this.action_param]) : e = t), e;
        }
        _sendData(t, e) {
          if (!t) return;
          if (!this.callEvent("onBeforeDataSending", e ? [e, this.getState(e), t] : [null, null, t])) return false;
          e && (this._in_progress[e] = (/* @__PURE__ */ new Date()).valueOf());
          const n = this.$gantt.ajax;
          if (this._tMode === "CUSTOM") {
            const l = this.getState(e), d = this.getActionByState(l), c = this.getGanttMode(), u = (g) => {
              let f = l || "updated", y = e, v = e;
              g && (f = g.action || l, y = g.sid || y, v = g.id || g.tid || v), this.afterUpdateCallback(y, v, f, g, c);
            };
            let h;
            if (this._router instanceof Function) if (this._routerParametersFormat === "object") {
              const g = { entity: c, action: d, data: t, id: e };
              h = this._router(g);
            } else h = this._router(c, d, t, e);
            else if (this._router[c] instanceof Function) h = this._router[c](d, t, e);
            else {
              const g = "Incorrect configuration of gantt.createDataProcessor", f = `
You need to either add missing properties to the dataProcessor router object or to use a router function.
See https://docs.dhtmlx.com/gantt/desktop__server_side.html#customrouting and https://docs.dhtmlx.com/gantt/api__gantt_createdataprocessor.html for details.`;
              if (!this._router[c]) throw new Error(`${g}: router for the **${c}** entity is not defined. ${f}`);
              switch (l) {
                case "inserted":
                  if (!this._router[c].create) throw new Error(`${g}: **create** action for the **${c}** entity is not defined. ${f}`);
                  h = this._router[c].create(t);
                  break;
                case "deleted":
                  if (!this._router[c].delete) throw new Error(`${g}: **delete** action for the **${c}** entity is not defined. ${f}`);
                  h = this._router[c].delete(e);
                  break;
                default:
                  if (!this._router[c].update) throw new Error(`${g}: **update**" action for the **${c}** entity is not defined. ${f}`);
                  h = this._router[c].update(t, e);
              }
            }
            if (h) {
              if (!h.then && h.id === void 0 && h.tid === void 0 && h.action === void 0) throw new Error("Incorrect router return value. A Promise or a response object is expected");
              h.then ? h.then(u).catch((g) => {
                g && g.action ? u(g) : u({ action: "error", value: g });
              }) : u(h);
            } else u(null);
            return;
          }
          let i;
          i = { callback: (l) => {
            const d = [];
            if (e) d.push(e);
            else if (t) for (const c in t) d.push(c);
            return this.afterUpdate(this, l, d);
          }, headers: this._headers };
          const a = "dhx_version=" + this.$gantt.getUserData(0, "version", this._ganttMode), r = this.serverProcessor + (this._user ? n.urlSeparator(this.serverProcessor) + ["dhx_user=" + this._user, a].join("&") : "");
          let s, o = this._applyPayload(r);
          switch (this._tMode) {
            case "GET":
              s = this._cleanupArgumentsBeforeSend(t), i.url = o + n.urlSeparator(o) + this.serialize(s, e), i.method = "GET";
              break;
            case "POST":
              s = this._cleanupArgumentsBeforeSend(t), i.url = o, i.method = "POST", i.data = this.serialize(s, e);
              break;
            case "JSON":
              s = {};
              const l = this._cleanupItemBeforeSend(t);
              for (const d in l) d !== this.action_param && d !== "id" && d !== "gr_id" && (s[d] = l[d]);
              i.url = o, i.method = "POST", i.data = JSON.stringify({ id: e, action: t[this.action_param], data: s });
              break;
            case "REST":
            case "REST-JSON":
              switch (o = r.replace(/(&|\?)editing=true/, ""), s = "", this.getState(e)) {
                case "inserted":
                  i.method = "POST", i.data = this.serialize(t, e);
                  break;
                case "deleted":
                  i.method = "DELETE", o = o + (o.slice(-1) === "/" ? "" : "/") + e;
                  break;
                default:
                  i.method = "PUT", i.data = this.serialize(t, e), o = o + (o.slice(-1) === "/" ? "" : "/") + e;
              }
              i.url = this._applyPayload(o);
          }
          return this._waitMode++, n.query(i);
        }
        _forEachUpdatedRow(t) {
          const e = this.updatedRows.slice();
          for (let n = 0; n < e.length; n++) {
            const i = e[n];
            this.$gantt.getUserData(i, this.action_param, this._ganttMode) && t.call(this, i);
          }
        }
        _setDefaultTransactionMode() {
          this.serverProcessor && (this.setTransactionMode("POST", true), this.serverProcessor += (this.serverProcessor.indexOf("?") !== -1 ? "&" : "?") + "editing=true", this._serverProcessor = this.serverProcessor);
        }
        _getXmlNodeValue(t) {
          return t.firstChild ? t.firstChild.nodeValue : "";
        }
        _getAllData() {
          const t = {};
          let e = false;
          return this._forEachUpdatedRow(function(n) {
            if (this._in_progress[n] || this.is_invalid(n)) return;
            const i = this._getRowData(n);
            this.callEvent("onBeforeUpdate", [n, this.getState(n), i]) && (t[n] = i, e = true, this._in_progress[n] = (/* @__PURE__ */ new Date()).valueOf());
          }), e ? t : null;
        }
        _prepareDate(t) {
          return this.$gantt.defined(this.$gantt.templates.xml_format) ? this.$gantt.templates.xml_format(t) : this.$gantt.templates.format_date(t);
        }
        _prepareArray(t, e) {
          return e.push(t), t.map((n) => J(n) ? this._prepareDate(n) : Array.isArray(n) && !zt(e, n) ? this._prepareArray(n, e) : n && typeof n == "object" && !zt(e, n) ? this._prepareObject(n, e) : n);
        }
        _prepareObject(t, e) {
          const n = {};
          e.push(t);
          for (const i in t) {
            if (i.substr(0, 1) === "$") continue;
            const a = t[i];
            J(a) ? n[i] = this._prepareDate(a) : a === null ? n[i] = "" : Array.isArray(a) && !zt(e, a) ? n[i] = this._prepareArray(a, e) : a && typeof a == "object" && !zt(e, a) ? n[i] = this._prepareObject(a, e) : n[i] = a;
          }
          return n;
        }
        _prepareDataItem(t) {
          const e = this._prepareObject(t, []);
          return e[this.action_param] = this.$gantt.getUserData(t.id, this.action_param, this._ganttMode), e;
        }
        getStoredItem(t) {
          return this._storage.getStoredItem(t);
        }
        _getRowData(t) {
          let e;
          const n = this.$gantt;
          return this.getGanttMode() === "task" ? n.isTaskExists(t) && (e = this.$gantt.getTask(t)) : this.getGanttMode() === "assignment" ? this.$gantt.$data.assignmentsStore.exists(t) && (e = this.$gantt.$data.assignmentsStore.getItem(t)) : this.getGanttMode() === "baseline" ? this.$gantt.$data.baselineStore.exists(t) && (e = this.$gantt.$data.baselineStore.getItem(t)) : n.isLinkExists(t) && (e = this.$gantt.getLink(t)), e || (e = this.getStoredItem(t)), e || (e = { id: t }), this._prepareDataItem(e);
        }
      };
      const Ke = { DEPRECATED_api: function(t) {
        return new Je(t);
      }, createDataProcessor: function(t) {
        let e, n, i;
        t instanceof Function ? e = t : t.hasOwnProperty("router") ? e = t.router : t.hasOwnProperty("assignment") || t.hasOwnProperty("baseline") || t.hasOwnProperty("link") || t.hasOwnProperty("task") ? e = t : t.hasOwnProperty("headers") && (i = t.headers), n = e ? "CUSTOM" : t.mode || "REST-JSON";
        const a = new Je(t.url);
        return a.init(this), a.setTransactionMode({ mode: n, router: e, headers: i }, t.batchUpdate), t.deleteAfterConfirmation && (a.deleteAfterConfirmation = t.deleteAfterConfirmation), a;
      } };
      function ei(t) {
        var e = {}, n = false;
        function i(l, d) {
          d = typeof d == "function" ? d : function() {
          }, e[l] || (e[l] = this[l], this[l] = d);
        }
        function a(l) {
          e[l] && (this[l] = e[l], e[l] = null);
        }
        function r(l) {
          for (var d in l) i.call(this, d, l[d]);
        }
        function s() {
          for (var l in e) a.call(this, l);
        }
        function o(l) {
          try {
            l();
          } catch (d) {
            lt.console.error(d);
          }
        }
        return t.$services.getService("state").registerProvider("batchUpdate", function() {
          return { batch_update: n };
        }, false), function(l, d) {
          if (n) o(l);
          else {
            var c, u = this._dp && this._dp.updateMode != "off";
            u && (c = this._dp.updateMode, this._dp.setUpdateMode("off"));
            var h = {}, g = { render: true, refreshData: true, refreshTask: true, refreshLink: true, resetProjectDates: function(y) {
              h[y.id] = y;
            } };
            for (var f in r.call(this, g), n = true, this.callEvent("onBeforeBatchUpdate", []), o(l), this.callEvent("onAfterBatchUpdate", []), s.call(this), h) this.resetProjectDates(h[f]);
            n = false, d || this.render(), u && (this._dp.setUpdateMode(c), this._dp.setGanttMode("task"), this._dp.sendData(), this._dp.setGanttMode("link"), this._dp.sendData());
          }
        };
      }
      function ni(t) {
        t.batchUpdate = ei(t);
      }
      var ii = function(t) {
        return { _needRecalc: true, reset: function() {
          this._needRecalc = true;
        }, _isRecalcNeeded: function() {
          return !this._isGroupSort() && this._needRecalc;
        }, _isGroupSort: function() {
          return !!t.getState().group_mode;
        }, _getWBSCode: function(e) {
          return e ? (this._isRecalcNeeded() && this._calcWBS(), e.$virtual ? "" : this._isGroupSort() ? e.$wbs || "" : (e.$wbs || (this.reset(), this._calcWBS()), e.$wbs)) : "";
        }, _setWBSCode: function(e, n) {
          e.$wbs = n;
        }, getWBSCode: function(e) {
          return this._getWBSCode(e);
        }, getByWBSCode: function(e) {
          for (var n = e.split("."), i = t.config.root_id, a = 0; a < n.length; a++) {
            var r = t.getChildren(i), s = 1 * n[a] - 1;
            if (!t.isTaskExists(r[s])) return null;
            i = r[s];
          }
          return t.isTaskExists(i) ? t.getTask(i) : null;
        }, _calcWBS: function() {
          if (this._isRecalcNeeded()) {
            var e = true;
            t.eachTask(function(n) {
              if (e) return e = false, void this._setWBSCode(n, "1");
              var i = t.getPrevSibling(n.id);
              if (i !== null) {
                var a = t.getTask(i).$wbs;
                a && ((a = a.split("."))[a.length - 1]++, this._setWBSCode(n, a.join(".")));
              } else {
                var r = t.getParent(n.id);
                this._setWBSCode(n, t.getTask(r).$wbs + ".1");
              }
            }, t.config.root_id, this), this._needRecalc = false;
          }
        } };
      };
      function ai(t) {
        var e = ii(t);
        function n() {
          return e.reset(), true;
        }
        t.getWBSCode = function(i) {
          return e.getWBSCode(i);
        }, t.getTaskByWBSCode = function(i) {
          return e.getByWBSCode(i);
        }, t.attachEvent("onAfterTaskMove", n), t.attachEvent("onBeforeParse", n), t.attachEvent("onAfterTaskDelete", n), t.attachEvent("onAfterTaskAdd", n), t.attachEvent("onAfterSort", n);
      }
      function ri(t) {
        var e = {}, n = false;
        t.$data.tasksStore.attachEvent("onStoreUpdated", function() {
          e = {}, n = false;
        }), t.attachEvent("onBeforeGanttRender", function() {
          e = {};
        });
        var i = String(Math.random());
        function a(l) {
          return l === null ? i + String(l) : String(l);
        }
        function r(l, d, c) {
          return Array.isArray(l) ? l.map(function(u) {
            return a(u);
          }).join("_") + `_${d}_${c}` : a(l) + `_${d}_${c}`;
        }
        function s(l, d, c) {
          var u, h = r(d, l, JSON.stringify(c)), g = {};
          return kt(d, function(f) {
            g[a(f)] = true;
          }), e[h] ? u = e[h] : (u = e[h] = [], t.eachTask(function(f) {
            if (c) {
              if (!c[t.getTaskType(f)]) return;
            } else if (f.type == t.config.types.project) return;
            l in f && kt(ne(f[l]) ? f[l] : [f[l]], function(y) {
              var v = y && y.resource_id ? y.resource_id : y;
              if (g[a(v)]) u.push(f);
              else if (!n) {
                var b = r(y, l);
                e[b] || (e[b] = []), e[b].push(f);
              }
            });
          }), n = true), u;
        }
        function o(l, d, c) {
          var u = t.config.resource_property, h = [];
          if (t.getDatastore("task").exists(d)) {
            var g = t.getTask(d);
            h = g[u] || [];
          }
          Array.isArray(h) || (h = [h]);
          for (var f = 0; f < h.length; f++) h[f].resource_id == l && c.push({ task_id: g.id, resource_id: h[f].resource_id, value: h[f].value });
        }
        return { getTaskBy: function(l, d, c) {
          return typeof l == "function" ? (u = l, h = [], t.eachTask(function(g) {
            u(g) && h.push(g);
          }), h) : ne(d) ? s(l, d, c) : s(l, [d], c);
          var u, h;
        }, getResourceAssignments: function(l, d) {
          var c = [], u = t.config.resource_property;
          return d !== void 0 ? o(l, d, c) : t.getTaskBy(u, l).forEach(function(h) {
            o(l, h.id, c);
          }), c;
        } };
      }
      function si(t) {
        var e = ri(t);
        t.ext.resources = /* @__PURE__ */ function(a) {
          const r = { renderEditableLabel: function(s, o, l, d, c) {
            const u = a.config.readonly ? "" : "contenteditable";
            if (s < l.end_date && o > l.start_date) {
              for (let h = 0; h < c.length; h++) {
                const g = c[h];
                return "<div " + u + " data-assignment-cell data-assignment-id='" + g.id + "' data-row-id='" + l.id + "' data-task='" + l.$task_id + "' data-start-date='" + a.templates.format_date(s) + "' data-end-date='" + a.templates.format_date(o) + "'>" + g.value + "</div>";
              }
              return "<div " + u + " data-assignment-cell data-empty  data-row-id='" + l.id + "' data-resource-id='" + l.$resource_id + "' data-task='" + l.$task_id + "' data-start-date='" + a.templates.format_date(s) + "''  data-end-date='" + a.templates.format_date(o) + "'>-</div>";
            }
            return "";
          }, renderSummaryLabel: function(s, o, l, d, c) {
            let u = c.reduce(function(h, g) {
              return h + Number(g.value);
            }, 0);
            return u % 1 && (u = Math.round(10 * u) / 10), u ? "<div>" + u + "</div>" : "";
          }, editableResourceCellTemplate: function(s, o, l, d, c) {
            return l.$role === "task" ? r.renderEditableLabel(s, o, l, d, c) : r.renderSummaryLabel(s, o, l, d, c);
          }, editableResourceCellClass: function(s, o, l, d, c) {
            const u = [];
            u.push("resource_marker"), l.$role === "task" ? u.push("task_cell") : u.push("resource_cell");
            const h = c.reduce(function(f, y) {
              return f + Number(y.value);
            }, 0);
            let g = Number(l.capacity);
            return isNaN(g) && (g = 8), h <= g ? u.push("workday_ok") : u.push("workday_over"), u.join(" ");
          }, getSummaryResourceAssignments: function(s) {
            let o;
            const l = a.getDatastore(a.config.resource_store), d = l.getItem(s);
            return d.$role === "task" ? o = a.getResourceAssignments(d.$resource_id, d.$task_id) : (o = a.getResourceAssignments(s), l.eachItem && l.eachItem(function(c) {
              c.$role !== "task" && (o = o.concat(a.getResourceAssignments(c.id)));
            }, s)), o;
          }, initEditableDiagram: function() {
            a.config.resource_render_empty_cells = true, function() {
              let s = null;
              function o() {
                return s && cancelAnimationFrame(s), s = requestAnimationFrame(function() {
                  a.$container && Array.prototype.slice.call(a.$container.querySelectorAll(".resourceTimeline_cell [data-assignment-cell]")).forEach(function(l) {
                    l.contentEditable = true;
                  });
                }), true;
              }
              a.attachEvent("onGanttReady", function() {
                a.getDatastore(a.config.resource_assignment_store).attachEvent("onStoreUpdated", o), a.getDatastore(a.config.resource_store).attachEvent("onStoreUpdated", o);
              }, { once: true }), a.attachEvent("onGanttLayoutReady", function() {
                a.$layout.getCellsByType("viewCell").forEach(function(l) {
                  l.$config && l.$config.view === "resourceTimeline" && l.$content && l.$content.attachEvent("onScroll", o);
                });
              });
            }(), a.attachEvent("onGanttReady", function() {
              let s = false;
              a.event(a.$container, "keypress", function(o) {
                var l = o.target.closest(".resourceTimeline_cell [data-assignment-cell]");
                l && (o.keyCode !== 13 && o.keyCode !== 27 || l.blur());
              }), a.event(a.$container, "focusout", function(o) {
                if (!s) {
                  s = true, setTimeout(function() {
                    s = false;
                  }, 300);
                  var l = o.target.closest(".resourceTimeline_cell [data-assignment-cell]");
                  if (l) {
                    var d = (l.innerText || "").trim();
                    d == "-" && (d = "0");
                    var c = Number(d), u = l.getAttribute("data-row-id"), h = l.getAttribute("data-assignment-id"), g = l.getAttribute("data-task"), f = l.getAttribute("data-resource-id"), y = a.templates.parse_date(l.getAttribute("data-start-date")), v = a.templates.parse_date(l.getAttribute("data-end-date")), b = a.getDatastore(a.config.resource_assignment_store);
                    if (isNaN(c)) a.getDatastore(a.config.resource_store).refresh(u);
                    else {
                      var _ = a.getTask(g);
                      if (a.plugins().undo && a.ext.undo.saveState(g, "task"), h) {
                        if (c === (p = b.getItem(h)).value) return;
                        if (p.start_date.valueOf() === y.valueOf() && p.end_date.valueOf() === v.valueOf()) p.value = c, c ? b.updateItem(p.id) : b.removeItem(p.id);
                        else {
                          if (p.end_date.valueOf() > v.valueOf()) {
                            var m = a.copy(p);
                            m.id = a.uid(), m.start_date = v, m.duration = a.calculateDuration({ start_date: m.start_date, end_date: m.end_date, task: _ }), m.delay = a.calculateDuration({ start_date: _.start_date, end_date: m.start_date, task: _ }), m.mode = p.mode || "default", m.duration !== 0 && b.addItem(m);
                          }
                          p.start_date.valueOf() < y.valueOf() ? (p.end_date = y, p.duration = a.calculateDuration({ start_date: p.start_date, end_date: p.end_date, task: _ }), p.mode = "fixedDuration", p.duration === 0 ? b.removeItem(p.id) : b.updateItem(p.id)) : b.removeItem(p.id), c && b.addItem({ task_id: p.task_id, resource_id: p.resource_id, value: c, start_date: y, end_date: v, duration: a.calculateDuration({ start_date: y, end_date: v, task: _ }), delay: a.calculateDuration({ start_date: _.start_date, end_date: y, task: _ }), mode: "fixedDuration" });
                        }
                        a.updateTaskAssignments(_.id), a.updateTask(_.id);
                      } else if (c) {
                        var p = { task_id: g, resource_id: f, value: c, start_date: y, end_date: v, duration: a.calculateDuration({ start_date: y, end_date: v, task: _ }), delay: a.calculateDuration({ start_date: _.start_date, end_date: y, task: _ }), mode: "fixedDuration" };
                        b.addItem(p), a.updateTaskAssignments(_.id), a.updateTask(_.id);
                      }
                    }
                  }
                }
              });
            }, { once: true });
          } };
          return r;
        }(t), t.config.resources = { dataprocessor_assignments: false, dataprocessor_resources: false, editable_resource_diagram: false, resource_store: { type: "treeDataStore", fetchTasks: false, initItem: function(a) {
          return a.parent = a.parent || t.config.root_id, a[t.config.resource_property] = a.parent, a.open = true, a;
        } }, lightbox_resources: function(a) {
          const r = [], s = t.getDatastore(t.config.resource_store);
          return a.forEach(function(o) {
            if (!s.hasChild(o.id)) {
              const l = t.copy(o);
              l.key = o.id, l.label = o.text, r.push(l);
            }
          }), r;
        } }, t.attachEvent("onBeforeGanttReady", function() {
          if (t.getDatastore(t.config.resource_store)) return;
          const a = t.config.resources ? t.config.resources.resource_store : void 0;
          let r = a ? a.fetchTasks : void 0;
          t.config.resources && t.config.resources.editable_resource_diagram && (r = true);
          let s = function(l) {
            return l.parent = l.parent || t.config.root_id, l[t.config.resource_property] = l.parent, l.open = true, l;
          };
          a && a.initItem && (s = a.initItem);
          const o = a && a.type ? a.type : "treeDatastore";
          t.$resourcesStore = t.createDatastore({ name: t.config.resource_store, type: o, fetchTasks: r !== void 0 && r, initItem: s }), t.$data.resourcesStore = t.$resourcesStore, t.$resourcesStore.attachEvent("onParse", function() {
            let l = function(c) {
              const u = [];
              return c.forEach(function(h) {
                if (!t.$resourcesStore.hasChild(h.id)) {
                  var g = t.copy(h);
                  g.key = h.id, g.label = h.text, u.push(g);
                }
              }), u;
            };
            t.config.resources && t.config.resources.lightbox_resources && (l = t.config.resources.lightbox_resources);
            const d = l(t.$resourcesStore.getItems());
            t.updateCollection("resourceOptions", d);
          });
        }), t.getTaskBy = e.getTaskBy, t.getResourceAssignments = e.getResourceAssignments, t.config.resource_property = "owner_id", t.config.resource_store = "resource", t.config.resource_render_empty_cells = false, t.templates.histogram_cell_class = function(a, r, s, o, l) {
        }, t.templates.histogram_cell_label = function(a, r, s, o, l) {
          return o.length + "/3";
        }, t.templates.histogram_cell_allocated = function(a, r, s, o, l) {
          return o.length / 3;
        }, t.templates.histogram_cell_capacity = function(a, r, s, o, l) {
          return 0;
        };
        const n = function(a, r, s, o, l) {
          return o.length <= 1 ? "gantt_resource_marker_ok" : "gantt_resource_marker_overtime";
        }, i = function(a, r, s, o, l) {
          return 8 * o.length;
        };
        t.templates.resource_cell_value = i, t.templates.resource_cell_class = n, t.attachEvent("onBeforeGanttReady", function() {
          t.config.resources && t.config.resources.editable_resource_diagram && (t.config.resource_render_empty_cells = true, t.templates.resource_cell_value === i && (t.templates.resource_cell_value = t.ext.resources.editableResourceCellTemplate), t.templates.resource_cell_class === n && (t.templates.resource_cell_class = t.ext.resources.editableResourceCellClass), t.ext.resources.initEditableDiagram(t));
        });
      }
      function oi(t) {
        var e = "$resourceAssignments";
        t.config.resource_assignment_store = "resourceAssignments", t.config.process_resource_assignments = true;
        var n = { auto: "auto", singleValue: "singleValue", valueArray: "valueArray", resourceValueArray: "resourceValueArray", assignmentsArray: "assignmentsArray" }, i = n.auto, a = { fixedDates: "fixedDates", fixedDuration: "fixedDuration", default: "default" };
        function r(f, y) {
          f.start_date ? f.start_date = t.date.parseDate(f.start_date, "parse_date") : f.start_date = null, f.end_date ? f.end_date = t.date.parseDate(f.end_date, "parse_date") : f.end_date = null;
          var v = Number(f.delay), b = false;
          if (isNaN(v) ? (f.delay = 0, b = true) : f.delay = v, t.defined(f.value) || (f.value = null), !f.task_id || !f.resource_id) return false;
          if (f.mode = f.mode || a.default, f.mode === a.fixedDuration && (isNaN(Number(f.duration)) && (y = y || t.getTask(f.task_id), f.duration = t.calculateDuration({ start_date: f.start_date, end_date: f.end_date, id: y })), b && (y = y || t.getTask(f.task_id), f.delay = t.calculateDuration({ start_date: y.start_date, end_date: f.start_date, id: y }))), f.mode !== a.fixedDates && (y || t.isTaskExists(f.task_id))) {
            var _ = o(f, y = y || t.getTask(f.task_id));
            f.start_date = _.start_date, f.end_date = _.end_date, f.duration = _.duration;
          }
        }
        var s = t.createDatastore({ name: t.config.resource_assignment_store, initItem: function(f) {
          return f.id || (f.id = t.uid()), r(f), f;
        } });
        function o(f, y) {
          if (f.mode === a.fixedDates) return { start_date: f.start_date, end_date: f.end_date, duration: f.duration };
          var v, b, _ = f.delay ? t.calculateEndDate({ start_date: y.start_date, duration: f.delay, task: y }) : new Date(y.start_date);
          return f.mode === a.fixedDuration ? (v = t.calculateEndDate({ start_date: _, duration: f.duration, task: y }), b = f.duration) : (v = new Date(y.end_date), b = y.duration - f.delay), { start_date: _, end_date: v, duration: b };
        }
        function l(f) {
          const y = t.config.resource_property;
          let v = f[y];
          const b = [];
          let _ = i === n.auto;
          if (t.defined(v) && v) {
            Array.isArray(v) || (v = [v], _ && (i = n.singleValue, _ = false));
            const m = {};
            v.forEach(function(p) {
              p.resource_id || (p = { resource_id: p }, _ && (i = n.valueArray, _ = false)), _ && (p.id && p.resource_id ? (i = n.assignmentsArray, _ = false) : (i = n.resourceValueArray, _ = false));
              let k, $ = a.default;
              p.mode || (p.start_date && p.end_date || p.start_date && p.duration) && ($ = a.fixedDuration), k = p.id || !p.$id || m[p.$id] ? p.id && !m[p.id] ? p.id : t.uid() : p.$id, m[k] = true;
              const w = { id: k, start_date: p.start_date, duration: p.duration, end_date: p.end_date, delay: p.delay, task_id: f.id, resource_id: p.resource_id, value: p.value, mode: p.mode || $ };
              Object.keys(p).forEach((x) => {
                x != "$id" && (w[x] = p[x]);
              }), w.start_date && w.start_date.getMonth && w.end_date && w.end_date.getMonth && typeof w.duration == "number" || r(w, f), b.push(w);
            });
          }
          return b;
        }
        function d(f) {
          if (t.isTaskExists(f)) {
            var y = t.getTask(f);
            c(y, t.getTaskAssignments(y.id));
          }
        }
        function c(f, y) {
          y.sort(function(v, b) {
            return v.start_date && b.start_date && v.start_date.valueOf() != b.start_date.valueOf() ? v.start_date - b.start_date : 0;
          }), i == n.assignmentsArray ? f[t.config.resource_property] = y : i == n.resourceValueArray && (f[t.config.resource_property] = y.map(function(v) {
            return { $id: v.id, start_date: v.start_date, duration: v.duration, end_date: v.end_date, delay: v.delay, resource_id: v.resource_id, value: v.value, mode: v.mode };
          })), f[e] = y;
        }
        function u(f) {
          var y = l(f);
          return y.forEach(function(v) {
            v.id = v.id || t.uid();
          }), y;
        }
        function h(f, y) {
          var v = function(b, _) {
            var m = { inBoth: [], inTaskNotInStore: [], inStoreNotInTask: [] };
            if (i == n.singleValue) {
              var p = b[0], k = p ? p.resource_id : null, $ = false;
              _.forEach(function(T) {
                T.resource_id != k ? m.inStoreNotInTask.push(T) : T.resource_id == k && (m.inBoth.push({ store: T, task: p }), $ = true);
              }), !$ && p && m.inTaskNotInStore.push(p);
            } else if (i == n.valueArray) {
              var w = {}, x = {}, S = {};
              b.forEach(function(T) {
                w[T.resource_id] = T;
              }), _.forEach(function(T) {
                x[T.resource_id] = T;
              }), b.concat(_).forEach(function(T) {
                if (!S[T.resource_id]) {
                  S[T.resource_id] = true;
                  var E = w[T.resource_id], C = x[T.resource_id];
                  E && C ? m.inBoth.push({ store: C, task: E }) : E && !C ? m.inTaskNotInStore.push(E) : !E && C && m.inStoreNotInTask.push(C);
                }
              });
            } else i != n.assignmentsArray && i != n.resourceValueArray || (w = {}, x = {}, S = {}, b.forEach(function(T) {
              w[T.id || T.$id] = T;
            }), _.forEach(function(T) {
              x[T.id] = T;
            }), b.concat(_).forEach(function(T) {
              var E = T.id || T.$id;
              if (!S[E]) {
                S[E] = true;
                var C = w[E], D = x[E];
                C && D ? m.inBoth.push({ store: D, task: C }) : C && !D ? m.inTaskNotInStore.push(C) : !C && D && m.inStoreNotInTask.push(D);
              }
            }));
            return m;
          }(l(f), y);
          v.inStoreNotInTask.forEach(function(b) {
            s.removeItem(b.id);
          }), v.inTaskNotInStore.forEach(function(b) {
            s.addItem(b);
          }), v.inBoth.forEach(function(b) {
            if (function(m, p) {
              var k = { id: true };
              for (var $ in m) if (!k[$] && String(m[$]) !== String(p[$])) return true;
              return false;
            }(b.task, b.store)) (function(m, p) {
              var k = { id: true };
              for (var $ in m) k[$] || (p[$] = m[$]);
            })(b.task, b.store), s.updateItem(b.store.id);
            else if (b.task.start_date && b.task.end_date && b.task.mode !== a.fixedDates) {
              var _ = o(b.store, f);
              b.store.start_date.valueOf() == _.start_date.valueOf() && b.store.end_date.valueOf() == _.end_date.valueOf() || (b.store.start_date = _.start_date, b.store.end_date = _.end_date, b.store.duration = _.duration, s.updateItem(b.store.id));
            }
          }), d(f.id);
        }
        function g(f) {
          var y = f[e] || s.find(function(v) {
            return v.task_id == f.id;
          });
          h(f, y);
        }
        t.$data.assignmentsStore = s, t.attachEvent("onGanttReady", function() {
          if (t.config.process_resource_assignments) {
            t.attachEvent("onParse", function() {
              t.silent(function() {
                s.clearAll();
                var k = [];
                t.eachTask(function($) {
                  if ($.type !== t.config.types.project) {
                    var w = u($);
                    c($, w), w.forEach(function(x) {
                      k.push(x);
                    });
                  }
                }), s.parse(k);
              });
            });
            var f = false, y = false, v = {}, b = false;
            t.attachEvent("onBeforeBatchUpdate", function() {
              f = true;
            }), t.attachEvent("onAfterBatchUpdate", function() {
              if (y) {
                var k = {};
                for (var $ in v) k[$] = t.getTaskAssignments(v[$].id);
                for (var $ in v) h(v[$], k[$]);
              }
              y = false, f = false, v = {};
            }), t.attachEvent("onTaskCreated", function(k) {
              var $ = u(k);
              return s.parse($), c(k, $), true;
            }), t.attachEvent("onAfterTaskUpdate", function(k, $) {
              f ? (y = true, v[k] = $) : $.unscheduled || g($);
            }), t.attachEvent("onAfterTaskAdd", function(k, $) {
              f ? (y = true, v[k] = $) : g($);
            }), t.attachEvent("onRowDragEnd", function(k) {
              g(t.getTask(k));
            }), t.$data.tasksStore.attachEvent("onAfterDeleteConfirmed", function(k, $) {
              var w, x = [k];
              t.eachTask(function(S) {
                x.push(S.id);
              }, k), w = {}, x.forEach(function(S) {
                w[S] = true;
              }), s.find(function(S) {
                return w[S.task_id];
              }).forEach(function(S) {
                s.removeItem(S.id);
              });
            }), t.$data.tasksStore.attachEvent("onClearAll", function() {
              return _ = null, m = null, p = null, s.clearAll(), true;
            }), t.attachEvent("onTaskIdChange", function(k, $) {
              s.find(function(w) {
                return w.task_id == k;
              }).forEach(function(w) {
                w.task_id = $, s.updateItem(w.id);
              }), d($);
            }), t.attachEvent("onBeforeUndo", function(k) {
              return b = true, true;
            }), t.attachEvent("onAfterUndo", function(k) {
              b = true;
            });
            var _ = null, m = null, p = null;
            s.attachEvent("onStoreUpdated", function() {
              return f && !b || (_ = null, m = null, p = null), true;
            }), t.getResourceAssignments = function(k, $) {
              var w = t.defined($) && $ !== null;
              return _ === null && (_ = {}, m = {}, s.eachItem(function(x) {
                _[x.resource_id] || (_[x.resource_id] = []), _[x.resource_id].push(x);
                var S = x.resource_id + "-" + x.task_id;
                m[S] || (m[S] = []), m[S].push(x);
              })), w ? (m[k + "-" + $] || []).slice() : (_[k] || []).slice();
            }, t.getTaskAssignments = function(k) {
              if (p === null) {
                var $ = [];
                p = {}, s.eachItem(function(w) {
                  p[w.task_id] || (p[w.task_id] = []), p[w.task_id].push(w), w.task_id == k && $.push(w);
                });
              }
              return (p[k] || []).slice();
            }, t.getTaskResources = function(k) {
              const $ = t.getDatastore("resource"), w = t.getTaskAssignments(k), x = {};
              w.forEach(function(T) {
                x[T.resource_id] || (x[T.resource_id] = T.resource_id);
              });
              const S = [];
              for (const T in x) {
                const E = $.getItem(x[T]);
                E && S.push(E);
              }
              return S;
            }, t.updateTaskAssignments = d;
          }
        }, { once: true });
      }
      function li(t) {
        function e(o) {
          return function() {
            return !t.config.placeholder_task || o.apply(this, arguments);
          };
        }
        function n() {
          var o = t.getTaskBy("type", t.config.types.placeholder);
          if (!o.length || !t.isTaskExists(o[0].id)) {
            var l = { unscheduled: true, type: t.config.types.placeholder, duration: 0, text: t.locale.labels.new_task };
            if (t.callEvent("onTaskCreated", [l]) === false) return;
            t.addTask(l);
          }
        }
        function i(o) {
          var l = t.getTask(o);
          l.type == t.config.types.placeholder && (l.start_date && l.end_date && l.unscheduled && (l.unscheduled = false), t.batchUpdate(function() {
            var d = t.copy(l);
            t.silent(function() {
              t.deleteTask(l.id);
            }), delete d["!nativeeditor_status"], d.type = t.config.types.task, d.id = t.uid(), t.addTask(d);
          }));
        }
        t.config.types.placeholder = "placeholder", t.attachEvent("onDataProcessorReady", e(function(o) {
          o && !o._silencedPlaceholder && (o._silencedPlaceholder = true, o.attachEvent("onBeforeUpdate", e(function(l, d, c) {
            return c.type != t.config.types.placeholder || (o.setUpdated(l, false), false);
          })));
        }));
        var a = false;
        function r(o) {
          return !!(t.config.types.placeholder && t.isTaskExists(o) && t.getTask(o).type == t.config.types.placeholder);
        }
        function s(o) {
          return !(!r(o.source) && !r(o.target));
        }
        t.attachEvent("onGanttReady", function() {
          a || (a = true, t.attachEvent("onAfterTaskUpdate", e(i)), t.attachEvent("onAfterTaskAdd", e(function(o, l) {
            l.type != t.config.types.placeholder && (t.getTaskBy("type", t.config.types.placeholder).forEach(function(d) {
              t.silent(function() {
                t.isTaskExists(d.id) && t.deleteTask(d.id);
              });
            }), n());
          })), t.attachEvent("onParse", e(n)));
        }), t.attachEvent("onLinkValidation", function(o) {
          return !s(o);
        }), t.attachEvent("onBeforeLinkAdd", function(o, l) {
          return !s(l);
        }), t.attachEvent("onBeforeUndoStack", function(o) {
          for (var l = 0; l < o.commands.length; l++) {
            var d = o.commands[l];
            d.entity === "task" && d.value.type === t.config.types.placeholder && (o.commands.splice(l, 1), l--);
          }
          return true;
        });
      }
      function di(t) {
        function e(c) {
          return function() {
            return !t.config.auto_types || t.getTaskType(t.config.types.project) != t.config.types.project || c.apply(this, arguments);
          };
        }
        function n(c, u) {
          var h = t.getTask(c), g = r(h);
          g !== false && t.getTaskType(h) !== g && (u.$needsUpdate = true, u[h.id] = { task: h, type: g });
        }
        function i(c) {
          if (!t.getState().group_mode) {
            var u = function(h, g) {
              return n(h, g = g || {}), t.eachParent(function(f) {
                n(f.id, g);
              }, h), g;
            }(c);
            u.$needsUpdate && t.batchUpdate(function() {
              (function(h) {
                for (var g in h) if (h[g] && h[g].task) {
                  var f = h[g].task;
                  f.type = h[g].type, t.updateTask(f.id);
                }
              })(u);
            });
          }
        }
        var a;
        function r(c) {
          var u = t.config.types, h = t.hasChild(c.id), g = t.getTaskType(c.type);
          return h && g === u.task ? u.project : !h && g === u.project && u.task;
        }
        var s, o, l = true;
        function d(c) {
          c != t.config.root_id && t.isTaskExists(c) && i(c);
        }
        t.attachEvent("onParse", e(function() {
          l = false, t.getState().group_mode || (t.batchUpdate(function() {
            t.eachTask(function(c) {
              var u = r(c);
              u !== false && function(h, g) {
                t.getState().group_mode || (h.type = g, t.updateTask(h.id));
              }(c, u);
            });
          }), l = true);
        })), t.attachEvent("onAfterTaskAdd", e(function(c) {
          l && i(c);
        })), t.attachEvent("onAfterTaskUpdate", e(function(c) {
          l && i(c);
        })), t.attachEvent("onBeforeTaskDelete", e(function(c, u) {
          return a = t.getParent(c), true;
        })), t.attachEvent("onAfterTaskDelete", e(function(c, u) {
          d(a);
        })), t.attachEvent("onRowDragStart", e(function(c, u, h) {
          return s = t.getParent(c), true;
        })), t.attachEvent("onRowDragEnd", e(function(c, u) {
          d(s), i(c);
        })), t.attachEvent("onBeforeTaskMove", e(function(c, u, h) {
          return o = t.getParent(c), true;
        })), t.attachEvent("onAfterTaskMove", e(function(c, u, h) {
          document.querySelector(".gantt_drag_marker") || (d(o), i(c));
        }));
      }
      const Jt = class Jt {
        constructor() {
          this.canParse = (e) => !isNaN(this.parse(e)), this.format = (e) => String(e), this.parse = (e) => parseInt(e, 10);
        }
      };
      Jt.create = (e = null) => new Jt();
      let Ct = Jt;
      const Kt = class Kt {
        constructor(e) {
          this.format = (n) => this._getWBSCode(n.source), this.canParse = (n) => this._linkReg.test(n), this.parse = (n) => {
            if (!this.canParse(n)) return null;
            const i = this._linkReg.exec(n)[0].trim();
            return { id: void 0, source: this._findSource(i) || null, target: null, type: this._gantt.config.links.finish_to_start, lag: 0 };
          }, this._getWBSCode = (n) => {
            const i = this._gantt.getTask(n);
            return this._gantt.getWBSCode(i);
          }, this._findSource = (n) => {
            const i = new RegExp("^[0-9.]+", "i");
            if (i.exec(n)) {
              const a = i.exec(n)[0], r = this._gantt.getTaskByWBSCode(a);
              if (r) return r.id;
            }
            return null;
          }, this._linkReg = /^[0-9\.]+/, this._gantt = e;
        }
      };
      Kt.create = (e = null, n) => new Kt(n);
      let ue = Kt;
      function ci(t) {
        t.ext.formatters = { durationFormatter: function(e) {
          return e || (e = {}), e.store || (e.store = t.config.duration_unit), e.enter || (e.enter = t.config.duration_unit), Ct.create(e, t);
        }, linkFormatter: function(e) {
          return ue.create(e, t);
        } };
      }
      function ui(t) {
        t.ext = t.ext || {}, t.config.show_empty_state = false, t.ext.emptyStateElement = t.ext.emptyStateElement || { isEnabled: () => t.config.show_empty_state === true, isGanttEmpty: () => !t.getTaskByTime().length, renderContent(e) {
          const n = `<div class='gantt_empty_state'><div class='gantt_empty_state_image'></div>${`<div class='gantt_empty_state_text'>
    <div class='gantt_empty_state_text_link' data-empty-state-create-task>${t.locale.labels.empty_state_text_link}</div>
    <div class='gantt_empty_state_text_description'>${t.locale.labels.empty_state_text_description}</div>
    </div>`}</div>`;
          e.innerHTML = n;
        }, clickEvents: [], attachAddTaskEvent() {
          const e = t.attachEvent("onEmptyClick", function(n) {
            t.utils.dom.closest(n.target, "[data-empty-state-create-task]") && t.createTask({ id: t.uid(), text: "New Task" });
          });
          this.clickEvents.push(e);
        }, detachAddTaskEvents() {
          this.clickEvents.forEach(function(e) {
            t.detachEvent(e);
          }), this.clickEvents = [];
        }, getContainer() {
          if (t.$container) {
            const e = t.utils.dom;
            if (t.$container.contains(t.$grid_data)) return e.closest(t.$grid_data, ".gantt_layout_content");
            if (t.$container.contains(t.$task_data)) return e.closest(t.$task_data, ".gantt_layout_content");
          }
          return null;
        }, getNode() {
          const e = this.getContainer();
          return e ? e.querySelector(".gantt_empty_state_wrapper") : null;
        }, show() {
          const e = this.getContainer();
          if (!e && this.isGanttEmpty()) return null;
          const n = document.createElement("div");
          n.className = "gantt_empty_state_wrapper", n.style.marginTop = t.config.scale_height - e.offsetHeight + "px";
          const i = t.$container.querySelectorAll(".gantt_empty_state_wrapper");
          Array.prototype.forEach.call(i, function(a) {
            a.parentNode.removeChild(a);
          }), this.detachAddTaskEvents(), this.attachAddTaskEvent(), e.appendChild(n), this.renderContent(n);
        }, hide() {
          const e = this.getNode();
          if (!e) return false;
          e.parentNode.removeChild(e);
        }, init() {
        } }, t.attachEvent("onDataRender", function() {
          const e = t.ext.emptyStateElement;
          e.isEnabled() && e.isGanttEmpty() ? e.show() : e.hide();
        });
      }
      const Xe = function(t, e) {
        const n = e.baselines && e.baselines.length, i = t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow";
        if (n && i) return true;
      }, hi = function(t, e) {
        let n = false;
        return t.eachTask(function(i) {
          n || (n = Xe(t, i));
        }, e), n;
      }, wt = function(t) {
        return t.render && t.render == "split" && !t.$open;
      }, _i = function(t, e, n, i) {
        let a = i || e.$task_data.scrollHeight, r = false, s = false;
        return t.eachParent(function(o) {
          if (wt(o)) {
            s = true;
            const l = e.getItemPosition(o).rowHeight;
            l < a && (a = l, r = true);
          }
        }, n.id), { maxHeight: a, shrinkHeight: r, splitChild: s };
      };
      function gi(t) {
        t.config.baselines = { datastore: "baselines", render_mode: false, dataprocessor_baselines: false, row_height: 16, bar_height: 8 };
        const e = t.createDatastore({ name: t.config.baselines.datastore, initItem: function(a) {
          return a.id || (a.id = t.uid()), function(r) {
            if (!r.task_id || !r.start_date && !r.end_date) return false;
            r.start_date ? r.start_date = t.date.parseDate(r.start_date, "parse_date") : r.start_date = null, r.end_date ? r.end_date = t.date.parseDate(r.end_date, "parse_date") : r.end_date = null, r.duration = r.duration || 1, r.start_date && !r.end_date ? r.end_date = t.calculateEndDate(r.start_date, r.duration) : r.end_date && !r.start_date && (r.start_date = t.calculateEndDate(r.end_date, -r.duration));
          }(a), a;
        } });
        function n(a) {
          let r = 0;
          t.adjustTaskHeightForBaselines(a), t.eachTask(function(s) {
            let o = s.row_height || t.config.row_height;
            r = r || o, o > r && (r = o);
          }, a.id), a.row_height < r && (a.row_height = r);
        }
        function i(a) {
          t.eachParent(function(r) {
            if (wt(r)) {
              const s = r.row_height || t.getLayoutView("timeline").getBarHeight(r.id);
              let o = a.row_height;
              t.getChildren(r.id).forEach(function(l) {
                const d = t.getTask(l);
                if (d.id == a.id) return;
                const c = d.row_height || t.getLayoutView("timeline").getBarHeight(d.id);
                o = o || c, c > o && (o = c);
              }), r.row_height = o, r.bar_height = r.bar_height || s;
            }
          }, a.id);
        }
        t.$data.baselineStore = e, t.adjustTaskHeightForBaselines = function(a) {
          let r, s, o = a.baselines && a.baselines.length || 0;
          const l = t.config.baselines.row_height;
          switch (t.config.baselines.render_mode) {
            case "taskRow":
              a.row_height = a.bar_height + 4;
              break;
            case "separateRow":
              r = t.getLayoutView("timeline").getBarHeight(a.id), o ? (a.bar_height = a.bar_height || r, a.bar_height > r && (r = a.bar_height), a.row_height = r + l) : a.bar_height && (a.row_height = a.bar_height + 4), i(a);
              break;
            case "individualRow":
              r = t.getLayoutView("timeline").getBarHeight(a.id), o ? (a.bar_height = a.bar_height || r, a.bar_height > r && (r = a.bar_height), s = l * o, a.row_height = r + s + 2) : a.bar_height && (a.row_height = a.bar_height + 4), i(a);
          }
        }, t.attachEvent("onGanttReady", function() {
          t.config.baselines !== false && (t.attachEvent("onParse", function() {
            e.eachItem(function(a) {
              const r = a.task_id;
              if (t.isTaskExists(r)) {
                const s = t.getTask(r);
                s.baselines = s.baselines || [];
                let o = true;
                for (let l = 0; l < s.baselines.length; l++) {
                  let d = s.baselines[l];
                  if (d.id == a.id) {
                    o = false, t.mixin(d, a, true);
                    break;
                  }
                }
                o && s.baselines.push(a), wt(s) ? n(s) : t.adjustTaskHeightForBaselines(s);
              }
            });
          }), t.attachEvent("onBeforeTaskUpdate", function(a, r) {
            return function(s) {
              let o = false;
              const l = {}, d = s.baselines || [], c = t.getTaskBaselines(s.id);
              d.length != c.length && (o = true), d.forEach(function(u) {
                l[u.id] = true;
                const h = e.getItem(u.id);
                if (h) {
                  const g = +h.start_date != +u.start_date, f = +h.end_date != +u.end_date;
                  (g || f) && e.updateItem(u.id, u);
                } else e.addItem(u);
              }), c.forEach(function(u) {
                l[u.id] || e.removeItem(u.id);
              }), o && (wt(s) ? n(s) : t.adjustTaskHeightForBaselines(s), t.render());
            }(r), true;
          }), t.attachEvent("onAfterUndo", function(a) {
            if ((t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow") && a) {
              let r = false;
              a.commands.forEach(function(s) {
                if (s.entity == "task") {
                  const o = s.value.id;
                  if (t.isTaskExists(o)) {
                    const l = t.getTask(o);
                    if (l.parent && t.isTaskExists(l.parent)) {
                      const d = t.getTask(l.parent);
                      wt(d) && (n(d), r = true);
                    }
                  }
                }
              }), r && t.render();
            }
          }), t.attachEvent("onAfterTaskDelete", function(a, r) {
            if (Xe && r.parent && t.isTaskExists(r.parent)) {
              const s = t.getTask(r.parent);
              wt(s) && n(s);
            }
            e.eachItem(function(s) {
              t.isTaskExists(s.task_id) || e.removeItem(s.id);
            });
          }), t.getTaskBaselines = function(a) {
            const r = [];
            return e.eachItem(function(s) {
              s.task_id == a && r.push(s);
            }), r;
          }, t.$data.baselineStore.attachEvent("onClearAll", function() {
            return t.eachTask(function(a) {
              a.baselines && delete a.baselines;
            }), true;
          }), t.$data.tasksStore.attachEvent("onClearAll", function() {
            return e.clearAll(), true;
          }), t.attachEvent("onTaskIdChange", function(a, r) {
            e.find(function(s) {
              return s.task_id == a;
            }).forEach(function(s) {
              s.task_id = r, e.updateItem(s.id);
            });
          }));
        }, { once: true });
      }
      function fi(t) {
        function e(n) {
          throw t.assert(false, "Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: " + JSON.stringify(n)), new Error("Invalid argument for gantt.parse or gantt.load. An object or a JSON string of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#json is expected. Actual argument value: " + JSON.stringify(n));
        }
        t.load = function() {
          throw new Error("gantt.load() method is not available in the node.js, use gantt.parse() instead");
        }, t.parse = function(n, i) {
          this.on_load({ xmlDoc: { responseText: n } }, i);
        }, t.serialize = function(n) {
          return this[n = n || "json"].serialize();
        }, t.on_load = function(n, i) {
          if (n.xmlDoc && n.xmlDoc.status === 404) this.assert(false, "Failed to load the data from <a href='" + n.xmlDoc.responseURL + "' target='_blank'>" + n.xmlDoc.responseURL + "</a>, server returns 404");
          else if (!t.$destroyed) {
            this.callEvent("onBeforeParse", []), i || (i = "json"), this.assert(this[i], "Invalid data type:'" + i + "'");
            var a = n.xmlDoc.responseText, r = this[i].parse(a, n);
            this._process_loading(r);
          }
        }, t._process_loading = function(n) {
          n.collections && this._load_collections(n.collections), n.resources && this.$data.resourcesStore && this.$data.resourcesStore.parse(n.resources), t.config.baselines !== false && n.baselines && this.$data.baselineStore && this.$data.baselineStore.parse(n.baselines);
          const i = n.data || n.tasks;
          n.assignments && function(r, s) {
            const o = {};
            s.forEach((l) => {
              o[l.task_id] || (o[l.task_id] = []), o[l.task_id].push(l);
            }), r.forEach((l) => {
              l[t.config.resource_property] = o[l.id] || [];
            });
          }(i, n.assignments), this.$data.tasksStore.parse(i);
          var a = n.links || (n.collections ? n.collections.links : []);
          this.$data.linksStore.parse(a), this.callEvent("onParse", []), this.render();
        }, t._load_collections = function(n) {
          var i = false;
          for (var a in n) if (n.hasOwnProperty(a)) {
            i = true;
            var r = n[a];
            this.serverList[a] = this.serverList[a] || [];
            var s = this.serverList[a];
            if (!s) continue;
            s.splice(0, s.length);
            for (var o = 0; o < r.length; o++) {
              var l = r[o], d = this.copy(l);
              for (var c in d.key = d.value, l) if (l.hasOwnProperty(c)) {
                if (c == "value" || c == "label") continue;
                d[c] = l[c];
              }
              s.push(d);
            }
          }
          i && this.callEvent("onOptionsLoad", []);
        }, t.attachEvent("onBeforeTaskDisplay", function(n, i) {
          return !i.$ignore;
        }), t.json = { parse: function(n) {
          if (n || e(n), typeof n == "string") if (typeof JSON != null) try {
            n = JSON.parse(n);
          } catch {
            e(n);
          }
          else t.assert(false, "JSON is not supported");
          return n.data || n.tasks || e(n), n.dhx_security && (t.security_key = n.dhx_security), n;
        }, serializeTask: function(n) {
          return this._copyObject(n);
        }, serializeLink: function(n) {
          return this._copyLink(n);
        }, _copyLink: function(n) {
          var i = {};
          for (var a in n) i[a] = n[a];
          return i;
        }, _copyObject: function(n) {
          var i = {};
          for (var a in n) a.charAt(0) != "$" && (i[a] = n[a], J(i[a]) && (i[a] = t.defined(t.templates.xml_format) ? t.templates.xml_format(i[a]) : t.templates.format_date(i[a])));
          return i;
        }, serialize: function() {
          var n = [], i = [];
          let a = [];
          t.eachTask(function(o) {
            t.resetProjectDates(o), n.push(this.serializeTask(o));
          }, t.config.root_id, this);
          for (var r = t.getLinks(), s = 0; s < r.length; s++) i.push(this.serializeLink(r[s]));
          return t.getDatastore("baselines").eachItem(function(o) {
            const l = t.json.serializeTask(o);
            a.push(l);
          }), { data: n, links: i, baselines: a };
        } }, t.xml = { _xmlNodeToJSON: function(n, i) {
          for (var a = {}, r = 0; r < n.attributes.length; r++) a[n.attributes[r].name] = n.attributes[r].value;
          if (!i) {
            for (r = 0; r < n.childNodes.length; r++) {
              var s = n.childNodes[r];
              s.nodeType == 1 && (a[s.tagName] = s.firstChild ? s.firstChild.nodeValue : "");
            }
            a.text || (a.text = n.firstChild ? n.firstChild.nodeValue : "");
          }
          return a;
        }, _getCollections: function(n) {
          for (var i = {}, a = t.ajax.xpath("//coll_options", n), r = 0; r < a.length; r++) for (var s = i[a[r].getAttribute("for")] = [], o = t.ajax.xpath(".//item", a[r]), l = 0; l < o.length; l++) {
            for (var d = o[l].attributes, c = { key: o[l].getAttribute("value"), label: o[l].getAttribute("label") }, u = 0; u < d.length; u++) {
              var h = d[u];
              h.nodeName != "value" && h.nodeName != "label" && (c[h.nodeName] = h.nodeValue);
            }
            s.push(c);
          }
          return i;
        }, _getXML: function(n, i, a) {
          a = a || "data", i.getXMLTopNode || (i = t.ajax.parse(i));
          var r = t.ajax.xmltop(a, i.xmlDoc);
          r && r.tagName == a || function(o) {
            throw t.assert(false, "Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: " + JSON.stringify(o)), new Error("Invalid argument for gantt.parse or gantt.load. An XML of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#xmldhtmlxgantt20 is expected. Actual argument value: " + JSON.stringify(o));
          }(n);
          var s = r.getAttribute("dhx_security");
          return s && (t.security_key = s), r;
        }, parse: function(n, i) {
          i = this._getXML(n, i);
          for (var a = {}, r = a.data = [], s = t.ajax.xpath("//task", i), o = 0; o < s.length; o++) r[o] = this._xmlNodeToJSON(s[o]);
          return a.collections = this._getCollections(i), a;
        }, _copyLink: function(n) {
          return "<item id='" + n.id + "' source='" + n.source + "' target='" + n.target + "' type='" + n.type + "' />";
        }, _copyObject: function(n) {
          return "<task id='" + n.id + "' parent='" + (n.parent || "") + "' start_date='" + n.start_date + "' duration='" + n.duration + "' open='" + !!n.open + "' progress='" + n.progress + "' end_date='" + n.end_date + "'><![CDATA[" + n.text + "]]></task>";
        }, serialize: function() {
          for (var n = [], i = [], a = t.json.serialize(), r = 0, s = a.data.length; r < s; r++) n.push(this._copyObject(a.data[r]));
          for (r = 0, s = a.links.length; r < s; r++) i.push(this._copyLink(a.links[r]));
          return "<data>" + n.join("") + "<coll_options for='links'>" + i.join("") + "</coll_options></data>";
        } }, t.oldxml = { parse: function(n, i) {
          i = t.xml._getXML(n, i, "projects");
          for (var a = { collections: { links: [] } }, r = a.data = [], s = t.ajax.xpath("//task", i), o = 0; o < s.length; o++) {
            r[o] = t.xml._xmlNodeToJSON(s[o]);
            var l = s[o].parentNode;
            l.tagName == "project" ? r[o].parent = "project-" + l.getAttribute("id") : r[o].parent = l.parentNode.getAttribute("id");
          }
          for (s = t.ajax.xpath("//project", i), o = 0; o < s.length; o++) (d = t.xml._xmlNodeToJSON(s[o], true)).id = "project-" + d.id, r.push(d);
          for (o = 0; o < r.length; o++) {
            var d;
            (d = r[o]).start_date = d.startdate || d.est, d.end_date = d.enddate, d.text = d.name, d.duration = d.duration / 8, d.open = 1, d.duration || d.end_date || (d.duration = 1), d.predecessortasks && a.collections.links.push({ target: d.id, source: d.predecessortasks, type: t.config.links.finish_to_start });
          }
          return a;
        }, serialize: function() {
          t.message("Serialization to 'old XML' is not implemented");
        } }, t.serverList = function(n, i) {
          return i ? this.serverList[n] = i.slice(0) : this.serverList[n] || (this.serverList[n] = []), this.serverList[n];
        };
      }
      function he(t, e, n, i, a) {
        return this.date = t, this.unit = e, this.task = n, this.id = i, this.calendar = a, this;
      }
      function _e(t, e, n, i, a, r) {
        return this.date = t, this.dir = e, this.unit = n, this.task = i, this.id = a, this.calendar = r, this;
      }
      function ge(t, e, n, i, a, r, s) {
        return this.start_date = t, this.duration = e, this.unit = n, this.step = i, this.task = a, this.id = r, this.calendar = s, this;
      }
      function pi(t, e, n, i) {
        return this.start_date = t, this.end_date = e, this.task = n, this.calendar = i, this.unit = null, this.step = null, this;
      }
      var Ze = function(t) {
        return { getWorkHoursArguments: function() {
          var e = arguments[0];
          if (!xt((e = J(e) ? { date: e } : N({}, e)).date)) throw t.assert(false, "Invalid date argument for getWorkHours method"), new Error("Invalid date argument for getWorkHours method");
          return e;
        }, setWorkTimeArguments: function() {
          return arguments[0];
        }, unsetWorkTimeArguments: function() {
          return arguments[0];
        }, isWorkTimeArguments: function() {
          var e, n = arguments[0];
          if (n instanceof he) return n;
          if ((e = n.date ? new he(n.date, n.unit, n.task, null, n.calendar) : new he(arguments[0], arguments[1], arguments[2], null, arguments[3])).unit = e.unit || t.config.duration_unit, !xt(e.date)) throw t.assert(false, "Invalid date argument for isWorkTime method"), new Error("Invalid date argument for isWorkTime method");
          return e;
        }, getClosestWorkTimeArguments: function(e) {
          var n, i = arguments[0];
          if (i instanceof _e) return i;
          if (n = J(i) ? new _e(i) : new _e(i.date, i.dir, i.unit, i.task, null, i.calendar), i.id && (n.task = i), n.dir = i.dir || "any", n.unit = i.unit || t.config.duration_unit, !xt(n.date)) throw t.assert(false, "Invalid date argument for getClosestWorkTime method"), new Error("Invalid date argument for getClosestWorkTime method");
          return n;
        }, _getStartEndConfig: function(e) {
          var n, i = pi;
          if (e instanceof i) return e;
          if (J(e) ? n = new i(arguments[0], arguments[1], arguments[2], arguments[3]) : (n = new i(e.start_date, e.end_date, e.task), e.id !== null && e.id !== void 0 && (n.task = e)), n.unit = n.unit || t.config.duration_unit, n.step = n.step || t.config.duration_step, n.start_date = n.start_date || n.start || n.date, !xt(n.start_date)) throw t.assert(false, "Invalid start_date argument for getDuration method"), new Error("Invalid start_date argument for getDuration method");
          if (!xt(n.end_date)) throw t.assert(false, "Invalid end_date argument for getDuration method"), new Error("Invalid end_date argument for getDuration method");
          return n;
        }, getDurationArguments: function(e, n, i, a) {
          return this._getStartEndConfig.apply(this, arguments);
        }, hasDurationArguments: function(e, n, i, a) {
          return this._getStartEndConfig.apply(this, arguments);
        }, calculateEndDateArguments: function(e, n, i, a) {
          var r, s = arguments[0];
          if (s instanceof ge) return s;
          if (r = J(s) ? new ge(arguments[0], arguments[1], arguments[2], void 0, arguments[3], void 0, arguments[4]) : new ge(s.start_date, s.duration, s.unit, s.step, s.task, null, s.calendar), s.id !== null && s.id !== void 0 && (r.task = s, r.unit = null, r.step = null), r.unit = r.unit || t.config.duration_unit, r.step = r.step || t.config.duration_step, !xt(r.start_date)) throw t.assert(false, "Invalid start_date argument for calculateEndDate method"), new Error("Invalid start_date argument for calculateEndDate method");
          return r;
        } };
      };
      function Qe() {
      }
      Qe.prototype = { _getIntervals: function(t) {
        for (var e = [], n = 0; n < t.length; n += 2) e.push({ start: t[n], end: t[n + 1] });
        return e;
      }, _toHoursArray: function(t) {
        var e = [];
        function n(a) {
          var r, s = Math.floor(a / 3600), o = a - 60 * s * 60, l = Math.floor(o / 60);
          return s + ":" + ((r = String(l)).length < 2 && (r = "0" + r), r);
        }
        for (var i = 0; i < t.length; i++) e.push(n(t[i].start) + "-" + n(t[i].end));
        return e;
      }, _intersectHourRanges: function(t, e) {
        var n = [], i = t.length > e.length ? t : e, a = t === i ? e : t;
        i = i.slice(), a = a.slice(), n = [];
        for (var r = 0; r < i.length; r++) for (var s = i[r], o = 0; o < a.length; o++) {
          var l = a[o];
          l.start < s.end && l.end > s.start && (n.push({ start: Math.max(s.start, l.start), end: Math.min(s.end, l.end) }), s.end > l.end && (a.splice(o, 1), o--, r--));
        }
        return n;
      }, _mergeAdjacentIntervals: function(t) {
        var e = t.slice();
        e.sort(function(r, s) {
          return r.start - s.start;
        });
        for (var n = e[0], i = 1; i < e.length; i++) {
          var a = e[i];
          a.start <= n.end ? (a.end > n.end && (n.end = a.end), e.splice(i, 1), i--) : n = a;
        }
        return e;
      }, _mergeHoursConfig: function(t, e) {
        return this._mergeAdjacentIntervals(this._intersectHourRanges(t, e));
      }, merge: function(t, e) {
        var n = V(t.getConfig().parsed), i = V(e.getConfig().parsed), a = { hours: this._toHoursArray(this._mergeHoursConfig(n.hours, i.hours)), dates: {}, customWeeks: {} };
        const r = (o, l) => {
          for (let d in o.dates) {
            const c = o.dates[d];
            +d > 1e3 && (a.dates[d] = false);
            for (const u in l.dates) {
              const h = l.dates[u];
              if (u == d && (a.dates[d] = !(!c || !h)), Array.isArray(c)) {
                const g = Array.isArray(h) ? h : l.hours;
                a.dates[d] = this._toHoursArray(this._mergeHoursConfig(c, g));
              }
            }
          }
        };
        if (r(n, i), r(i, n), n.customWeeks) for (var s in n.customWeeks) a.customWeeks[s] = n.customWeeks[s];
        if (i.customWeeks) for (var s in i.customWeeks) a.customWeeks[s] = i.customWeeks[s];
        return a;
      } };
      class mi {
        constructor() {
          this.clear();
        }
        getItem(e, n, i) {
          if (this._cache.has(e)) {
            const a = this._cache.get(e)[i.getFullYear()];
            if (a && a.has(n)) return a.get(n);
          }
          return -1;
        }
        setItem(e, n, i, a) {
          if (!e || !n) return;
          const r = this._cache, s = a.getFullYear();
          let o;
          r.has(e) ? o = r.get(e) : (o = [], r.set(e, o));
          let l = o[s];
          l || (l = o[s] = /* @__PURE__ */ new Map()), l.set(n, i);
        }
        clear() {
          this._cache = /* @__PURE__ */ new Map();
        }
      }
      class vi {
        constructor() {
          this.clear();
        }
        getItem(e, n, i) {
          const a = this._cache;
          if (a && a[e]) {
            const r = a[e];
            if (r === void 0) return -1;
            const s = r[i.getFullYear()];
            if (s && s[n] !== void 0) return s[n];
          }
          return -1;
        }
        setItem(e, n, i, a) {
          if (!e || !n) return;
          const r = this._cache;
          if (!r) return;
          r[e] || (r[e] = []);
          const s = r[e], o = a.getFullYear();
          let l = s[o];
          l || (l = s[o] = {}), l[n] = i;
        }
        clear() {
          this._cache = {};
        }
      }
      class ki {
        constructor(e) {
          this.getMinutesPerWeek = (n) => {
            const i = n.valueOf();
            if (this._weekCache.has(i)) return this._weekCache.get(i);
            const a = this._calendar, r = this._calendar.$gantt;
            let s = 0, o = r.date.week_start(new Date(n));
            for (let l = 0; l < 7; l++) s += 60 * a.getHoursPerDay(o), o = r.date.add(o, 1, "day");
            return this._weekCache.set(i, s), s;
          }, this.getMinutesPerMonth = (n) => {
            const i = n.valueOf();
            if (this._monthCache.has(i)) return this._monthCache.get(i);
            const a = this._calendar, r = this._calendar.$gantt;
            let s = 0, o = r.date.week_start(new Date(n));
            const l = r.date.add(o, 1, "month").valueOf();
            for (; o.valueOf() < l; ) s += 60 * a.getHoursPerDay(o), o = r.date.add(o, 1, "day");
            return this._monthCache.set(i, s), s;
          }, this.clear = () => {
            this._weekCache = /* @__PURE__ */ new Map(), this._monthCache = /* @__PURE__ */ new Map();
          }, this.clear(), this._calendar = e;
        }
      }
      class yi {
        constructor() {
          this.clear();
        }
        _getCacheObject(e, n, i) {
          const a = this._cache;
          a[n] || (a[n] = []);
          let r = a[n];
          r || (r = a[n] = {});
          let s = r[i];
          s || (s = r[i] = {});
          const o = e.getFullYear();
          let l = s[o];
          return l || (l = s[o] = { durations: {}, endDates: {} }), l;
        }
        _endDateCacheKey(e, n) {
          return String(e) + "-" + String(n);
        }
        _durationCacheKey(e, n) {
          return String(e) + "-" + String(n);
        }
        getEndDate(e, n, i, a, r) {
          const s = this._getCacheObject(e, i, a), o = e.valueOf(), l = this._endDateCacheKey(o, n);
          let d;
          if (s.endDates[l] === void 0) {
            const c = r(), u = c.valueOf();
            s.endDates[l] = u, s.durations[this._durationCacheKey(o, u)] = n, d = c;
          } else d = new Date(s.endDates[l]);
          return d;
        }
        getDuration(e, n, i, a, r) {
          const s = this._getCacheObject(e, i, a), o = e.valueOf(), l = n.valueOf(), d = this._durationCacheKey(o, l);
          let c;
          if (s.durations[d] === void 0) {
            const u = r();
            s.durations[d] = u.valueOf(), c = u;
          } else c = s.durations[d];
          return c;
        }
        clear() {
          this._cache = {};
        }
      }
      function fe(t, e) {
        this.argumentsHelper = e, this.$gantt = t, this._workingUnitsCache = typeof Map < "u" ? new mi() : new vi(), this._largeUnitsCache = new ki(this), this._dateDurationCache = new yi(), this._worktime = null, this._cached_timestamps = {}, this._cached_timestamps_count = 0;
      }
      fe.prototype = { units: ["year", "month", "week", "day", "hour", "minute"], _clearCaches: function() {
        this._workingUnitsCache.clear(), this._largeUnitsCache.clear(), this._dateDurationCache.clear();
      }, _getUnitOrder: function(t) {
        for (var e = 0, n = this.units.length; e < n; e++) if (this.units[e] == t) return e;
      }, _resetTimestampCache: function() {
        this._cached_timestamps = {}, this._cached_timestamps_count = 0;
      }, _timestamp: function(t) {
        this._cached_timestamps_count > 1e6 && this._resetTimestampCache();
        var e = null;
        if (t.day || t.day === 0) e = t.day;
        else if (t.date) {
          var n = String(t.date.valueOf());
          this._cached_timestamps[n] ? e = this._cached_timestamps[n] : (e = Date.UTC(t.date.getFullYear(), t.date.getMonth(), t.date.getDate()), this._cached_timestamps[n] = e, this._cached_timestamps_count++);
        }
        return e;
      }, _checkIfWorkingUnit: function(t, e) {
        if (!this["_is_work_" + e]) {
          const n = this.$gantt.date[`${e}_start`](new Date(t)), i = this.$gantt.date.add(n, 1, e);
          return this.hasDuration(n, i);
        }
        return this["_is_work_" + e](t);
      }, _is_work_day: function(t) {
        var e = this._getWorkHours(t);
        return !!Array.isArray(e) && e.length > 0;
      }, _is_work_hour: function(t) {
        for (var e = this._getWorkHours(t), n = t.getHours(), i = 0; i < e.length; i++) if (n >= e[i].startHour && n < e[i].endHour) return true;
        return false;
      }, _getTimeOfDayStamp: function(t, e) {
        var n = t.getHours();
        return t.getHours() || t.getMinutes() || !e || (n = 24), 60 * n * 60 + 60 * t.getMinutes();
      }, _is_work_minute: function(t) {
        for (var e = this._getWorkHours(t), n = this._getTimeOfDayStamp(t), i = 0; i < e.length; i++) if (n >= e[i].start && n < e[i].end) return true;
        return false;
      }, _nextDate: function(t, e, n) {
        return this.$gantt.date.add(t, n, e);
      }, _getWorkUnitsBetweenGeneric: function(t, e, n, i) {
        var a = this.$gantt.date, r = new Date(t), s = new Date(e);
        i = i || 1;
        var o, l, d = 0, c = null, u = false;
        (o = a[n + "_start"](new Date(r))).valueOf() != r.valueOf() && (u = true);
        var h = false;
        (l = a[n + "_start"](new Date(e))).valueOf() != e.valueOf() && (h = true);
        for (var g = false; r.valueOf() < s.valueOf(); ) {
          if (g = (c = this._nextDate(r, n, i)).valueOf() > s.valueOf(), this._isWorkTime(r, n)) (u || h && g) && (o = a[n + "_start"](new Date(r)), l = a.add(o, i, n)), u ? (u = false, c = this._nextDate(o, n, i), d += (l.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : h && g ? (h = false, d += (s.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : d++;
          else {
            var f = this._getUnitOrder(n), y = this.units[f - 1];
            y && !this._isWorkTime(r, y) && (c = this._getClosestWorkTimeFuture(r, y));
          }
          r = c;
        }
        return d;
      }, _getMinutesPerHour: function(t) {
        var e = this._getTimeOfDayStamp(t), n = this._getTimeOfDayStamp(this._nextDate(t, "hour", 1));
        n === 0 && (n = 86400);
        for (var i = this._getWorkHours(t), a = 0; a < i.length; a++) {
          var r = i[a];
          if (e >= r.start && n <= r.end) return 60;
          if (e < r.end && n > r.start) return (Math.min(n, r.end) - Math.max(e, r.start)) / 60;
        }
        return 0;
      }, _getMinutesPerDay: function(t) {
        var e = this._getWorkHours(t), n = 0;
        return e.forEach(function(i) {
          n += i.durationMinutes;
        }), n;
      }, getHoursPerDay: function(t) {
        var e = this._getWorkHours(t), n = 0;
        return e.forEach(function(i) {
          n += i.durationHours;
        }), n;
      }, _getWorkUnitsForRange: function(t, e, n, i) {
        var a, r = 0, s = new Date(t), o = new Date(e);
        for (a = R(n == "minute" ? this._getMinutesPerDay : this.getHoursPerDay, this); s.valueOf() < o.valueOf(); ) if (o - s > 27648e5 && s.getDate() === 0) {
          var l = this._largeUnitsCache.getMinutesPerMonth(s);
          n == "hour" && (l /= 60), r += l, s = this.$gantt.date.add(s, 1, "month");
        } else {
          if (o - s > 13824e5) {
            var d = this.$gantt.date.week_start(new Date(s));
            if (s.valueOf() === d.valueOf()) {
              l = this._largeUnitsCache.getMinutesPerWeek(s), n == "hour" && (l /= 60), r += l, s = this.$gantt.date.add(s, 7, "day");
              continue;
            }
          }
          r += a(s), s = this._nextDate(s, "day", 1);
        }
        return r / i;
      }, _getMinutesBetweenSingleDay: function(t, e) {
        for (var n = this._getIntervalTimestamp(t, e), i = this._getWorkHours(t), a = 0, r = 0; r < i.length; r++) {
          var s = i[r];
          if (n.end >= s.start && n.start <= s.end) {
            var o = Math.max(s.start, n.start), l = Math.min(s.end, n.end);
            a += (l - o) / 60, n.start = l;
          }
        }
        return Math.floor(a);
      }, _getMinutesBetween: function(t, e, n, i) {
        var a = new Date(t), r = new Date(e);
        i = i || 1;
        var s = new Date(a), o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, "day");
        if (r.valueOf() <= o.valueOf()) return this._getMinutesBetweenSingleDay(t, e);
        var l = this.$gantt.date.day_start(new Date(r)), d = r, c = this._getMinutesBetweenSingleDay(s, o), u = this._getMinutesBetweenSingleDay(l, d);
        return c + this._getWorkUnitsForRange(o, l, n, i) + u;
      }, _getHoursBetween: function(t, e, n, i) {
        var a = new Date(t), r = new Date(e);
        i = i || 1;
        var s = new Date(a), o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, "day");
        if (r.valueOf() <= o.valueOf()) return Math.round(this._getMinutesBetweenSingleDay(t, e) / 60);
        var l = this.$gantt.date.day_start(new Date(r)), d = r, c = this._getMinutesBetweenSingleDay(s, o, n, i) / 60, u = this._getMinutesBetweenSingleDay(l, d, n, i) / 60, h = c + this._getWorkUnitsForRange(o, l, n, i) + u;
        return Math.round(h);
      }, getConfig: function() {
        return this._worktime;
      }, _setConfig: function(t) {
        this._worktime = t, this._parseSettings(), this._clearCaches();
      }, _parseSettings: function() {
        var t = this.getConfig();
        for (var e in t.parsed = { dates: {}, hours: null, haveCustomWeeks: false, customWeeks: {}, customWeeksRangeStart: null, customWeeksRangeEnd: null, customWeeksBoundaries: [] }, t.parsed.hours = this._parseHours(t.hours), t.dates) t.parsed.dates[e] = this._parseHours(t.dates[e]);
        if (t.customWeeks) {
          var n = null, i = null;
          for (var e in t.customWeeks) {
            var a = t.customWeeks[e];
            if (a.from && a.to) {
              var r = a.from, s = a.to;
              (!n || n > r.valueOf()) && (n = r.valueOf()), (!i || i < s.valueOf()) && (i = s.valueOf()), t.parsed.customWeeksBoundaries.push({ from: r.valueOf(), fromReadable: new Date(r), to: s.valueOf(), toReadable: new Date(s), name: e }), t.parsed.haveCustomWeeks = true;
              var o = t.parsed.customWeeks[e] = { from: a.from, to: a.to, hours: this._parseHours(a.hours), dates: {} };
              for (var l in a.dates) o.dates[l] = this._parseHours(a.dates[l]);
            }
          }
          t.parsed.customWeeksRangeStart = n, t.parsed.customWeeksRangeEnd = i;
        }
      }, _tryChangeCalendarSettings: function(t) {
        var e = JSON.stringify(this.getConfig());
        return t(), !!this.hasWorkTime() || (this._setConfig(JSON.parse(e)), this._clearCaches(), false);
      }, _arraysEqual: function(t, e) {
        if (t === e) return true;
        if (!t || !e || t.length != e.length) return false;
        for (var n = 0; n < t.length; ++n) if (t[n] !== e[n]) return false;
        return true;
      }, _compareSettings: function(t, e) {
        if (!this._arraysEqual(t.hours, e.hours)) return false;
        var n = Object.keys(t.dates), i = Object.keys(e.dates);
        if (n.sort(), i.sort(), !this._arraysEqual(n, i)) return false;
        for (var a = 0; a < n.length; a++) {
          var r = n[a], s = t.dates[r], o = t.dates[r];
          if (s !== o && !(Array.isArray(s) && Array.isArray(o) && this._arraysEqual(s, o))) return false;
        }
        return true;
      }, equals: function(t) {
        if (!(t instanceof fe)) return false;
        var e = this.getConfig(), n = t.getConfig();
        if (!this._compareSettings(e, n)) return false;
        if (e.parsed.haveCustomWeeks && n.parsed.haveCustomWeeks) {
          if (e.parsed.customWeeksBoundaries.length != n.parsed.customWeeksBoundaries.length) return false;
          for (var i in e.parsed.customWeeks) {
            var a = e.parsed.customWeeks[i], r = n.parsed.customWeeks[i];
            if (!r || !this._compareSettings(a, r)) return false;
          }
        } else if (e.parse.haveCustomWeeks !== n.parsed.haveCustomWeeks) return false;
        return true;
      }, getWorkHours: function() {
        var t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments);
        return this._getWorkHours(t.date, false);
      }, _getWorkHours: function(t, e) {
        var n = this.getConfig();
        if (e !== false && (n = n.parsed), !t) return n.hours;
        var i = this._timestamp({ date: t });
        if (n.haveCustomWeeks && n.customWeeksRangeStart <= i && n.customWeeksRangeEnd > i) {
          for (var a = 0; a < n.customWeeksBoundaries.length; a++) if (n.customWeeksBoundaries[a].from <= i && n.customWeeksBoundaries[a].to > i) {
            n = n.customWeeks[n.customWeeksBoundaries[a].name];
            break;
          }
        }
        var r = true;
        return n.dates[i] !== void 0 ? r = n.dates[i] : n.dates[t.getDay()] !== void 0 && (r = n.dates[t.getDay()]), r === true ? n.hours : r || [];
      }, _getIntervalTimestamp: function(t, e) {
        var n = { start: 0, end: 0 };
        n.start = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds();
        var i = e.getHours();
        return !i && !e.getMinutes() && !e.getSeconds() && t.valueOf() < e.valueOf() && (i = 24), n.end = 60 * i * 60 + 60 * e.getMinutes() + e.getSeconds(), n;
      }, _parseHours: function(t) {
        if (Array.isArray(t)) {
          var e = [];
          t.forEach(function(o) {
            typeof o == "number" ? e.push(60 * o * 60) : typeof o == "string" && o.split("-").map(function(l) {
              return l.trim();
            }).forEach(function(l) {
              var d = l.split(":").map(function(u) {
                return u.trim();
              }), c = parseInt(60 * d[0] * 60);
              d[1] && (c += parseInt(60 * d[1])), d[2] && (c += parseInt(d[2])), e.push(c);
            });
          });
          for (var n = [], i = 0; i < e.length; i += 2) {
            var a = e[i], r = e[i + 1], s = r - a;
            n.push({ start: a, end: r, startHour: Math.floor(a / 3600), startMinute: Math.floor(a / 60), endHour: Math.ceil(r / 3600), endMinute: Math.ceil(r / 60), durationSeconds: s, durationMinutes: s / 60, durationHours: s / 3600 });
          }
          return n;
        }
        return t;
      }, setWorkTime: function(t) {
        return this._tryChangeCalendarSettings(R(function() {
          var e = t.hours === void 0 || t.hours, n = this._timestamp(t), i = this.getConfig();
          if (n !== null ? i.dates[n] = e : t.customWeeks || (i.hours = e), t.customWeeks) {
            if (i.customWeeks || (i.customWeeks = {}), typeof t.customWeeks == "string") n !== null ? i.customWeeks[t.customWeeks].dates[n] = e : t.customWeeks || (i.customWeeks[t.customWeeks].hours = e);
            else if (typeof t.customWeeks == "object" && Function.prototype.toString.call(t.customWeeks.constructor) === "function Object() { [native code] }") for (var a in t.customWeeks) i.customWeeks[a] = t.customWeeks[a];
          }
          this._parseSettings(), this._clearCaches();
        }, this));
      }, unsetWorkTime: function(t) {
        return this._tryChangeCalendarSettings(R(function() {
          if (t) {
            var e = this._timestamp(t);
            e !== null && delete this.getConfig().dates[e];
          } else this.reset_calendar();
          this._parseSettings(), this._clearCaches();
        }, this));
      }, _isWorkTime: function(t, e) {
        var n, i = -1;
        return n = String(t.valueOf()), (i = this._workingUnitsCache.getItem(e, n, t)) == -1 && (i = this._checkIfWorkingUnit(t, e), this._workingUnitsCache.setItem(e, n, i, t)), i;
      }, isWorkTime: function() {
        var t = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);
        return this._isWorkTime(t.date, t.unit);
      }, calculateDuration: function() {
        var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);
        if (!t.unit) return false;
        var e = this;
        return this._dateDurationCache.getDuration(t.start_date, t.end_date, t.unit, t.step, function() {
          return e._calculateDuration(t.start_date, t.end_date, t.unit, t.step);
        });
      }, _calculateDuration: function(t, e, n, i) {
        var a = 0, r = 1;
        if (t.valueOf() > e.valueOf()) {
          var s = e;
          e = t, t = s, r = -1;
        }
        return a = n == "hour" && i == 1 ? this._getHoursBetween(t, e, n, i) : n == "minute" && i == 1 ? this._getMinutesBetween(t, e, n, i) : this._getWorkUnitsBetweenGeneric(t, e, n, i), r * Math.round(a);
      }, hasDuration: function() {
        var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.end_date, i = t.unit, a = t.step;
        if (!i) return false;
        var r = new Date(e), s = new Date(n);
        for (a = a || 1; r.valueOf() < s.valueOf(); ) {
          if (this._isWorkTime(r, i)) return true;
          r = this._nextDate(r, i, a);
        }
        return false;
      }, calculateEndDate: function() {
        var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.duration, i = t.unit, a = t.step;
        if (!i) return false;
        var r = t.duration >= 0 ? 1 : -1;
        n = Math.abs(1 * n);
        var s = this;
        return this._dateDurationCache.getEndDate(e, n, i, a * r, function() {
          return s._calculateEndDate(e, n, i, a * r);
        });
      }, _calculateEndDate: function(t, e, n, i) {
        return !!n && (i == 1 && n == "minute" ? this._calculateMinuteEndDate(t, e, i) : i == -1 && n == "minute" ? this._subtractMinuteDate(t, e, i) : i == 1 && n == "hour" ? this._calculateHourEndDate(t, e, i) : this._addInterval(t, e, n, i, null).end);
      }, _addInterval: function(t, e, n, i, a) {
        for (var r = 0, s = t, o = false; r < e && (!a || !a(s)); ) {
          var l = this._nextDate(s, n, i);
          n == "day" && (o = o || !s.getHours() && l.getHours()) && (l.setHours(0), l.getHours() || (o = false));
          var d = new Date(l.valueOf() + 1);
          i > 0 && (d = new Date(l.valueOf() - 1)), this._isWorkTime(d, n) && !o && r++, s = l;
        }
        return { end: s, start: t, added: r };
      }, _addHoursUntilDayEnd: function(t, e) {
        for (var n = this.$gantt.date.add(this.$gantt.date.day_start(new Date(t)), 1, "day"), i = 0, a = e, r = this._getIntervalTimestamp(t, n), s = this._getWorkHours(t), o = 0; o < s.length && i < e; o++) {
          var l = s[o];
          if (r.end >= l.start && r.start <= l.end) {
            var d = Math.max(l.start, r.start), c = Math.min(l.end, r.end), u = (c - d) / 3600;
            u > a && (u = a, c = d + 60 * a * 60);
            var h = Math.round((c - d) / 3600);
            i += h, a -= h, r.start = c;
          }
        }
        var g = n;
        return i === e && (g = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, r.start)), { added: i, end: g };
      }, _calculateHourEndDate: function(t, e, n) {
        var i = new Date(t), a = 0;
        n = n || 1, e = Math.abs(1 * e);
        var r = this._addHoursUntilDayEnd(i, e);
        if (a = r.added, i = r.end, d = e - a) {
          for (var s = i; a < e; ) {
            var o = this._nextDate(s, "day", n);
            o.setHours(0), o.setMinutes(0), o.setSeconds(0);
            var l = 0;
            if (a + (l = n > 0 ? this.getHoursPerDay(new Date(o.valueOf() - 1)) : this.getHoursPerDay(new Date(o.valueOf() + 1))) >= e) break;
            a += l, s = o;
          }
          i = s;
        }
        if (a < e) {
          var d = e - a;
          i = (r = this._addHoursUntilDayEnd(i, d)).end;
        }
        return i;
      }, _addMinutesUntilHourEnd: function(t, e) {
        if (t.getMinutes() === 0) return { added: 0, end: new Date(t) };
        for (var n = this.$gantt.date.add(this.$gantt.date.hour_start(new Date(t)), 1, "hour"), i = 0, a = e, r = this._getIntervalTimestamp(t, n), s = this._getWorkHours(t), o = 0; o < s.length && i < e; o++) {
          var l = s[o];
          if (r.end >= l.start && r.start <= l.end) {
            var d = Math.max(l.start, r.start), c = Math.min(l.end, r.end), u = (c - d) / 60;
            u > a && (u = a, c = d + 60 * a);
            var h = Math.round((c - d) / 60);
            a -= h, i += h, r.start = c;
          }
        }
        var g = n;
        return i === e && (g = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, r.start)), { added: i, end: g };
      }, _subtractMinutesUntilHourStart: function(t, e) {
        for (var n = this.$gantt.date.hour_start(new Date(t)), i = 0, a = e, r = 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds(), s = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds(), o = this._getWorkHours(t), l = o.length - 1; l >= 0 && i < e; l--) {
          var d = o[l];
          if (s > d.start && r <= d.end) {
            var c = Math.min(s, d.end), u = Math.max(r, d.start), h = (c - u) / 60;
            h > a && (h = a, u = c - 60 * a);
            var g = Math.abs(Math.round((c - u) / 60));
            a -= g, i += g, s = u;
          }
        }
        var f = n;
        return i === e && (f = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, s)), { added: i, end: f };
      }, _subtractMinuteDate: function(t, e, n) {
        var i = new Date(t), a = 0;
        n = n || -1, e = Math.abs(1 * e), e = Math.round(e);
        const r = this._isMinutePrecision(i);
        let s = this._subtractMinutesUntilHourStart(i, e);
        a += s.added, i = s.end;
        for (var o = 0, l = [], d = 0; a < e; ) {
          var c = this.$gantt.date.day_start(new Date(i)), u = false;
          i.valueOf() === c.valueOf() && (c = this.$gantt.date.add(c, -1, "day"), u = true);
          var h = new Date(c.getFullYear(), c.getMonth(), c.getDate(), 23, 59, 59, 999).valueOf();
          h !== o && (l = this._getWorkHours(c), d = this._getMinutesPerDay(c), o = h);
          var g = e - a, f = this._getTimeOfDayStamp(i, u);
          if (l.length && d) if (l[l.length - 1].end <= f && g > d) a += d, i = this.$gantt.date.add(i, -1, "day");
          else {
            for (var y = false, v = null, b = null, _ = l.length - 1; _ >= 0; _--) if (l[_].start < f - 1 && l[_].end >= f - 1) {
              y = true, v = l[_], b = l[_ - 1];
              break;
            }
            if (y) if (f === v.end && g >= v.durationMinutes) a += v.durationMinutes, i = this.$gantt.date.add(i, -v.durationMinutes, "minute");
            else if (!r && g <= f / 60 - v.startMinute) a += g, i = this.$gantt.date.add(i, -g, "minute");
            else if (r) g <= f / 60 - v.startMinute ? (a += g, i = this.$gantt.date.add(i, -g, "minute")) : (a += f / 60 - v.startMinute, i = b ? new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, b.end) : this.$gantt.date.day_start(i));
            else {
              var m = this._getMinutesPerHour(i);
              m <= g ? (a += m, i = this._nextDate(i, "hour", n)) : (s = this._subtractMinutesUntilHourStart(i, g), a += s.added, i = s.end);
            }
            else if (i.getHours() === 0 && i.getMinutes() === 0 && i.getSeconds() === 0) {
              if ((p = this._getClosestWorkTimePast(i, "hour")).valueOf() === i.valueOf()) {
                var p = this.$gantt.date.add(i, -1, "day"), k = this._getWorkHours(p);
                if (k.length) {
                  var $ = k[k.length - 1];
                  p.setSeconds($.durationSeconds);
                }
              }
              i = p;
            } else i = this._getClosestWorkTimePast(new Date(i - 1), "hour");
          }
          else i = this.$gantt.date.add(i, -1, "day");
        }
        if (a < e) {
          var w = e - a;
          s = this._subtractMinutesUntilHourStart(i, w), a += s.added, i = s.end;
        }
        return i;
      }, _calculateMinuteEndDate: function(t, e, n) {
        var i = new Date(t), a = 0;
        n = n || 1, e = Math.abs(1 * e), e = Math.round(e);
        var r = this._addMinutesUntilHourEnd(i, e);
        a += r.added, i = r.end;
        for (var s = 0, o = [], l = 0, d = this._isMinutePrecision(i); a < e; ) {
          var c = this.$gantt.date.day_start(new Date(i)).valueOf();
          c !== s && (o = this._getWorkHours(i), l = this._getMinutesPerDay(i), s = c);
          var u = e - a, h = this._getTimeOfDayStamp(i);
          if (o.length && l) if (o[0].start >= h && u >= l) {
            if (a += l, u == l) {
              i = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, o[o.length - 1].end);
              break;
            }
            i = this.$gantt.date.add(i, 1, "day"), i = this.$gantt.date.day_start(i);
          } else {
            for (var g = false, f = null, y = 0; y < o.length; y++) if (o[y].start <= h && o[y].end > h) {
              g = true, f = o[y];
              break;
            }
            if (g) if (h === f.start && u >= f.durationMinutes) a += f.durationMinutes, i = this.$gantt.date.add(i, f.durationMinutes, "minute");
            else if (u <= f.endMinute - h / 60) a += u, i = this.$gantt.date.add(i, u, "minute");
            else {
              var v = this._getMinutesPerHour(i);
              v <= u ? (a += v, i = d ? this.$gantt.date.add(i, v, "minute") : this._nextDate(i, "hour", n)) : (a += (r = this._addMinutesUntilHourEnd(i, u)).added, i = r.end);
            }
            else i = this._getClosestWorkTimeFuture(i, "hour");
          }
          else i = this.$gantt.date.add(this.$gantt.date.day_start(i), 1, "day");
        }
        if (a < e) {
          var b = e - a;
          a += (r = this._addMinutesUntilHourEnd(i, b)).added, i = r.end;
        }
        return i;
      }, getClosestWorkTime: function() {
        var t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments);
        return this._getClosestWorkTime(t.date, t.unit, t.dir);
      }, _getClosestWorkTime: function(t, e, n) {
        var i = new Date(t);
        if (this._isWorkTime(i, e)) return i;
        if (i = this.$gantt.date[e + "_start"](i), n != "any" && n) i = n == "past" ? this._getClosestWorkTimePast(i, e) : this._getClosestWorkTimeFuture(i, e);
        else {
          var a = this._getClosestWorkTimeFuture(i, e), r = this._getClosestWorkTimePast(i, e);
          i = Math.abs(a - t) <= Math.abs(t - r) ? a : r;
        }
        return i;
      }, _getClosestWorkTimeFuture: function(t, e) {
        return this._getClosestWorkTimeGeneric(t, e, 1);
      }, _getClosestWorkTimePast: function(t, e) {
        var n = this._getClosestWorkTimeGeneric(t, e, -1);
        return this.$gantt.date.add(n, 1, e);
      }, _findClosestTimeInDay: function(t, e, n) {
        var i = new Date(t), a = null, r = false;
        this._getWorkHours(i).length || (i = this._getClosestWorkTime(i, "day", e < 0 ? "past" : "future"), e < 0 && (i = new Date(i.valueOf() - 1), r = true), n = this._getWorkHours(i));
        var s = this._getTimeOfDayStamp(i);
        if (r && (s = this._getTimeOfDayStamp(new Date(i.valueOf() + 1), r)), e > 0) {
          for (var o = 0; o < n.length; o++) if (n[o].start >= s) {
            a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, n[o].start);
            break;
          }
        } else for (o = n.length - 1; o >= 0; o--) {
          if (n[o].end <= s) {
            a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, n[o].end);
            break;
          }
          if (n[o].end > s && n[o].start <= s) {
            a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, s);
            break;
          }
        }
        return a;
      }, _getClosestWorkMinute: function(t, e, n) {
        var i = new Date(t), a = this._getWorkHours(i), r = this._findClosestTimeInDay(i, n, a);
        return r || (i = this.calculateEndDate(i, n, "day"), n > 0 ? i = this.$gantt.date.day_start(i) : (i = this.$gantt.date.day_start(i), i = this.$gantt.date.add(i, 1, "day"), i = new Date(i.valueOf() - 1)), a = this._getWorkHours(i), r = this._findClosestTimeInDay(i, n, a)), n < 0 && (r = this.$gantt.date.add(r, -1, e)), r;
      }, _getClosestWorkTimeGeneric: function(t, e, n) {
        if (e === "hour" || e === "minute") return this._getClosestWorkMinute(t, e, n);
        for (var i = this._getUnitOrder(e), a = this.units[i - 1], r = t, s = 0; !this._isWorkTime(r, e) && (!a || this._isWorkTime(r, a) || (r = n > 0 ? this._getClosestWorkTimeFuture(r, a) : this._getClosestWorkTimePast(r, a), !this._isWorkTime(r, e))); ) {
          if (++s > 3e3) return this.$gantt.assert(false, "Invalid working time check"), false;
          var o = r.getTimezoneOffset();
          r = this.$gantt.date.add(r, n, e), r = this.$gantt._correct_dst_change(r, o, n, e), this.$gantt.date[e + "_start"] && (r = this.$gantt.date[e + "_start"](r));
        }
        return r;
      }, hasWorkTime: function() {
        var t = this.getConfig(), e = t.dates;
        for (var n in t.dates) ;
        var i = this._checkWorkHours(t.hours), a = false;
        return [0, 1, 2, 3, 4, 5, 6].forEach(function(r) {
          if (!a) {
            var s = e[r];
            s === true ? a = i : Array.isArray(s) && (a = this._checkWorkHours(s));
          }
        }.bind(this)), a;
      }, _checkWorkHours: function(t) {
        if (t.length === 0) return false;
        for (var e = false, n = 0; n < t.length; n += 2) t[n] !== t[n + 1] && (e = true);
        return e;
      }, _isMinutePrecision: function(t) {
        let e = false;
        return this._getWorkHours(t).forEach(function(n) {
          (n.startMinute % 60 || n.endMinute % 60) && (e = true);
        }), e;
      } };
      const Dt = { isLegacyResourceCalendarFormat: function(t) {
        if (!t) return false;
        for (var e in t) if (t[e] && typeof t[e] == "object") return true;
        return false;
      }, getResourceProperty: function(t) {
        var e = t.resource_calendars, n = t.resource_property;
        if (this.isLegacyResourceCalendarFormat(e)) for (var i in t) {
          n = i;
          break;
        }
        return n;
      }, getCalendarIdFromLegacyConfig: function(t, e) {
        if (e) for (var n in e) {
          var i = e[n];
          if (t[n]) {
            var a = i[t[n]];
            if (a) return a;
          }
        }
        return null;
      } }, bi = (jt = {}, { getCalendarIdFromMultipleResources: function(t, e) {
        var n = function(a) {
          return a.map(function(r) {
            return r && r.resource_id ? r.resource_id : r;
          }).sort().join("-");
        }(t);
        if (t.length) {
          if (t.length === 1) return e.getResourceCalendar(n).id;
          if (jt[n]) return jt[n].id;
          var i = function(a, r) {
            return r.mergeCalendars(a.map(function(s) {
              var o = s && s.resource_id ? s.resource_id : s;
              return r.getResourceCalendar(o);
            }));
          }(t, e);
          return jt[n] = i, e.addCalendar(i);
        }
        return null;
      } });
      var jt;
      function tn(t) {
        this.$gantt = t, this._calendars = {}, this._legacyConfig = void 0, this.$gantt.attachEvent("onGanttReady", function() {
          this.$gantt.config.resource_calendars && (this._isLegacyConfig = Dt.isLegacyResourceCalendarFormat(this.$gantt.config.resource_calendars));
        }.bind(this)), this.$gantt.attachEvent("onBeforeGanttReady", function() {
          this.createDefaultCalendars();
        }.bind(this)), this.$gantt.attachEvent("onBeforeGanttRender", function() {
          this.createDefaultCalendars();
        }.bind(this));
      }
      function pe(t, e) {
        this.argumentsHelper = e, this.$gantt = t;
      }
      function en(t) {
        this.$gantt = t.$gantt, this.argumentsHelper = Ze(this.$gantt), this.calendarManager = t, this.$disabledCalendar = new pe(this.$gantt, this.argumentsHelper);
      }
      tn.prototype = { _calendars: {}, _convertWorkTimeSettings: function(t) {
        var e = t.days;
        if (e && !t.dates) {
          t.dates = t.dates || {};
          for (var n = 0; n < e.length; n++) t.dates[n] = e[n], e[n] instanceof Array || (t.dates[n] = !!e[n]);
        }
        return delete t.days, t;
      }, mergeCalendars: function() {
        var t = [], e = arguments;
        if (Array.isArray(e[0])) t = e[0].slice();
        else for (var n = 0; n < arguments.length; n++) t.push(arguments[n]);
        var i, a = new Qe();
        return t.forEach(function(r) {
          i = i ? this._createCalendarFromConfig(a.merge(i, r)) : r;
        }.bind(this)), this.createCalendar(i);
      }, _createCalendarFromConfig: function(t) {
        var e = new fe(this.$gantt, Ze(this.$gantt));
        e.id = String(at());
        var n = this._convertWorkTimeSettings(t);
        if (n.customWeeks) for (var i in n.customWeeks) n.customWeeks[i] = this._convertWorkTimeSettings(n.customWeeks[i]);
        return e._setConfig(n), e;
      }, createCalendar: function(t) {
        var e;
        return t || (t = {}), N(e = t.getConfig ? V(t.getConfig()) : t.worktime ? V(t.worktime) : V(t), V(this.defaults.fulltime.worktime)), this._createCalendarFromConfig(e);
      }, getCalendar: function(t) {
        t = t || "global";
        var e = this._calendars[t];
        return e || (this.createDefaultCalendars(), e = this._calendars[t]), e;
      }, getCalendars: function() {
        var t = [];
        for (var e in this._calendars) t.push(this.getCalendar(e));
        return t;
      }, _getOwnCalendar: function(t) {
        var e = this.$gantt.config;
        if (t[e.calendar_property]) return this.getCalendar(t[e.calendar_property]);
        if (e.resource_calendars) {
          var n;
          if (n = this._legacyConfig === false ? e.resource_property : Dt.getResourceProperty(e), Array.isArray(t[n])) e.dynamic_resource_calendars ? i = bi.getCalendarIdFromMultipleResources(t[n], this) : a = this.getResourceCalendar(t[n]);
          else if (this._legacyConfig === void 0 && (this._legacyConfig = Dt.isLegacyResourceCalendarFormat(e.resource_calendars)), this._legacyConfig) var i = Dt.getCalendarIdFromLegacyConfig(t, e.resource_calendars);
          else if (n && t[n] && e.resource_calendars[t[n]]) var a = this.getResourceCalendar(t[n]);
          if (i && (a = this.getCalendar(i)), a) return a;
        }
        return null;
      }, getResourceCalendar: function(t) {
        if (t == null) return this.getCalendar();
        var e = null;
        e = typeof t == "number" || typeof t == "string" ? t : t.id || t.key;
        var n = this.$gantt.config, i = n.resource_calendars, a = null;
        if (Array.isArray(t) && t.length === 1 && (e = typeof t[0] == "object" ? t[0].resource_id : t[0]), i) {
          if (this._legacyConfig === void 0 && (this._legacyConfig = Dt.isLegacyResourceCalendarFormat(n.resource_calendars)), this._legacyConfig) {
            for (var r in i) if (i[r][e]) {
              a = i[r][e];
              break;
            }
          } else a = i[e];
          if (a) return this.getCalendar(a);
        }
        return this.getCalendar();
      }, getTaskCalendar: function(t) {
        var e, n = this.$gantt;
        if (t == null) return this.getCalendar();
        if (!(e = typeof t != "number" && typeof t != "string" || !n.isTaskExists(t) ? t : n.getTask(t))) return this.getCalendar();
        var i = this._getOwnCalendar(e), a = !!n.getState().group_mode;
        if (!i && n.config.inherit_calendar && n.isTaskExists(e.parent)) {
          for (var r = e; n.isTaskExists(r.parent) && (r = n.getTask(r.parent), !n.isSummaryTask(r) || !(i = this._getOwnCalendar(r))); ) ;
          a && !i && t.$effective_calendar && (i = this.getCalendar(t.$effective_calendar));
        }
        return i || this.getCalendar();
      }, addCalendar: function(t) {
        if (!this.isCalendar(t)) {
          var e = t.id;
          (t = this.createCalendar(t)).id = e;
        }
        if (t._tryChangeCalendarSettings(function() {
        })) {
          var n = this.$gantt.config;
          return t.id = t.id || at(), this._calendars[t.id] = t, n.worktimes || (n.worktimes = {}), n.worktimes[t.id] = t.getConfig(), t.id;
        }
        return this.$gantt.callEvent("onCalendarError", [{ message: "Invalid calendar settings, no worktime available" }, t]), null;
      }, deleteCalendar: function(t) {
        var e = this.$gantt.config;
        return !!t && !!this._calendars[t] && (delete this._calendars[t], e.worktimes && e.worktimes[t] && delete e.worktimes[t], true);
      }, restoreConfigCalendars: function(t) {
        for (var e in t) if (!this._calendars[e]) {
          var n = t[e], i = this.createCalendar(n);
          i.id = e, this.addCalendar(i);
        }
      }, defaults: { global: { id: "global", worktime: { hours: [8, 12, 13, 17], days: [0, 1, 1, 1, 1, 1, 0] } }, fulltime: { id: "fulltime", worktime: { hours: [0, 24], days: [1, 1, 1, 1, 1, 1, 1] } } }, createDefaultCalendars: function() {
        var t = this.$gantt.config;
        this.restoreConfigCalendars(this.defaults), this.restoreConfigCalendars(t.worktimes);
      }, isCalendar: function(t) {
        return [t.isWorkTime, t.setWorkTime, t.getWorkHours, t.unsetWorkTime, t.getClosestWorkTime, t.calculateDuration, t.hasDuration, t.calculateEndDate].every(function(e) {
          return e instanceof Function;
        });
      } }, pe.prototype = { getWorkHours: function() {
        return [0, 24];
      }, setWorkTime: function() {
        return true;
      }, unsetWorkTime: function() {
        return true;
      }, isWorkTime: function() {
        return true;
      }, getClosestWorkTime: function(t) {
        return this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments).date;
      }, calculateDuration: function() {
        var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.end_date, i = t.unit, a = t.step;
        return this._calculateDuration(e, n, i, a);
      }, _calculateDuration: function(t, e, n, i) {
        var a = this.$gantt.date, r = { week: 6048e5, day: 864e5, hour: 36e5, minute: 6e4 }, s = 0;
        if (r[n]) s = Math.round((e - t) / (i * r[n]));
        else {
          for (var o = new Date(t), l = new Date(e); o.valueOf() < l.valueOf(); ) s += 1, o = a.add(o, i, n);
          o.valueOf() != e.valueOf() && (s += (l - o) / (a.add(o, i, n) - o));
        }
        return Math.round(s);
      }, hasDuration: function() {
        var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.end_date;
        return !!t.unit && (e = new Date(e), n = new Date(n), e.valueOf() < n.valueOf());
      }, hasWorkTime: function() {
        return true;
      }, equals: function(t) {
        return t instanceof pe;
      }, calculateEndDate: function() {
        var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments), e = t.start_date, n = t.duration, i = t.unit, a = t.step;
        return this.$gantt.date.add(e, a * n, i);
      } }, en.prototype = { _getCalendar: function(t) {
        var e;
        if (this.$gantt.config.work_time) {
          var n = this.calendarManager;
          t.task ? e = n.getTaskCalendar(t.task) : t.id ? e = n.getTaskCalendar(t) : t.calendar && (e = t.calendar), e || (e = n.getTaskCalendar());
        } else e = this.$disabledCalendar;
        return e;
      }, getWorkHours: function(t) {
        return t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).getWorkHours(t.date);
      }, setWorkTime: function(t, e) {
        return t = this.argumentsHelper.setWorkTimeArguments.apply(this.argumentsHelper, arguments), e || (e = this.calendarManager.getCalendar()), e.setWorkTime(t);
      }, unsetWorkTime: function(t, e) {
        return t = this.argumentsHelper.unsetWorkTimeArguments.apply(this.argumentsHelper, arguments), e || (e = this.calendarManager.getCalendar()), e.unsetWorkTime(t);
      }, isWorkTime: function(t, e, n, i) {
        var a = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);
        return (i = this._getCalendar(a)).isWorkTime(a);
      }, getClosestWorkTime: function(t) {
        return t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).getClosestWorkTime(t);
      }, calculateDuration: function() {
        var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);
        return this._getCalendar(t).calculateDuration(t);
      }, hasDuration: function() {
        var t = this.argumentsHelper.hasDurationArguments.apply(this.argumentsHelper, arguments);
        return this._getCalendar(t).hasDuration(t);
      }, calculateEndDate: function(t) {
        return t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).calculateEndDate(t);
      } };
      const xi = { create: function(t, e) {
        return { getWorkHours: function(n) {
          return e.getWorkHours(n);
        }, setWorkTime: function(n) {
          return e.setWorkTime(n);
        }, unsetWorkTime: function(n) {
          e.unsetWorkTime(n);
        }, isWorkTime: function(n, i, a) {
          return e.isWorkTime(n, i, a);
        }, getClosestWorkTime: function(n) {
          return e.getClosestWorkTime(n);
        }, calculateDuration: function(n, i, a) {
          return e.calculateDuration(n, i, a);
        }, _hasDuration: function(n, i, a) {
          return e.hasDuration(n, i, a);
        }, calculateEndDate: function(n, i, a, r) {
          return e.calculateEndDate(n, i, a, r);
        }, mergeCalendars: R(t.mergeCalendars, t), createCalendar: R(t.createCalendar, t), addCalendar: R(t.addCalendar, t), getCalendar: R(t.getCalendar, t), getCalendars: R(t.getCalendars, t), getResourceCalendar: R(t.getResourceCalendar, t), getTaskCalendar: R(t.getTaskCalendar, t), deleteCalendar: R(t.deleteCalendar, t) };
      } };
      function $i(t) {
        t.isUnscheduledTask = function(s) {
          return t.assert(s && s instanceof Object, "Invalid argument <b>task</b>=" + s + " of gantt.isUnscheduledTask. Task object was expected"), !!s.unscheduled || !s.start_date;
        }, t._isAllowedUnscheduledTask = function(s) {
          return !(!s.unscheduled || !t.config.show_unscheduled);
        }, t._isTaskInTimelineLimits = function(s) {
          var o = s.start_date ? s.start_date.valueOf() : null, l = s.end_date ? s.end_date.valueOf() : null;
          return !!(o && l && o <= this._max_date.valueOf() && l >= this._min_date.valueOf());
        }, t.isTaskVisible = function(s) {
          if (!this.isTaskExists(s)) return false;
          var o = this.getTask(s);
          return !(!this._isAllowedUnscheduledTask(o) && !this._isTaskInTimelineLimits(o)) && this.getGlobalTaskIndex(s) >= 0;
        }, t._getProjectEnd = function() {
          if (t.config.project_end) return t.config.project_end;
          var s = t.getTaskByTime();
          return (s = s.sort(function(o, l) {
            return +o.end_date > +l.end_date ? 1 : -1;
          })).length ? s[s.length - 1].end_date : null;
        }, t._getProjectStart = function() {
          if (t.config.project_start) return t.config.project_start;
          if (t.config.start_date) return t.config.start_date;
          if (t.getState().min_date) return t.getState().min_date;
          var s = t.getTaskByTime();
          return (s = s.sort(function(o, l) {
            return +o.start_date > +l.start_date ? 1 : -1;
          })).length ? s[0].start_date : null;
        };
        var e = function(s, o) {
          var l = !!(o && o != t.config.root_id && t.isTaskExists(o)) && t.getTask(o), d = null;
          if (l) if (t.config.schedule_from_end) d = t.calculateEndDate({ start_date: l.end_date, duration: -t.config.duration_step, task: s });
          else {
            if (!l.start_date) return e(l, t.getParent(l));
            d = l.start_date;
          }
          else if (t.config.schedule_from_end) d = t.calculateEndDate({ start_date: t._getProjectEnd(), duration: -t.config.duration_step, task: s });
          else {
            const c = t.getTaskByIndex(0), u = t.config.start_date || t.getState().min_date;
            d = c ? c.start_date ? c.start_date : c.end_date ? t.calculateEndDate({ start_date: c.end_date, duration: -t.config.duration_step, task: s }) : u : u;
          }
          return t.assert(d, "Invalid dates"), new Date(d);
        };
        t._set_default_task_timing = function(s) {
          s.start_date = s.start_date || e(s, t.getParent(s)), s.duration = s.duration || t.config.duration_step, s.end_date = s.end_date || t.calculateEndDate(s);
        }, t.createTask = function(s, o, l) {
          if (s = s || {}, t.defined(s.id) || (s.id = t.uid()), s.start_date || (s.start_date = e(s, o)), s.text === void 0 && (s.text = t.locale.labels.new_task), s.duration === void 0 && (s.duration = 1), this.isTaskExists(o)) {
            this.setParent(s, o, true);
            var d = this.getTask(o);
            d.$open = true, this.config.details_on_create || this.callEvent("onAfterParentExpand", [o, d]);
          }
          return this.callEvent("onTaskCreated", [s]) ? (this.config.details_on_create ? (t.isTaskExists(s.id) ? t.getTask(s.id).$index != s.$index && (s.start_date && typeof s.start_date == "string" && (s.start_date = this.date.parseDate(s.start_date, "parse_date")), s.end_date && typeof s.end_date == "string" && (s.end_date = this.date.parseDate(s.end_date, "parse_date")), this.$data.tasksStore.updateItem(s.id, s)) : (s.$new = true, this.silent(function() {
            t.$data.tasksStore.addItem(s, l);
          })), this.selectTask(s.id), this.refreshData(), this.showLightbox(s.id)) : this.addTask(s, o, l) && (this.showTask(s.id), this.selectTask(s.id)), s.id) : null;
        }, t._update_flags = function(s, o) {
          var l = t.$data.tasksStore;
          s === void 0 ? (this._lightbox_id = null, l.silent(function() {
            l.unselect();
          }), this.getSelectedTasks && this._multiselect.reset(), this._tasks_dnd && this._tasks_dnd.drag && (this._tasks_dnd.drag.id = null)) : (this._lightbox_id == s && (this._lightbox_id = o), l.getSelectedId() == s && l.silent(function() {
            l.unselect(s), l.select(o);
          }), this._tasks_dnd && this._tasks_dnd.drag && this._tasks_dnd.drag.id == s && (this._tasks_dnd.drag.id = o));
        };
        var n = function(s, o) {
          var l = t.getTaskType(s.type), d = { type: l, $no_start: false, $no_end: false, scheduled_summary: false };
          return l === t.config.types.project && s.auto_scheduling === false && (d.scheduled_summary = true), o || l != s.$rendered_type ? (l == t.config.types.project ? d.$no_end = d.$no_start = true : l != t.config.types.milestone && (d.$no_end = !(s.end_date || s.duration), d.$no_start = !s.start_date, t._isAllowedUnscheduledTask(s) && (d.$no_end = d.$no_start = false)), d) : (d.$no_start = s.$no_start, d.$no_end = s.$no_end, d);
        };
        function i(s) {
          s.$effective_calendar = t.getTaskCalendar(s).id, s.start_date = t.getClosestWorkTime({ dir: "future", date: s.start_date, unit: t.config.duration_unit, task: s }), s.end_date = t.calculateEndDate(s);
        }
        function a(s, o, l, d) {
          const c = { start: "start_date", end: "end_date" }, u = { start: "$auto_start_date", end: "$auto_end_date" };
          let h;
          h = s.type === t.config.types.project && s.auto_scheduling === false ? u : c, o.$no_start && (s[h.start] = l ? new Date(l) : e(s, this.getParent(s))), o.$no_end && (s[h.end] = d ? new Date(d) : this.calculateEndDate({ start_date: s[h.start], duration: this.config.duration_step, task: s })), (o.$no_start || o.$no_end) && this._init_task_timing(s);
        }
        function r(s) {
          var o = null, l = null, d = s !== void 0 ? s : t.config.root_id, c = [];
          return t.eachTask(function(u) {
            const h = t.getTaskType(u.type) == t.config.types.project && u.auto_scheduling === false;
            t.getTaskType(u.type) == t.config.types.project && !h || t.isUnscheduledTask(u) || (u.rollup && c.push(u.id), !u.start_date || u.$no_start && !h || o && !(o > u.start_date.valueOf()) || (o = u.start_date.valueOf()), !u.end_date || u.$no_end && !h || l && !(l < u.end_date.valueOf()) || (l = u.end_date.valueOf()));
          }, d), { start_date: o ? new Date(o) : null, end_date: l ? new Date(l) : null, rollup: c };
        }
        t._init_task_timing = function(s) {
          var o = n(s, true), l = s.$rendered_type != o.type, d = o.type;
          l && (s.$no_start = o.$no_start, s.$no_end = o.$no_end, s.$rendered_type = o.type), l && d != this.config.types.milestone && d == this.config.types.project && (this._set_default_task_timing(s), s.$calculate_duration = false), d == this.config.types.milestone && (s.end_date = s.start_date), s.start_date && s.end_date && s.$calculate_duration !== false && (s.duration = this.calculateDuration(s)), s.$calculate_duration || (s.$calculate_duration = true), s.end_date || (s.end_date = s.start_date), s.duration = s.duration || 0, this.config.min_duration === 0 && s.duration === 0 && (s.$no_end = false);
          var c = this.getTaskCalendar(s);
          s.$effective_calendar && s.$effective_calendar !== c.id && (i(s), this.config.inherit_calendar && this.isSummaryTask(s) && this.eachTask(function(u) {
            i(u);
          }, s.id)), s.$effective_calendar = c.id;
        }, t.isSummaryTask = function(s) {
          t.assert(s && s instanceof Object, "Invalid argument <b>task</b>=" + s + " of gantt.isSummaryTask. Task object was expected");
          var o = n(s);
          return !(!o.$no_end && !o.$no_start);
        }, t.resetProjectDates = function(s) {
          var o = n(s);
          if (o.$no_end || o.$no_start) {
            var l = r(s.id);
            a.call(this, s, o, l.start_date, l.end_date), s.$rollup = l.rollup;
          }
        }, t.getSubtaskDuration = function(s) {
          var o = 0, l = s !== void 0 ? s : t.config.root_id;
          return this.eachTask(function(d) {
            this.getTaskType(d.type) == t.config.types.project || this.isUnscheduledTask(d) || (o += d.duration);
          }, l), o;
        }, t.getSubtaskDates = function(s) {
          var o = r(s);
          return { start_date: o.start_date, end_date: o.end_date };
        }, t._update_parents = function(s, o, l) {
          if (s) {
            var d = this.getTask(s);
            d.rollup && (l = true);
            var c = this.getParent(d), u = n(d), h = true;
            if (l || d.start_date && d.end_date && (u.$no_start || u.$no_end)) {
              const y = d.$auto_start_date ? "$auto_start_date" : "start_date", v = d.$auto_end_date ? "$auto_end_date" : "end_date";
              var g = d[y].valueOf(), f = d[v].valueOf();
              t.resetProjectDates(d), l || g != d[y].valueOf() || f != d[v].valueOf() || (h = false), h && !o && this.refreshTask(d.id, true), u.scheduled_summary && (h = true);
            }
            h && c && this.isTaskExists(c) && this._update_parents(c, o, l);
          }
        }, t.roundDate = function(s) {
          var o = t.getScale();
          J(s) && (s = { date: s, unit: o ? o.unit : t.config.duration_unit, step: o ? o.step : t.config.duration_step });
          var l, d, c, u = s.date, h = s.step, g = s.unit;
          if (!o) return u;
          if (g == o.unit && h == o.step && +u >= +o.min_date && +u <= +o.max_date) c = Math.floor(t.columnIndexByDate(u)), o.trace_x[c] || (c -= 1, o.rtl && (c = 0)), d = new Date(o.trace_x[c]), l = t.date.add(d, h, g);
          else {
            for (c = Math.floor(t.columnIndexByDate(u)), l = t.date[g + "_start"](new Date(o.min_date)), o.trace_x[c] && (l = t.date[g + "_start"](o.trace_x[c])); +l < +u; ) {
              var f = (l = t.date[g + "_start"](t.date.add(l, h, g))).getTimezoneOffset();
              l = t._correct_dst_change(l, f, l, g), t.date[g + "_start"] && (l = t.date[g + "_start"](l));
            }
            d = t.date.add(l, -1 * h, g);
          }
          return s.dir && s.dir == "future" ? l : s.dir && s.dir == "past" || Math.abs(u - d) < Math.abs(l - u) ? d : l;
        }, t.correctTaskWorkTime = function(s) {
          t.config.work_time && t.config.correct_work_time && (this.isWorkTime(s.start_date, void 0, s) ? this.isWorkTime(new Date(+s.end_date - 1), void 0, s) || (s.end_date = this.calculateEndDate(s)) : (s.start_date = this.getClosestWorkTime({ date: s.start_date, dir: "future", task: s }), s.end_date = this.calculateEndDate(s)));
        }, t.attachEvent("onBeforeTaskUpdate", function(s, o) {
          return t._init_task_timing(o), true;
        }), t.attachEvent("onBeforeTaskAdd", function(s, o) {
          return t._init_task_timing(o), true;
        }), t.attachEvent("onAfterTaskMove", function(s, o, l) {
          return t._init_task_timing(t.getTask(s)), true;
        });
      }
      function nn(t, e) {
        var n, i = t.config.container_resize_timeout || 20;
        let a = an(t);
        if (t.config.container_resize_method == "timeout") l();
        else try {
          t.event(e, "resize", function() {
            if (t.$scrollbarRepaint) t.$scrollbarRepaint = null;
            else {
              let d = an(t);
              if (a.x == d.x && a.y == d.y) return;
              a = d, r();
            }
          });
        } catch {
          l();
        }
        function r() {
          clearTimeout(n), n = setTimeout(function() {
            t.$destroyed || t.render();
          }, i);
        }
        var s = t.$root.offsetHeight, o = t.$root.offsetWidth;
        function l() {
          t.$root.offsetHeight == s && t.$root.offsetWidth == o || r(), s = t.$root.offsetHeight, o = t.$root.offsetWidth, setTimeout(l, i);
        }
      }
      function an(t) {
        return { x: t.$root.offsetWidth, y: t.$root.offsetHeight };
      }
      function wi(t) {
        t.assert = /* @__PURE__ */ function(r) {
          return function(s, o) {
            s || r.config.show_errors && r.callEvent("onError", [o]) !== false && (r.message ? r.message({ type: "error", text: o, expire: -1 }) : console.log(o));
          };
        }(t);
        var e = "Invalid value of the first argument of `gantt.init`. Supported values: HTMLElement, String (element id).This error means that either invalid object is passed into `gantt.init` or that the element with the specified ID doesn't exist on the page when `gantt.init` is called.";
        function n(r) {
          if (!r || typeof r == "string" && document.getElementById(r) || function(s) {
            try {
              s.cloneNode(false);
            } catch {
              return false;
            }
            return true;
          }(r)) return true;
          throw t.assert(false, e), new Error(e);
        }
        t.init = function(r, s, o) {
          t.env.isNode ? r = null : n(r), s && o && (this.config.start_date = this._min_date = new Date(s), this.config.end_date = this._max_date = new Date(o)), this.date.init(), this.init = function(l) {
            t.env.isNode ? l = null : n(l), this.$container && this.$container.parentNode && (this.$container.parentNode.removeChild(this.$container), this.$container = null), this.$layout && this.$layout.clear(), this._reinit(l);
          }, this._reinit(r);
        }, t._quickRefresh = function(r) {
          for (var s = this._getDatastores.call(this), o = 0; o < s.length; o++) s[o]._quick_refresh = true;
          for (r(), o = 0; o < s.length; o++) s[o]._quick_refresh = false;
        };
        var i = function() {
          this._clearTaskLayers && this._clearTaskLayers(), this._clearLinkLayers && this._clearLinkLayers(), this.$layout && (this.$layout.destructor(), this.$layout = null, this.$ui.reset());
        }.bind(t), a = function() {
          F(t) || (this.$root.innerHTML = "", this.$root.gantt = this, de(this), this.config.layout.id = "main", this.$layout = this.$ui.createView("layout", this.$root, this.config.layout), this.$layout.attachEvent("onBeforeResize", function() {
            for (var r = t.$services.getService("datastores"), s = 0; s < r.length; s++) t.getDatastore(r[s]).filter(), t.$data.tasksStore._skipTaskRecalculation ? t.$data.tasksStore._skipTaskRecalculation != "lightbox" && (t.$data.tasksStore._skipTaskRecalculation = false) : t.getDatastore(r[s]).callEvent("onBeforeRefreshAll", []);
          }), this.$layout.attachEvent("onResize", function() {
            t._quickRefresh(function() {
              t.refreshData();
            });
          }), this.callEvent("onGanttLayoutReady", []), this.$layout.render(), this.$container = this.$layout.$container.firstChild, function(r) {
            window.getComputedStyle(r.$root).getPropertyValue("position") == "static" && (r.$root.style.position = "relative");
            var s = document.createElement("iframe");
            s.className = "gantt_container_resize_watcher", s.tabIndex = -1, r.config.wai_aria_attributes && (s.setAttribute("role", "none"), s.setAttribute("aria-hidden", true)), (window.Sfdc || window.$A || window.Aura) && (r.config.container_resize_method = "timeout"), r.$root.appendChild(s), s.contentWindow ? nn(r, s.contentWindow) : (r.$root.removeChild(s), nn(r, window));
          }(this));
        }.bind(t);
        t.resetLayout = function() {
          i(), a(), this.render();
        }, t._reinit = function(r) {
          this.callEvent("onBeforeGanttReady", []), this._update_flags(), this.$services.getService("templateLoader").initTemplates(this), i(), this.$root = null, r && (this.$root = Qt(r), a(), this.$mouseEvents.reset(this.$root), function(s) {
            s.$container && !s.config.autosize && s.$root.offsetHeight < 50 && console.warn(`The Gantt container has a small height, so you cannot see its content. If it is not intended, you need to set the 'height' style rule to the container:
https://docs.dhtmlx.com/gantt/faq.html#theganttchartisntrenderedcorrectly`);
          }(t)), this.callEvent("onTemplatesReady", []), this.callEvent("onGanttReady", []), this.render();
        }, t.$click = { buttons: { edit: function(r) {
          t.isReadonly(t.getTask(r)) || t.showLightbox(r);
        }, delete: function(r) {
          var s = t.getTask(r);
          if (!t.isReadonly(s)) {
            var o = t.locale.labels.confirm_deleting, l = t.locale.labels.confirm_deleting_title;
            t._simple_confirm(o, l, function() {
              t.isTaskExists(r) && (s.$new ? (t.$data.tasksStore._skipTaskRecalculation = "lightbox", t.silent(function() {
                t.deleteTask(r, true);
              }), t.$data.tasksStore._skipTaskRecalculation = false, t.refreshData()) : (t.$data.tasksStore._skipTaskRecalculation = true, t.deleteTask(r))), t.hideLightbox();
            });
          }
        } } }, t.render = function() {
          var r;
          if (this.callEvent("onBeforeGanttRender", []), !F(t)) {
            !this.config.sort && this._sort && (this._sort = void 0), this.$root && (this.config.rtl ? (this.$root.classList.add("gantt_rtl"), this.$root.firstChild.classList.add("gantt_rtl")) : (this.$root.classList.remove("gantt_rtl"), this.$root.firstChild.classList.remove("gantt_rtl")));
            var s = this.getScrollState(), o = s ? s.x : 0;
            this._getHorizontalScrollbar() && (o = this._getHorizontalScrollbar().$config.codeScrollLeft || o || 0), r = null, o && (r = t.dateFromPos(o + this.config.task_scroll_offset));
          }
          if (de(this), F(t)) t.refreshData();
          else {
            this.$layout.$config.autosize = this.config.autosize;
            var l = this.config.preserve_scroll;
            if (this.config.preserve_scroll = false, this.$layout.resize(), this.config.preserve_scroll = l, this.config.preserve_scroll && s) {
              if (o || s.y) {
                var d = t.getScrollState();
                if (+r != +t.dateFromPos(d.x) || d.y != s.y) {
                  o = null;
                  var c = null;
                  r && (o = Math.max(t.posFromDate(r) - t.config.task_scroll_offset, 0)), s.y && (c = s.y), t.scrollTo(o, c);
                }
              }
              var u = t.$ui.getView("grid");
              if (u) {
                var h = u.$config.scrollY, g = t.$ui.getView(h);
                g && (t.utils.dom.isChildOf(g.$view, t.$container) || u.scrollTo(void 0, 0));
              }
            }
          }
          this.callEvent("onGanttRender", []);
        }, t.setSizes = t.render, t.getTaskRowNode = function(r) {
          for (var s = this.$grid_data.childNodes, o = this.config.task_attribute, l = 0; l < s.length; l++) if (s[l].getAttribute && s[l].getAttribute(o) == r) return s[l];
          return null;
        }, t.changeLightboxType = function(r) {
          if (this.getLightboxType() == r) return true;
          t._silent_redraw_lightbox(r);
        }, t._get_link_type = function(r, s) {
          var o = null;
          return r && s ? o = t.config.links.start_to_start : !r && s ? o = t.config.links.finish_to_start : r || s ? r && !s && (o = t.config.links.start_to_finish) : o = t.config.links.finish_to_finish, o;
        }, t.isLinkAllowed = function(r, s, o, l) {
          var d = null;
          if (!(d = typeof r == "object" ? r : { source: r, target: s, type: this._get_link_type(o, l) }) || !(d.source && d.target && d.type) || d.source == d.target) return false;
          var c = true;
          return this.checkEvent("onLinkValidation") && (c = this.callEvent("onLinkValidation", [d])), c;
        }, t._correct_dst_change = function(r, s, o, l) {
          var d = Bt(l) * o;
          if (d > 3600 && d < 86400) {
            var c = r.getTimezoneOffset() - s;
            c && (r = t.date.add(r, c, "minute"));
          }
          return r;
        }, t.isSplitTask = function(r) {
          return t.assert(r && r instanceof Object, "Invalid argument <b>task</b>=" + r + " of gantt.isSplitTask. Task object was expected"), this.$data.tasksStore._isSplitItem(r);
        }, t._is_icon_open_click = function(r) {
          if (!r) return false;
          var s = r.target || r.srcElement;
          if (!s || !s.className) return false;
          var o = Y(s);
          return o.indexOf("gantt_tree_icon") !== -1 && (o.indexOf("gantt_close") !== -1 || o.indexOf("gantt_open") !== -1);
        };
      }
      const Si = { date: { month_full: ["\u0643\u0627\u0646\u0648\u0646 \u0627\u0644\u062B\u0627\u0646\u064A", "\u0634\u0628\u0627\u0637", "\u0622\u0630\u0627\u0631", "\u0646\u064A\u0633\u0627\u0646", "\u0623\u064A\u0627\u0631", "\u062D\u0632\u064A\u0631\u0627\u0646", "\u062A\u0645\u0648\u0632", "\u0622\u0628", "\u0623\u064A\u0644\u0648\u0644", "\u062A\u0634\u0631\u064A\u0646 \u0627\u0644\u0623\u0648\u0644", "\u062A\u0634\u0631\u064A\u0646 \u0627\u0644\u062B\u0627\u0646\u064A", "\u0643\u0627\u0646\u0648\u0646 \u0627\u0644\u0623\u0648\u0644"], month_short: ["\u064A\u0646\u0627\u064A\u0631", "\u0641\u0628\u0631\u0627\u064A\u0631", "\u0645\u0627\u0631\u0633", "\u0623\u0628\u0631\u064A\u0644", "\u0645\u0627\u064A\u0648", "\u064A\u0648\u0646\u064A\u0648", "\u064A\u0648\u0644\u064A\u0648", "\u0623\u063A\u0633\u0637\u0633", "\u0633\u0628\u062A\u0645\u0628\u0631", "\u0623\u0643\u062A\u0648\u0628\u0631", "\u0646\u0648\u0641\u0645\u0628\u0631", "\u062F\u064A\u0633\u0645\u0628\u0631"], day_full: ["\u0627\u0644\u0623\u062D\u062F", "\u0627\u0644\u0623\u062B\u0646\u064A\u0646", "\u0623\u0644\u062B\u0644\u0627\u062B\u0627\u0621", "\u0627\u0644\u0623\u0631\u0628\u0639\u0627\u0621", "\u0623\u0644\u062D\u0645\u064A\u0633", "\u0623\u0644\u062C\u0645\u0639\u0629", "\u0627\u0644\u0633\u0628\u062A"], day_short: ["\u0627\u062D\u062F", "\u0627\u062B\u0646\u064A\u0646", "\u062B\u0644\u0627\u062B\u0627\u0621", "\u0627\u0631\u0628\u0639\u0627\u0621", "\u062E\u0645\u064A\u0633", "\u062C\u0645\u0639\u0629", "\u0633\u0628\u062A"] }, labels: { new_task: "\u0645\u0647\u0645\u0629 \u062C\u062F\u064A\u062F", icon_save: "\u0627\u062E\u0632\u0646", icon_cancel: "\u0627\u0644\u063A\u0627\u0621", icon_details: "\u062A\u0641\u0627\u0635\u064A\u0644", icon_edit: "\u062A\u062D\u0631\u064A\u0631", icon_delete: "\u062D\u0630\u0641", confirm_closing: "\u0627\u0644\u062A\u063A\u064A\u064A\u0631\u0627\u062A \u0633\u0648\u0641 \u062A\u0636\u064A\u0639, \u0647\u0644 \u0627\u0646\u062A \u0645\u062A\u0623\u0643\u062F\u061F", confirm_deleting: "\u0627\u0644\u062D\u062F\u062B \u0633\u064A\u062A\u0645 \u062D\u0630\u0641\u0647\u0627 \u0646\u0647\u0627\u0626\u064A\u0627 \u060C \u0647\u0644 \u0623\u0646\u062A \u0645\u062A\u0623\u0643\u062F\u061F", section_description: "\u0627\u0644\u0648\u0635\u0641", section_time: "\u0627\u0644\u0641\u062A\u0631\u0629 \u0627\u0644\u0632\u0645\u0646\u064A\u0629", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "\u0627\u0644\u063A\u0627\u0621", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ti = { date: { month_full: ["\u0421\u0442\u0443\u0434\u0437\u0435\u043D\u044C", "\u041B\u044E\u0442\u044B", "\u0421\u0430\u043A\u0430\u0432\u0456\u043A", "\u041A\u0440\u0430\u0441\u0430\u0432\u0456\u043A", "Ma\u0439", "\u0427\u044D\u0440\u0432\u0435\u043D\u044C", "\u041B\u0456\u043F\u0435\u043D\u044C", "\u0416\u043D\u0456\u0432\u0435\u043D\u044C", "\u0412\u0435\u0440\u0430\u0441\u0435\u043D\u044C", "\u041A\u0430\u0441\u0442\u0440\u044B\u0447\u043D\u0456\u043A", "\u041B\u0456\u0441\u0442\u0430\u043F\u0430\u0434", "\u0421\u043D\u0435\u0436\u0430\u043D\u044C"], month_short: ["\u0421\u0442\u0443\u0434\u0437", "\u041B\u044E\u0442", "\u0421\u0430\u043A", "\u041A\u0440\u0430\u0441", "Ma\u0439", "\u0427\u044D\u0440", "\u041B\u0456\u043F", "\u0416\u043D\u0456\u0432", "\u0412\u0435\u0440", "\u041A\u0430\u0441\u0442", "\u041B\u0456\u0441\u0442", "\u0421\u043D\u0435\u0436"], day_full: ["\u041D\u044F\u0434\u0437\u0435\u043B\u044F", "\u041F\u0430\u043D\u044F\u0434\u0437\u0435\u043B\u0430\u043A", "\u0410\u045E\u0442\u043E\u0440\u0430\u043A", "\u0421\u0435\u0440\u0430\u0434\u0430", "\u0427\u0430\u0446\u0432\u0435\u0440", "\u041F\u044F\u0442\u043D\u0456\u0446\u0430", "\u0421\u0443\u0431\u043E\u0442\u0430"], day_short: ["\u041D\u0434", "\u041F\u043D", "\u0410\u045E\u0442", "\u0421\u0440", "\u0427\u0446\u0432", "\u041F\u0442", "\u0421\u0431"] }, labels: { new_task: "\u041D\u043E\u0432\u0430\u0435 \u0437\u0430\u0434\u0430\u043D\u043D\u0435", icon_save: "\u0417\u0430\u0445\u0430\u0432\u0430\u0446\u044C", icon_cancel: "\u0410\u0434\u043C\u044F\u043D\u0456\u0446\u044C", icon_details: "\u0414\u044D\u0442\u0430\u043B\u0456", icon_edit: "\u0417\u043C\u044F\u043D\u0456\u0446\u044C", icon_delete: "\u0412\u044B\u0434\u0430\u043B\u0456\u0446\u044C", confirm_closing: "", confirm_deleting: "\u041F\u0430\u0434\u0437\u0435\u044F \u0431\u0443\u0434\u0437\u0435 \u0432\u044B\u0434\u0430\u043B\u0435\u043D\u0430 \u043D\u0435\u0437\u0432\u0430\u0440\u043E\u0442\u043D\u0430, \u043F\u0440\u0430\u0446\u044F\u0433\u043D\u0443\u0446\u044C?", section_description: "\u0410\u043F\u0456\u0441\u0430\u043D\u043D\u0435", section_time: "\u041F\u0435\u0440\u044B\u044F\u0434 \u0447\u0430\u0441\u0443", section_type: "\u0422\u044B\u043F", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "\u0406\u0421\u0420", column_text: "\u0417\u0430\u0434\u0430\u0447\u0430", column_start_date: "\u041F\u0430\u0447\u0430\u0442\u0430\u043A", column_duration: "\u041F\u0440\u0430\u0446\u044F\u0433", column_add: "", link: "\u0421\u0443\u0432\u044F\u0437\u044C", confirm_link_deleting: "\u0431\u0443\u0434\u0437\u0435 \u0432\u044B\u0434\u0430\u043B\u0435\u043D\u0430", link_start: "(\u043F\u0430\u0447\u0430\u0442\u0430\u043A)", link_end: "(\u043A\u0430\u043D\u0435\u0446)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "\u0425\u0432i\u043Bi\u043D\u0430", hours: "\u0413\u0430\u0434\u0437i\u043D\u0430", days: "\u0414\u0437\u0435\u043D\u044C", weeks: "\u0422\u044B\u0434\u0437\u0435\u043D\u044C", months: "\u041C\u0435\u0441\u044F\u0446", years: "\u0413\u043E\u0434", message_ok: "OK", message_cancel: "\u0410\u0434\u043C\u044F\u043D\u0456\u0446\u044C", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ei = { date: { month_full: ["Gener", "Febrer", "Mar\xE7", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"], month_short: ["Gen", "Feb", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Des"], day_full: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"], day_short: ["Dg", "Dl", "Dm", "Dc", "Dj", "Dv", "Ds"] }, labels: { new_task: "Nova tasca", icon_save: "Guardar", icon_cancel: "Cancel\xB7lar", icon_details: "Detalls", icon_edit: "Editar", icon_delete: "Esborrar", confirm_closing: "", confirm_deleting: "L'esdeveniment s'esborrar\xE0 definitivament, continuar ?", section_description: "Descripci\xF3", section_time: "Periode de temps", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Cancel\xB7lar", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ci = { date: { month_full: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"], month_short: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], day_full: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], day_short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"] }, labels: { new_task: "\u65B0\u4EFB\u52D9", icon_save: "\u4FDD\u5B58", icon_cancel: "\u5173\u95ED", icon_details: "\u8BE6\u7EC6", icon_edit: "\u7F16\u8F91", icon_delete: "\u5220\u9664", confirm_closing: "\u8BF7\u786E\u8BA4\u662F\u5426\u64A4\u9500\u4FEE\u6539!", confirm_deleting: "\u662F\u5426\u5220\u9664\u65E5\u7A0B?", section_description: "\u63CF\u8FF0", section_time: "\u65F6\u95F4\u8303\u56F4", section_type: "\u7C7B\u578B", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "\u5DE5\u4F5C\u5206\u89E3\u7ED3\u6784", column_text: "\u4EFB\u52A1\u540D", column_start_date: "\u5F00\u59CB\u65F6\u95F4", column_duration: "\u6301\u7EED\u65F6\u95F4", column_add: "", link: "\u5173\u8054", confirm_link_deleting: "\u5C06\u88AB\u5220\u9664", link_start: " (\u5F00\u59CB)", link_end: " (\u7ED3\u675F)", type_task: "\u4EFB\u52A1", type_project: "\u9879\u76EE", type_milestone: "\u91CC\u7A0B\u7891", minutes: "\u5206\u949F", hours: "\u5C0F\u65F6", days: "\u5929", weeks: "\u5468", months: "\u6708", years: "\u5E74", message_ok: "OK", message_cancel: "\u5173\u95ED", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Di = { date: { month_full: ["Leden", "\xDAnor", "B\u0159ezen", "Duben", "Kv\u011Bten", "\u010Cerven", "\u010Cervenec", "Srpen", "Z\xE1\u0159\xED", "\u0158\xEDjen", "Listopad", "Prosinec"], month_short: ["Led", "\xDAn", "B\u0159e", "Dub", "Kv\u011B", "\u010Cer", "\u010Cec", "Srp", "Z\xE1\u0159\xED", "\u0158\xEDj", "List", "Pro"], day_full: ["Ned\u011Ble", "Pond\u011Bl\xED", "\xDAter\xFD", "St\u0159eda", "\u010Ctvrtek", "P\xE1tek", "Sobota"], day_short: ["Ne", "Po", "\xDAt", "St", "\u010Ct", "P\xE1", "So"] }, labels: { new_task: "Nov\xE1 pr\xE1ce", icon_save: "Ulo\u017Eit", icon_cancel: "Zp\u011Bt", icon_details: "Detail", icon_edit: "Edituj", icon_delete: "Smazat", confirm_closing: "", confirm_deleting: "Ud\xE1lost bude trvale smaz\xE1na, opravdu?", section_description: "Pozn\xE1mky", section_time: "Doba platnosti", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Zp\u011Bt", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ai = { date: { month_full: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"], month_short: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"], day_full: ["S\xF8ndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "L\xF8rdag"], day_short: ["S\xF8n", "Man", "Tir", "Ons", "Tor", "Fre", "L\xF8r"] }, labels: { new_task: "Ny opgave", icon_save: "Gem", icon_cancel: "Fortryd", icon_details: "Detaljer", icon_edit: "Tilret", icon_delete: "Slet", confirm_closing: "Dine rettelser vil g\xE5 tabt.. Er dy sikker?", confirm_deleting: "Bigivenheden vil blive slettet permanent. Er du sikker?", section_description: "Beskrivelse", section_time: "Tidsperiode", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Fortryd", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ii = { date: { month_full: [" Januar", " Februar", " M\xE4rz ", " April", " Mai", " Juni", " Juli", " August", " September ", " Oktober", " November ", " Dezember"], month_short: ["Jan", "Feb", "M\xE4r", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"], day_full: ["Sonntag", "Montag", "Dienstag", " Mittwoch", " Donnerstag", "Freitag", "Samstag"], day_short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"] }, labels: { new_task: "Neue Aufgabe", icon_save: "Speichern", icon_cancel: "Abbrechen", icon_details: "Details", icon_edit: "\xC4ndern", icon_delete: "L\xF6schen", confirm_closing: "", confirm_deleting: "Der Eintrag wird gel\xF6scht", section_description: "Beschreibung", section_time: "Zeitspanne", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "PSP", column_text: "Task-Namen", column_start_date: "Startzeit", column_duration: "Dauer", column_add: "", link: "Link", confirm_link_deleting: "werden gel\xF6scht", link_start: "(starten)", link_end: "(ende)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minuten", hours: "Stunden", days: "Tage", weeks: "Wochen", months: "Monate", years: "Jahre", message_ok: "OK", message_cancel: "Abbrechen", section_constraint: "Regel", constraint_type: "Regel", constraint_date: "Regel - Datum", asap: "So bald wie m\xF6glich", alap: "So sp\xE4t wie m\xF6glich", snet: "Beginn nicht vor", snlt: "Beginn nicht sp\xE4ter als", fnet: "Fertigstellung nicht vor", fnlt: "Fertigstellung nicht sp\xE4ter als", mso: "Muss beginnen am", mfo: "Muss fertig sein am", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Mi = { date: { month_full: ["\u0399\u03B1\u03BD\u03BF\u03C5\u03AC\u03C1\u03B9\u03BF\u03C2", "\u03A6\u03B5\u03B2\u03C1\u03BF\u03C5\u03AC\u03C1\u03B9\u03BF\u03C2", "\u039C\u03AC\u03C1\u03C4\u03B9\u03BF\u03C2", "\u0391\u03C0\u03C1\u03AF\u03BB\u03B9\u03BF\u03C2", "\u039C\u03AC\u03CA\u03BF\u03C2", "\u0399\u03BF\u03CD\u03BD\u03B9\u03BF\u03C2", "\u0399\u03BF\u03CD\u03BB\u03B9\u03BF\u03C2", "\u0391\u03CD\u03B3\u03BF\u03C5\u03C3\u03C4\u03BF\u03C2", "\u03A3\u03B5\u03C0\u03C4\u03AD\u03BC\u03B2\u03C1\u03B9\u03BF\u03C2", "\u039F\u03BA\u03C4\u03CE\u03B2\u03C1\u03B9\u03BF\u03C2", "\u039D\u03BF\u03AD\u03BC\u03B2\u03C1\u03B9\u03BF\u03C2", "\u0394\u03B5\u03BA\u03AD\u03BC\u03B2\u03C1\u03B9\u03BF\u03C2"], month_short: ["\u0399\u0391\u039D", "\u03A6\u0395\u0392", "\u039C\u0391\u03A1", "\u0391\u03A0\u03A1", "\u039C\u0391\u0399", "\u0399\u039F\u03A5\u039D", "\u0399\u039F\u03A5\u039B", "\u0391\u03A5\u0393", "\u03A3\u0395\u03A0", "\u039F\u039A\u03A4", "\u039D\u039F\u0395", "\u0394\u0395\u039A"], day_full: ["\u039A\u03C5\u03C1\u03B9\u03B1\u03BA\u03AE", "\u0394\u03B5\u03C5\u03C4\u03AD\u03C1\u03B1", "\u03A4\u03C1\u03AF\u03C4\u03B7", "\u03A4\u03B5\u03C4\u03AC\u03C1\u03C4\u03B7", "\u03A0\u03AD\u03BC\u03C0\u03C4\u03B7", "\u03A0\u03B1\u03C1\u03B1\u03C3\u03BA\u03B5\u03C5\u03AE", "\u039A\u03C5\u03C1\u03B9\u03B1\u03BA\u03AE"], day_short: ["\u039A\u03A5", "\u0394\u0395", "\u03A4\u03A1", "\u03A4\u0395", "\u03A0\u0395", "\u03A0\u0391", "\u03A3\u0391"] }, labels: { new_task: "\u039D\u03AD\u03B1 \u03B5\u03C1\u03B3\u03B1\u03C3\u03AF\u03B1", icon_save: "\u0391\u03C0\u03BF\u03B8\u03AE\u03BA\u03B5\u03C5\u03C3\u03B7", icon_cancel: "\u0386\u03BA\u03C5\u03C1\u03BF", icon_details: "\u039B\u03B5\u03C0\u03C4\u03BF\u03BC\u03AD\u03C1\u03B5\u03B9\u03B5\u03C2", icon_edit: "\u0395\u03C0\u03B5\u03BE\u03B5\u03C1\u03B3\u03B1\u03C3\u03AF\u03B1", icon_delete: "\u0394\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03AE", confirm_closing: "", confirm_deleting: "\u03A4\u03BF \u03AD\u03C1\u03B3\u03BF \u03B8\u03B1 \u03B4\u03B9\u03B1\u03B3\u03C1\u03B1\u03C6\u03B5\u03AF \u03BF\u03C1\u03B9\u03C3\u03C4\u03B9\u03BA\u03AC. \u0398\u03AD\u03BB\u03B5\u03C4\u03B5 \u03BD\u03B1 \u03C3\u03C5\u03BD\u03B5\u03C7\u03AF\u03C3\u03B5\u03C4\u03B5;", section_description: "\u03A0\u03B5\u03C1\u03B9\u03B3\u03C1\u03B1\u03C6\u03AE", section_time: "\u03A7\u03C1\u03BF\u03BD\u03B9\u03BA\u03AE \u03C0\u03B5\u03C1\u03AF\u03BF\u03B4\u03BF\u03C2", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "\u0386\u03BA\u03C5\u03C1\u03BF", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ni = { date: { month_full: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], month_short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], day_full: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], day_short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] }, labels: { new_task: "New task", icon_save: "Save", icon_cancel: "Cancel", icon_details: "Details", icon_edit: "Edit", icon_delete: "Delete", confirm_closing: "", confirm_deleting: "Task will be deleted permanently, are you sure?", section_description: "Description", section_time: "Time period", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Cancel", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Li = { date: { month_full: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], month_short: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"], day_full: ["Domingo", "Lunes", "Martes", "Mi\xE9rcoles", "Jueves", "Viernes", "S\xE1bado"], day_short: ["Dom", "Lun", "Mar", "Mi\xE9", "Jue", "Vie", "S\xE1b"] }, labels: { new_task: "Nueva tarea", icon_save: "Guardar", icon_cancel: "Cancelar", icon_details: "Detalles", icon_edit: "Editar", icon_delete: "Eliminar", confirm_closing: "", confirm_deleting: "El evento se borrar\xE1 definitivamente, \xBFcontinuar?", section_description: "Descripci\xF3n", section_time: "Per\xEDodo", section_type: "Tipo", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "EDT", column_text: "Tarea", column_start_date: "Inicio", column_duration: "Duraci\xF3n", column_add: "", link: "Enlace", confirm_link_deleting: "ser\xE1 borrada", link_start: " (inicio)", link_end: " (fin)", type_task: "Tarea", type_project: "Proyecto", type_milestone: "Hito", minutes: "Minutos", hours: "Horas", days: "D\xEDas", weeks: "Semanas", months: "Meses", years: "A\xF1os", message_ok: "OK", message_cancel: "Cancelar", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Pi = { date: { month_full: ["\u0698\u0627\u0646\u0648\u06CC\u0647", "\u0641\u0648\u0631\u06CC\u0647", "\u0645\u0627\u0631\u0633", "\u0622\u0648\u0631\u06CC\u0644", "\u0645\u0647", "\u0698\u0648\u0626\u0646", "\u0698\u0648\u0626\u06CC\u0647", "\u0627\u0648\u062A", "\u0633\u067E\u062A\u0627\u0645\u0628\u0631", "\u0627\u06A9\u062A\u0628\u0631", "\u0646\u0648\u0627\u0645\u0628\u0631", "\u062F\u0633\u0627\u0645\u0628\u0631"], month_short: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], day_full: ["\u064A\u06A9\u0634\u0646\u0628\u0647", "\u062F\u0648\u0634\u0646\u0628\u0647", "\u0633\u0647\u200C\u0634\u0646\u0628\u0647", "\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647", "\u067E\u0646\u062C\u0634\u0646\u0628\u0647", "\u062C\u0645\u0639\u0647", "\u0634\u0646\u0628\u0647"], day_short: ["\u06CC", "\u062F", "\u0633", "\u0686", "\u067E", "\u062C", "\u0634"] }, labels: { new_task: "\u0648\u0638\u06CC\u0641\u0647 \u062C\u062F\u06CC\u062F", icon_save: "\u0630\u062E\u06CC\u0631\u0647", icon_cancel: "\u0644\u063A\u0648", icon_details: "\u062C\u0632\u06CC\u06CC\u0627\u062A", icon_edit: "\u0648\u06CC\u0631\u0627\u06CC\u0634", icon_delete: "\u062D\u0630\u0641", confirm_closing: "\u062A\u063A\u06CC\u06CC\u0631\u0627\u062A \u0634\u0645\u0627 \u0627\u0632\u062F\u0633\u062A \u062E\u0648\u0627\u0647\u062F \u0631\u0641\u062A\u060C \u0622\u06CC\u0627 \u0645\u0637\u0645\u0626\u0646 \u0647\u0633\u062A\u06CC\u062F\u061F", confirm_deleting: "\u0627\u06CC\u0646 \u0645\u0648\u0631\u062F \u0628\u0631\u0627\u06CC \u0647\u0645\u06CC\u0634\u0647 \u062D\u0630\u0641 \u062E\u0648\u0627\u0647\u062F \u0634\u062F\u060C \u0622\u06CC\u0627 \u0645\u0637\u0645\u0626\u0646 \u0647\u0633\u062A\u06CC\u062F\u061F", section_description: "\u062A\u0648\u0636\u06CC\u062D\u0627\u062A", section_time: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646", section_type: "\u0646\u0648\u0639", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "\u0639\u0646\u0648\u0627\u0646", column_start_date: "\u0632\u0645\u0627\u0646 \u0634\u0631\u0648\u0639", column_duration: "\u0645\u062F\u062A", column_add: "", link: "\u0627\u0631\u062A\u0628\u0627\u0637", confirm_link_deleting: "\u062D\u0630\u0641 \u062E\u0648\u0627\u0647\u062F \u0634\u062F", link_start: " (\u0622\u063A\u0627\u0632)", link_end: " (\u067E\u0627\u06CC\u0627\u0646)", type_task: "\u0648\u0638\u06CC\u0641\u0647", type_project: "\u067E\u0631\u0648\u0698\u0647", type_milestone: "\u0646\u06AF\u0627\u0631\u0634", minutes: "\u062F\u0642\u0627\u06CC\u0642", hours: "\u0633\u0627\u0639\u0627\u062A", days: "\u0631\u0648\u0632\u0647\u0627", weeks: "\u0647\u0641\u062A\u0647", months: "\u0645\u0627\u0647\u200C\u0647\u0627", years: "\u0633\u0627\u0644\u200C\u0647\u0627", message_ok: "\u062A\u0627\u06CC\u06CC\u062F", message_cancel: "\u0644\u063A\u0648", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ri = { date: { month_full: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kes&auml;kuu", "Hein&auml;kuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"], month_short: ["Tam", "Hel", "Maa", "Huh", "Tou", "Kes", "Hei", "Elo", "Syy", "Lok", "Mar", "Jou"], day_full: ["Sunnuntai", "Maanantai", "Tiistai", "Keskiviikko", "Torstai", "Perjantai", "Lauantai"], day_short: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"] }, labels: { new_task: "Uusi teht\xE4v\xE4", icon_save: "Tallenna", icon_cancel: "Peru", icon_details: "Tiedot", icon_edit: "Muokkaa", icon_delete: "Poista", confirm_closing: "", confirm_deleting: "Haluatko varmasti poistaa tapahtuman?", section_description: "Kuvaus", section_time: "Aikajakso", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Peru", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Hi = { date: { month_full: ["Janvier", "F\xE9vrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Ao\xFBt", "Septembre", "Octobre", "Novembre", "D\xE9cembre"], month_short: ["Jan", "F\xE9v", "Mar", "Avr", "Mai", "Juin", "Juil", "Ao\xFB", "Sep", "Oct", "Nov", "D\xE9c"], day_full: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"], day_short: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"] }, labels: { new_task: "Nouvelle t\xE2che", icon_save: "Enregistrer", icon_cancel: "Annuler", icon_details: "D\xE9tails", icon_edit: "Modifier", icon_delete: "Effacer", confirm_closing: "", confirm_deleting: "L'\xE9v\xE9nement sera effac\xE9 sans appel, \xEAtes-vous s\xFBr ?", section_description: "Description", section_time: "P\xE9riode", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "OTP", column_text: "Nom de la t\xE2che", column_start_date: "Date initiale", column_duration: "Dur\xE9e", column_add: "", link: "Le lien", confirm_link_deleting: "sera supprim\xE9", link_start: "(d\xE9but)", link_end: "(fin)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Heures", days: "Jours", weeks: "Semaines", months: "Mois", years: "Ann\xE9es", message_ok: "OK", message_cancel: "Annuler", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Oi = { date: { month_full: ["\u05D9\u05E0\u05D5\u05D0\u05E8", "\u05E4\u05D1\u05E8\u05D5\u05D0\u05E8", "\u05DE\u05E8\u05E5", "\u05D0\u05E4\u05E8\u05D9\u05DC", "\u05DE\u05D0\u05D9", "\u05D9\u05D5\u05E0\u05D9", "\u05D9\u05D5\u05DC\u05D9", "\u05D0\u05D5\u05D2\u05D5\u05E1\u05D8", "\u05E1\u05E4\u05D8\u05DE\u05D1\u05E8", "\u05D0\u05D5\u05E7\u05D8\u05D5\u05D1\u05E8", "\u05E0\u05D5\u05D1\u05DE\u05D1\u05E8", "\u05D3\u05E6\u05DE\u05D1\u05E8"], month_short: ["\u05D9\u05E0\u05D5", "\u05E4\u05D1\u05E8", "\u05DE\u05E8\u05E5", "\u05D0\u05E4\u05E8", "\u05DE\u05D0\u05D9", "\u05D9\u05D5\u05E0", "\u05D9\u05D5\u05DC", "\u05D0\u05D5\u05D2", "\u05E1\u05E4\u05D8", "\u05D0\u05D5\u05E7", "\u05E0\u05D5\u05D1", "\u05D3\u05E6\u05DE"], day_full: ["\u05E8\u05D0\u05E9\u05D5\u05DF", "\u05E9\u05E0\u05D9", "\u05E9\u05DC\u05D9\u05E9\u05D9", "\u05E8\u05D1\u05D9\u05E2\u05D9", "\u05D7\u05DE\u05D9\u05E9\u05D9", "\u05E9\u05D9\u05E9\u05D9", "\u05E9\u05D1\u05EA"], day_short: ["\u05D0", "\u05D1", "\u05D2", "\u05D3", "\u05D4", "\u05D5", "\u05E9"] }, labels: { new_task: "\u05DE\u05E9\u05D9\u05DE\u05D4 \u05D7\u05D3\u05E9", icon_save: "\u05E9\u05DE\u05D5\u05E8", icon_cancel: "\u05D1\u05D8\u05DC", icon_details: "\u05E4\u05E8\u05D8\u05D9\u05DD", icon_edit: "\u05E2\u05E8\u05D5\u05DA", icon_delete: "\u05DE\u05D7\u05E7", confirm_closing: "", confirm_deleting: "\u05D0\u05E8\u05D5\u05E2 \u05D9\u05DE\u05D7\u05E7 \u05E1\u05D5\u05E4\u05D9\u05EA.\u05DC\u05D4\u05DE\u05E9\u05D9\u05DA?", section_description: "\u05D4\u05E1\u05D1\u05E8", section_time: "\u05EA\u05E7\u05D5\u05E4\u05D4", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "\u05D1\u05D8\u05DC", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Bi = { date: { month_full: ["Sije\u010Danj", "Velja\u010Da", "O\u017Eujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"], month_short: ["Sij", "Velj", "O\u017Eu", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"], day_full: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "\u010Cetvrtak", "Petak", "Subota"], day_short: ["Ned", "Pon", "Uto", "Sri", "\u010Cet", "Pet", "Sub"] }, labels: { new_task: "Novi Zadatak", icon_save: "Spremi", icon_cancel: "Odustani", icon_details: "Detalji", icon_edit: "Izmjeni", icon_delete: "Obri\u0161i", confirm_closing: "", confirm_deleting: "Zadatak \u0107e biti trajno izbrisan, jeste li sigurni?", section_description: "Opis", section_time: "Vremenski Period", section_type: "Tip", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Naziv Zadatka", column_start_date: "Po\u010Detno Vrijeme", column_duration: "Trajanje", column_add: "", link: "Poveznica", confirm_link_deleting: "\u0107e biti izbrisan", link_start: " (po\u010Detak)", link_end: " (kraj)", type_task: "Zadatak", type_project: "Projekt", type_milestone: "Milestone", minutes: "Minute", hours: "Sati", days: "Dani", weeks: "Tjedni", months: "Mjeseci", years: "Godine", message_ok: "OK", message_cancel: "Odustani", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, zi = { date: { month_full: ["Janu\xE1r", "Febru\xE1r", "M\xE1rcius", "\xC1prilis", "M\xE1jus", "J\xFAnius", "J\xFAlius", "Augusztus", "Szeptember", "Okt\xF3ber", "November", "December"], month_short: ["Jan", "Feb", "M\xE1r", "\xC1pr", "M\xE1j", "J\xFAn", "J\xFAl", "Aug", "Sep", "Okt", "Nov", "Dec"], day_full: ["Vas\xE1rnap", "H\xE9tf\xF5", "Kedd", "Szerda", "Cs\xFCt\xF6rt\xF6k", "P\xE9ntek", "szombat"], day_short: ["Va", "H\xE9", "Ke", "Sze", "Cs\xFC", "P\xE9", "Szo"] }, labels: { new_task: "\xDAj feladat", icon_save: "Ment\xE9s", icon_cancel: "M\xE9gse", icon_details: "R\xE9szletek", icon_edit: "Szerkeszt\xE9s", icon_delete: "T\xF6rl\xE9s", confirm_closing: "", confirm_deleting: "Az esem\xE9ny t\xF6r\xF6lve lesz, biztosan folytatja?", section_description: "Le\xEDr\xE1s", section_time: "Id\xF5szak", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "M\xE9gse", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Wi = { date: { month_full: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"], month_short: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Ags", "Sep", "Okt", "Nov", "Des"], day_full: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"], day_short: ["Ming", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"] }, labels: { new_task: "Tugas baru", icon_save: "Simpan", icon_cancel: "Batal", icon_details: "Detail", icon_edit: "Edit", icon_delete: "Hapus", confirm_closing: "", confirm_deleting: "Acara akan dihapus", section_description: "Keterangan", section_time: "Periode", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Batal", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, ji = { date: { month_full: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"], month_short: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"], day_full: ["Domenica", "Luned\xEC", "Marted\xEC", "Mercoled\xEC", "Gioved\xEC", "Venerd\xEC", "Sabato"], day_short: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"] }, labels: { new_task: "Nuovo compito", icon_save: "Salva", icon_cancel: "Chiudi", icon_details: "Dettagli", icon_edit: "Modifica", icon_delete: "Elimina", confirm_closing: "", confirm_deleting: "Sei sicuro di confermare l'eliminazione?", section_description: "Descrizione", section_time: "Periodo di tempo", section_type: "Tipo", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Nome Attivit\xE0", column_start_date: "Inizio", column_duration: "Durata", column_add: "", link: "Link", confirm_link_deleting: "sar\xE0 eliminato", link_start: " (inizio)", link_end: " (fine)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minuti", hours: "Ore", days: "Giorni", weeks: "Settimane", months: "Mesi", years: "Anni", message_ok: "OK", message_cancel: "Chiudi", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Fi = { date: { month_full: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], month_short: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], day_full: ["\u65E5\u66DC\u65E5", "\u6708\u66DC\u65E5", "\u706B\u66DC\u65E5", "\u6C34\u66DC\u65E5", "\u6728\u66DC\u65E5", "\u91D1\u66DC\u65E5", "\u571F\u66DC\u65E5"], day_short: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"] }, labels: { new_task: "\u65B0\u3057\u3044\u4ED5\u4E8B", icon_save: "\u4FDD\u5B58", icon_cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB", icon_details: "\u8A73\u7D30", icon_edit: "\u7DE8\u96C6", icon_delete: "\u524A\u9664", confirm_closing: "", confirm_deleting: "\u30A4\u30D9\u30F3\u30C8\u5B8C\u5168\u306B\u524A\u9664\u3055\u308C\u307E\u3059\u3001\u5B9C\u3057\u3044\u3067\u3059\u304B\uFF1F", section_description: "\u30C7\u30B9\u30AF\u30EA\u30D7\u30B7\u30E7\u30F3", section_time: "\u671F\u9593", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Vi = { date: { month_full: ["1\uC6D4", "2\uC6D4", "3\uC6D4", "4\uC6D4", "5\uC6D4", "6\uC6D4", "7\uC6D4", "8\uC6D4", "9\uC6D4", "10\uC6D4", "11\uC6D4", "12\uC6D4"], month_short: ["1\uC6D4", "2\uC6D4", "3\uC6D4", "4\uC6D4", "5\uC6D4", "6\uC6D4", "7\uC6D4", "8\uC6D4", "9\uC6D4", "10\uC6D4", "11\uC6D4", "12\uC6D4"], day_full: ["\uC77C\uC694\uC77C", "\uC6D4\uC694\uC77C", "\uD654\uC694\uC77C", "\uC218\uC694\uC77C", "\uBAA9\uC694\uC77C", "\uAE08\uC694\uC77C", "\uD1A0\uC694\uC77C"], day_short: ["\uC77C", "\uC6D4", "\uD654", "\uC218", "\uBAA9", "\uAE08", "\uD1A0"] }, labels: { new_task: "\uC774\uB984\uC5C6\uB294 \uC791\uC5C5", icon_save: "\uC800\uC7A5", icon_cancel: "\uCDE8\uC18C", icon_details: "\uC138\uBD80 \uC0AC\uD56D", icon_edit: "\uC218\uC815", icon_delete: "\uC0AD\uC81C", confirm_closing: "", confirm_deleting: "\uC791\uC5C5\uC744 \uC0AD\uC81C\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?", section_description: "\uC124\uBA85", section_time: "\uAE30\uAC04", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "\uC791\uC5C5\uBA85", column_start_date: "\uC2DC\uC791\uC77C", column_duration: "\uAE30\uAC04", column_add: "", link: "\uC804\uC81C", confirm_link_deleting: "\uC0AD\uC81C \uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?", link_start: " (start)", link_end: " (end)", type_task: "\uC791\uC5C5", type_project: "\uD504\uB85C\uC81D\uD2B8", type_milestone: "\uB9C8\uC77C\uC2A4\uD1A4", minutes: "\uBD84", hours: "\uC2DC\uAC04", days: "\uC77C", weeks: "\uC8FC", months: "\uB2EC", years: "\uB144", message_ok: "OK", message_cancel: "\uCDE8\uC18C", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } };
      class Ui {
        constructor(e) {
          this.addLocale = (n, i) => {
            this._locales[n] = i;
          }, this.getLocale = (n) => this._locales[n], this._locales = {};
          for (const n in e) this._locales[n] = e[n];
        }
      }
      const qi = { date: { month_full: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"], month_short: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"], day_full: ["S\xF8ndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "L\xF8rdag"], day_short: ["S\xF8n", "Mon", "Tir", "Ons", "Tor", "Fre", "L\xF8r"] }, labels: { new_task: "Ny oppgave", icon_save: "Lagre", icon_cancel: "Avbryt", icon_details: "Detaljer", icon_edit: "Rediger", icon_delete: "Slett", confirm_closing: "", confirm_deleting: "Hendelsen vil bli slettet permanent. Er du sikker?", section_description: "Beskrivelse", section_time: "Tidsperiode", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Avbryt", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Gi = { date: { month_full: ["Januari", "Februari", "Maart", "April", "Mei", "Juni", "Juli", "Augustus", "September", "Oktober", "November", "December"], month_short: ["Jan", "Feb", "mrt", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"], day_full: ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"], day_short: ["Zo", "Ma", "Di", "Wo", "Do", "Vr", "Za"] }, labels: { new_task: "Nieuwe taak", icon_save: "Opslaan", icon_cancel: "Annuleren", icon_details: "Details", icon_edit: "Bewerken", icon_delete: "Verwijderen", confirm_closing: "", confirm_deleting: "Item zal permanent worden verwijderd, doorgaan?", section_description: "Beschrijving", section_time: "Tijd periode", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Taak omschrijving", column_start_date: "Startdatum", column_duration: "Duur", column_add: "", link: "Koppeling", confirm_link_deleting: "zal worden verwijderd", link_start: " (start)", link_end: " (eind)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "minuten", hours: "uren", days: "dagen", weeks: "weken", months: "maanden", years: "jaren", message_ok: "OK", message_cancel: "Annuleren", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Yi = { date: { month_full: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"], month_short: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"], day_full: ["S\xF8ndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "L\xF8rdag"], day_short: ["S\xF8n", "Man", "Tir", "Ons", "Tor", "Fre", "L\xF8r"] }, labels: { new_task: "Ny oppgave", icon_save: "Lagre", icon_cancel: "Avbryt", icon_details: "Detaljer", icon_edit: "Endre", icon_delete: "Slett", confirm_closing: "Endringer blir ikke lagret, er du sikker?", confirm_deleting: "Oppf\xF8ringen vil bli slettet, er du sikker?", section_description: "Beskrivelse", section_time: "Tidsperiode", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Avbryt", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ji = { date: { month_full: ["Stycze\u0144", "Luty", "Marzec", "Kwiecie\u0144", "Maj", "Czerwiec", "Lipiec", "Sierpie\u0144", "Wrzesie\u0144", "Pa\u017Adziernik", "Listopad", "Grudzie\u0144"], month_short: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa\u017A", "Lis", "Gru"], day_full: ["Niedziela", "Poniedzia\u0142ek", "Wtorek", "\u015Aroda", "Czwartek", "Pi\u0105tek", "Sobota"], day_short: ["Nie", "Pon", "Wto", "\u015Aro", "Czw", "Pi\u0105", "Sob"] }, labels: { new_task: "Nowe zadanie", icon_save: "Zapisz", icon_cancel: "Anuluj", icon_details: "Szczeg\xF3\u0142y", icon_edit: "Edytuj", icon_delete: "Usu\u0144", confirm_closing: "", confirm_deleting: "Zdarzenie zostanie usuni\u0119te na zawsze, kontynuowa\u0107?", section_description: "Opis", section_time: "Okres czasu", section_type: "Typ", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Nazwa zadania", column_start_date: "Pocz\u0105tek", column_duration: "Czas trwania", column_add: "", link: "Link", confirm_link_deleting: "zostanie usuni\u0119ty", link_start: " (pocz\u0105tek)", link_end: " (koniec)", type_task: "Zadanie", type_project: "Projekt", type_milestone: "Milestone", minutes: "Minuty", hours: "Godziny", days: "Dni", weeks: "Tydzie\u0144", months: "Miesi\u0105ce", years: "Lata", message_ok: "OK", message_cancel: "Anuluj", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Ki = { date: { month_full: ["Janeiro", "Fevereiro", "Mar\xE7o", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], month_short: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"], day_full: ["Domingo", "Segunda", "Ter\xE7a", "Quarta", "Quinta", "Sexta", "S\xE1bado"], day_short: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"] }, labels: { new_task: "Nova tarefa", icon_save: "Salvar", icon_cancel: "Cancelar", icon_details: "Detalhes", icon_edit: "Editar", icon_delete: "Excluir", confirm_closing: "", confirm_deleting: "As tarefas ser\xE3o excluidas permanentemente, confirme?", section_description: "Descri\xE7\xE3o", section_time: "Per\xEDodo", section_type: "Tipo", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "EAP", column_text: "Nome tarefa", column_start_date: "Data in\xEDcio", column_duration: "Dura\xE7\xE3o", column_add: "", link: "Link", confirm_link_deleting: "Ser\xE1 exclu\xEDdo!", link_start: " (in\xEDcio)", link_end: " (fim)", type_task: "Task", type_project: "Projeto", type_milestone: "Marco", minutes: "Minutos", hours: "Horas", days: "Dias", weeks: "Semanas", months: "Meses", years: "Anos", message_ok: "OK", message_cancel: "Cancelar", section_constraint: "Restri\xE7\xE3o", constraint_type: "Tipo Restri\xE7\xE3o", constraint_date: "Data restri\xE7\xE3o", asap: "Mais breve poss\xEDvel", alap: "Mais tarde poss\xEDvel", snet: "N\xE3o come\xE7ar antes de", snlt: "N\xE3o come\xE7ar depois de", fnet: "N\xE3o terminar antes de", fnlt: "N\xE3o terminar depois de", mso: "Precisa come\xE7ar em", mfo: "Precisa terminar em", resources_filter_placeholder: "Tipo de filtros", resources_filter_label: "Ocultar vazios", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Xi = { date: { month_full: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "November", "December"], month_short: ["Ian", "Feb", "Mar", "Apr", "Mai", "Iun", "Iul", "Aug", "Sep", "Oct", "Nov", "Dec"], day_full: ["Duminica", "Luni", "Marti", "Miercuri", "Joi", "Vineri", "Sambata"], day_short: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sa"] }, labels: { new_task: "Sarcina noua", icon_save: "Salveaza", icon_cancel: "Anuleaza", icon_details: "Detalii", icon_edit: "Editeaza", icon_delete: "Sterge", confirm_closing: "Schimbarile nu vor fi salvate, esti sigur?", confirm_deleting: "Evenimentul va fi sters permanent, esti sigur?", section_description: "Descriere", section_time: "Interval", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Anuleaza", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Zi = { date: { month_full: ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440\u0435\u043B\u044C", "Ma\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433\u0443\u0441\u0442", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "O\u043A\u0442\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044C"], month_short: ["\u042F\u043D\u0432", "\u0424\u0435\u0432", "Ma\u0440", "A\u043F\u0440", "Ma\u0439", "\u0418\u044E\u043D", "\u0418\u044E\u043B", "A\u0432\u0433", "\u0421\u0435\u043D", "\u041E\u043A\u0442", "\u041D\u043E\u044F", "\u0414\u0435\u043A"], day_full: ["\u0412\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u041F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0412\u0442\u043E\u0440\u043D\u0438\u043A", "\u0421\u0440\u0435\u0434\u0430", "\u0427\u0435\u0442\u0432\u0435\u0440\u0433", "\u041F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0421\u0443\u0431\u0431\u043E\u0442\u0430"], day_short: ["\u0412\u0441", "\u041F\u043D", "\u0412\u0442", "\u0421\u0440", "\u0427\u0442", "\u041F\u0442", "\u0421\u0431"] }, labels: { new_task: "\u041D\u043E\u0432\u043E\u0435 \u0437\u0430\u0434\u0430\u043D\u0438\u0435", icon_save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C", icon_cancel: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C", icon_details: "\u0414\u0435\u0442\u0430\u043B\u0438", icon_edit: "\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C", icon_delete: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C", confirm_closing: "", confirm_deleting: "\u0421\u043E\u0431\u044B\u0442\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 \u0443\u0434\u0430\u043B\u0435\u043D\u043E \u0431\u0435\u0437\u0432\u043E\u0437\u0432\u0440\u0430\u0442\u043D\u043E, \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C?", section_description: "\u041E\u043F\u0438\u0441\u0430\u043D\u0438\u0435", section_time: "\u041F\u0435\u0440\u0438\u043E\u0434 \u0432\u0440\u0435\u043C\u0435\u043D\u0438", section_type: "\u0422\u0438\u043F", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "\u0418\u0421\u0420", column_text: "\u0417\u0430\u0434\u0430\u0447\u0430", column_start_date: "\u041D\u0430\u0447\u0430\u043B\u043E", column_duration: "\u0414\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C", column_add: "", link: "\u0421\u0432\u044F\u0437\u044C", confirm_link_deleting: "\u0431\u0443\u0434\u0435\u0442 \u0443\u0434\u0430\u043B\u0435\u043D\u0430", link_start: " (\u043D\u0430\u0447\u0430\u043B\u043E)", link_end: " (\u043A\u043E\u043D\u0435\u0446)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "\u041C\u0438\u043D\u0443\u0442\u0430", hours: "\u0427\u0430\u0441", days: "\u0414\u0435\u043D\u044C", weeks: "\u041D\u0435\u0434\u0435\u043B\u044F", months: "\u041C\u0435\u0441\u044F\u0446", years: "\u0413\u043E\u0434", message_ok: "OK", message_cancel: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "\u043D\u0430\u0447\u043D\u0438\u0442\u0435 \u0432\u0432\u043E\u0434\u0438\u0442\u044C \u0441\u043B\u043E\u0432\u043E \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u0442\u0440\u0430\u0446\u0438\u0438", resources_filter_label: "\u0441\u043F\u0440\u044F\u0442\u0430\u0442\u044C \u043D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u043D\u044B\u0435", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, Qi = { date: { month_full: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"], month_short: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"], day_full: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "\u010Cetrtek", "Petek", "Sobota"], day_short: ["Ned", "Pon", "Tor", "Sre", "\u010Cet", "Pet", "Sob"] }, labels: { new_task: "Nova naloga", icon_save: "Shrani", icon_cancel: "Prekli\u010Di", icon_details: "Podrobnosti", icon_edit: "Uredi", icon_delete: "Izbri\u0161i", confirm_closing: "", confirm_deleting: "Dogodek bo izbrisan. \u017Delite nadaljevati?", section_description: "Opis", section_time: "\u010Casovni okvir", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Prekli\u010Di", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, ta = { date: { month_full: ["Janu\xE1r", "Febru\xE1r", "Marec", "Apr\xEDl", "M\xE1j", "J\xFAn", "J\xFAl", "August", "September", "Okt\xF3ber", "November", "December"], month_short: ["Jan", "Feb", "Mar", "Apr", "M\xE1j", "J\xFAn", "J\xFAl", "Aug", "Sept", "Okt", "Nov", "Dec"], day_full: ["Nede\u013Ea", "Pondelok", "Utorok", "Streda", "\u0160tvrtok", "Piatok", "Sobota"], day_short: ["Ne", "Po", "Ut", "St", "\u0160t", "Pi", "So"] }, labels: { new_task: "Nov\xE1 \xFAloha", icon_save: "Ulo\u017Ei\u0165", icon_cancel: "Sp\xE4\u0165", icon_details: "Detail", icon_edit: "Edituj", icon_delete: "Zmaza\u0165", confirm_closing: "Va\u0161e zmeny nebud\xFA ulo\u017Een\xE9. Skuto\u010Dne?", confirm_deleting: "Udalos\u0165 bude natrvalo vymazan\xE1. Skuto\u010Dne?", section_description: "Pozn\xE1mky", section_time: "Doba platnosti", section_type: "Type", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "Sp\xE4\u0165", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, ea = { date: { month_full: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"], month_short: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"], day_full: ["S\xF6ndag", "M\xE5ndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "L\xF6rdag"], day_short: ["S\xF6n", "M\xE5n", "Tis", "Ons", "Tor", "Fre", "L\xF6r"] }, labels: { new_task: "Ny uppgift", icon_save: "Spara", icon_cancel: "Avbryt", icon_details: "Detajer", icon_edit: "\xC4ndra", icon_delete: "Ta bort", confirm_closing: "", confirm_deleting: "\xC4r du s\xE4ker p\xE5 att du vill ta bort h\xE4ndelsen permanent?", section_description: "Beskrivning", section_time: "Tid", section_type: "Typ", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Uppgiftsnamn", column_start_date: "Starttid", column_duration: "Varaktighet", column_add: "", link: "L\xE4nk", confirm_link_deleting: "kommer tas bort", link_start: " (start)", link_end: " (slut)", type_task: "Uppgift", type_project: "Projekt", type_milestone: "Milstolpe", minutes: "Minuter", hours: "Timmar", days: "Dagar", weeks: "Veckor", months: "M\xE5nader", years: "\xC5r", message_ok: "OK", message_cancel: "Avbryt", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, na = { date: { month_full: ["Ocak", "\u015Eubat", "Mart", "Nisan", "May\u0131s", "Haziran", "Temmuz", "A\u011Fustos", "Eyl\xFCl", "Ekim", "Kas\u0131m", "Aral\u0131k"], month_short: ["Oca", "\u015Eub", "Mar", "Nis", "May", "Haz", "Tem", "A\u011Fu", "Eyl", "Eki", "Kas", "Ara"], day_full: ["Pazar", "Pazartesi", "Sal\u0131", "\xC7ar\u015Famba", "Per\u015Fembe", "Cuma", "Cumartesi"], day_short: ["Paz", "Pzt", "Sal", "\xC7ar", "Per", "Cum", "Cmt"] }, labels: { new_task: "Yeni g\xF6rev", icon_save: "Kaydet", icon_cancel: "\u0130ptal", icon_details: "Detaylar", icon_edit: "D\xFCzenle", icon_delete: "Sil", confirm_closing: "", confirm_deleting: "G\xF6rev silinecek, emin misiniz?", section_description: "A\xE7\u0131klama", section_time: "Zaman Aral\u0131\u011F\u0131", section_type: "Tip", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "G\xF6rev Ad\u0131", column_start_date: "Ba\u015Flang\u0131\xE7", column_duration: "S\xFCre", column_add: "", link: "Ba\u011Flant\u0131", confirm_link_deleting: "silinecek", link_start: " (ba\u015Flang\u0131\xE7)", link_end: " (biti\u015F)", type_task: "G\xF6rev", type_project: "Proje", type_milestone: "Kilometreta\u015F\u0131", minutes: "Dakika", hours: "Saat", days: "G\xFCn", weeks: "Hafta", months: "Ay", years: "Y\u0131l", message_ok: "OK", message_cancel: "\xDDptal", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } }, ia = { date: { month_full: ["\u0421\u0456\u0447\u0435\u043D\u044C", "\u041B\u044E\u0442\u0438\u0439", "\u0411\u0435\u0440\u0435\u0437\u0435\u043D\u044C", "\u041A\u0432\u0456\u0442\u0435\u043D\u044C", "\u0422\u0440\u0430\u0432\u0435\u043D\u044C", "\u0427\u0435\u0440\u0432\u0435\u043D\u044C", "\u041B\u0438\u043F\u0435\u043D\u044C", "\u0421\u0435\u0440\u043F\u0435\u043D\u044C", "\u0412\u0435\u0440\u0435\u0441\u0435\u043D\u044C", "\u0416\u043E\u0432\u0442\u0435\u043D\u044C", "\u041B\u0438\u0441\u0442\u043E\u043F\u0430\u0434", "\u0413\u0440\u0443\u0434\u0435\u043D\u044C"], month_short: ["\u0421\u0456\u0447", "\u041B\u044E\u0442", "\u0411\u0435\u0440", "\u041A\u0432\u0456", "\u0422\u0440\u0430", "\u0427\u0435\u0440", "\u041B\u0438\u043F", "\u0421\u0435\u0440", "\u0412\u0435\u0440", "\u0416\u043E\u0432", "\u041B\u0438\u0441", "\u0413\u0440\u0443"], day_full: ["\u041D\u0435\u0434\u0456\u043B\u044F", "\u041F\u043E\u043D\u0435\u0434\u0456\u043B\u043E\u043A", "\u0412\u0456\u0432\u0442\u043E\u0440\u043E\u043A", "\u0421\u0435\u0440\u0435\u0434\u0430", "\u0427\u0435\u0442\u0432\u0435\u0440", "\u041F'\u044F\u0442\u043D\u0438\u0446\u044F", "\u0421\u0443\u0431\u043E\u0442\u0430"], day_short: ["\u041D\u0435\u0434", "\u041F\u043E\u043D", "\u0412\u0456\u0432", "\u0421\u0435\u0440", "\u0427\u0435\u0442", "\u041F\u0442\u043D", "\u0421\u0443\u0431"] }, labels: { new_task: "\u041D\u043E\u0432\u0435 \u0437\u0430\u0432\u0434\u0430\u043D\u043D\u044F", icon_save: "\u0417\u0431\u0435\u0440\u0435\u0433\u0442\u0438", icon_cancel: "\u0412\u0456\u0434\u043C\u0456\u043D\u0430", icon_details: "\u0414\u0435\u0442\u0430\u043B\u0456", icon_edit: "\u0420\u0435\u0434\u0430\u0433\u0443\u0432\u0430\u0442\u0438", icon_delete: "\u0412\u0438\u043B\u0443\u0447\u0438\u0442\u0438", confirm_closing: "", confirm_deleting: "\u041F\u043E\u0434\u0456\u044F \u0432\u0438\u043B\u0443\u0447\u0438\u0442\u044C\u0441\u044F \u043D\u0430\u0437\u0430\u0432\u0436\u0434\u0438. \u0412\u0438 \u0432\u043F\u0435\u0432\u043D\u0435\u043D\u0456?", section_description: "\u041E\u043F\u0438\u0441", section_time: "\u0427\u0430\u0441\u043E\u0432\u0438\u0439 \u043F\u0440\u043E\u043C\u0456\u0436\u043E\u043A", section_type: "\u0422\u0438\u043F", section_deadline: "Deadline", section_baselines: "Baselines", column_wbs: "WBS", column_text: "Task name", column_start_date: "Start time", column_duration: "Duration", column_add: "", link: "Link", confirm_link_deleting: "will be deleted", link_start: " (start)", link_end: " (end)", type_task: "Task", type_project: "Project", type_milestone: "Milestone", minutes: "Minutes", hours: "Hours", days: "Days", weeks: "Week", months: "Months", years: "Years", message_ok: "OK", message_cancel: "\u0412\u0456\u0434\u043C\u0456\u043D\u0430", section_constraint: "Constraint", constraint_type: "Constraint type", constraint_date: "Constraint date", asap: "As Soon As Possible", alap: "As Late As Possible", snet: "Start No Earlier Than", snlt: "Start No Later Than", fnet: "Finish No Earlier Than", fnlt: "Finish No Later Than", mso: "Must Start On", mfo: "Must Finish On", resources_filter_placeholder: "type to filter", resources_filter_label: "hide empty", empty_state_text_link: "Click here", empty_state_text_description: "to create your first task", baselines_section_placeholder: "Start adding a new baseline", baselines_add_button: "Add Baseline", baselines_remove_button: "Remove", baselines_remove_all_button: "Remove All", deadline_enable_button: "Set", deadline_disable_button: "Remove" } };
      function aa() {
        this.constants = Fn, this.version = "9.0.4", this.license = "gpl", this.templates = {}, this.ext = {}, this.keys = { edit_save: this.constants.KEY_CODES.ENTER, edit_cancel: this.constants.KEY_CODES.ESC };
      }
      function ra(t) {
        var e = new aa(), n = new Vn(t), i = {};
        e.plugins = function(l) {
          for (var d in l) if (l[d] && !i[d]) {
            var c = n.getExtension(d);
            c && (c(e), i[d] = true);
          }
          return i;
        }, e.$services = /* @__PURE__ */ function() {
          var l = {};
          return { services: {}, setService: function(d, c) {
            l[d] = c;
          }, getService: function(d) {
            return l[d] ? l[d]() : null;
          }, dropService: function(d) {
            l[d] && delete l[d];
          }, destructor: function() {
            for (var d in l) if (l[d]) {
              var c = l[d];
              c && c.destructor && c.destructor();
            }
            l = null;
          } };
        }(), e.config = Un(), e.ajax = /* @__PURE__ */ function(l) {
          return { cache: true, method: "get", parse: function(d) {
            return typeof d != "string" ? d : (d = d.replace(/^[\s]+/, ""), typeof DOMParser > "u" || ht.isIE ? lt.ActiveXObject !== void 0 && ((c = new lt.ActiveXObject("Microsoft.XMLDOM")).async = "false", c.loadXML(d)) : c = new DOMParser().parseFromString(d, "text/xml"), c);
            var c;
          }, xmltop: function(d, c, u) {
            if (c.status === void 0 || c.status < 400) {
              var h = c.responseXML ? c.responseXML || c : this.parse(c.responseText || c);
              if (h && h.documentElement !== null && !h.getElementsByTagName("parsererror").length) return h.getElementsByTagName(d)[0];
            }
            return u !== -1 && l.callEvent("onLoadXMLError", ["Incorrect XML", arguments[1], u]), document.createElement("DIV");
          }, xpath: function(d, c) {
            if (c.nodeName || (c = c.responseXML || c), ht.isIE) return c.selectNodes(d) || [];
            for (var u, h = [], g = (c.ownerDocument || c).evaluate(d, c, null, XPathResult.ANY_TYPE, null); u = g.iterateNext(); ) h.push(u);
            return h;
          }, query: function(d) {
            return this._call(d.method || "GET", d.url, d.data || "", d.async || true, d.callback, d.headers);
          }, get: function(d, c, u) {
            var h = $t("GET", arguments);
            return this.query(h);
          }, getSync: function(d, c) {
            var u = $t("GET", arguments);
            return u.async = false, this.query(u);
          }, put: function(d, c, u, h) {
            var g = $t("PUT", arguments);
            return this.query(g);
          }, del: function(d, c, u) {
            var h = $t("DELETE", arguments);
            return this.query(h);
          }, post: function(d, c, u, h) {
            arguments.length == 1 ? c = "" : arguments.length == 2 && typeof c == "function" && (u = c, c = "");
            var g = $t("POST", arguments);
            return this.query(g);
          }, postSync: function(d, c, u) {
            c = c === null ? "" : String(c);
            var h = $t("POST", arguments);
            return h.async = false, this.query(h);
          }, _call: function(d, c, u, h, g, f) {
            return new l.Promise(function(y, v) {
              var b = typeof XMLHttpRequest !== void 0 ? new XMLHttpRequest() : new lt.ActiveXObject("Microsoft.XMLHTTP"), _ = navigator.userAgent.match(/AppleWebKit/) !== null && navigator.userAgent.match(/Qt/) !== null && navigator.userAgent.match(/Safari/) !== null;
              h && (b.onreadystatechange = function() {
                if (b.readyState == 4 || _ && b.readyState == 3) {
                  if ((b.status != 200 || b.responseText === "") && !l.callEvent("onAjaxError", [b])) return;
                  setTimeout(function() {
                    typeof g == "function" && g.apply(lt, [{ xmlDoc: b, filePath: c }]), y(b), typeof g == "function" && (g = null, b = null);
                  }, 0);
                }
              });
              var m = !this || !this.cache;
              if (d == "GET" && m && (c += (c.indexOf("?") >= 0 ? "&" : "?") + "dhxr" + (/* @__PURE__ */ new Date()).getTime() + "=1"), b.open(d, c, h), f) for (var p in f) b.setRequestHeader(p, f[p]);
              else d.toUpperCase() == "POST" || d == "PUT" || d == "DELETE" ? b.setRequestHeader("Content-Type", "application/x-www-form-urlencoded") : d == "GET" && (u = null);
              if (b.setRequestHeader("X-Requested-With", "XMLHttpRequest"), b.send(u), !h) return { xmlDoc: b, filePath: c };
            });
          }, urlSeparator: function(d) {
            return d.indexOf("?") != -1 ? "&" : "?";
          } };
        }(e), e.date = qn(e), e.RemoteEvents = Yn;
        var a = function(l) {
          function d(u) {
            return { target: u.target || u.srcElement, pageX: u.pageX, pageY: u.pageY, clientX: u.clientX, clientY: u.clientY, metaKey: u.metaKey, shiftKey: u.shiftKey, ctrlKey: u.ctrlKey, altKey: u.altKey };
          }
          function c(u, h) {
            this._obj = u, this._settings = h || {}, nt(this);
            var g = this.getInputMethods();
            this._drag_start_timer = null, l.attachEvent("onGanttScroll", R(function(v, b) {
              this.clearDragTimer();
            }, this));
            for (var f = { passive: false }, y = 0; y < g.length; y++) R(function(v) {
              l.event(u, v.down, R(function(_) {
                v.accessor(_) && (_.button !== void 0 && _.button !== 0 || (h.preventDefault && h.selector && ot(_.target, h.selector) && _.preventDefault(), l.config.touch && _.timeStamp && _.timeStamp - 0 < 300 || (this._settings.original_target = d(_), this._settings.original_element_sizes = { ...et(_, Ie(u)), width: _.target.offsetWidth, height: _.target.offsetHeight }, l.config.touch ? (this.clearDragTimer(), this._drag_start_timer = setTimeout(R(function() {
                  l.getState().lightbox || this.dragStart(u, _, v);
                }, this), l.config.touch_drag)) : this.dragStart(u, _, v))));
              }, this), f);
              var b = document.body;
              l.event(b, v.up, R(function(_) {
                v.accessor(_) && this.clearDragTimer();
              }, this), f);
            }, this)(g[y]);
          }
          return c.prototype = { traceDragEvents: function(u, h) {
            var g = R(function(m) {
              return this.dragMove(u, m, h.accessor);
            }, this);
            R(function(m) {
              return this.dragScroll(u, m);
            }, this);
            var f = R(function(m) {
              if (!this.config.started || !j(this.config.updates_per_second) || Ue(this, this.config.updates_per_second)) {
                var p = g(m);
                if (p) try {
                  m && m.preventDefault && m.cancelable && m.preventDefault();
                } catch {
                }
                return p;
              }
            }, this), y = vt(l.$root), v = this.config.mousemoveContainer || vt(l.$root), b = { passive: false }, _ = R(function(m) {
              return l.eventRemove(v, h.move, f), l.eventRemove(y, h.up, _, b), this.dragEnd(u);
            }, this);
            l.event(v, h.move, f, b), l.event(y, h.up, _, b);
          }, checkPositionChange: function(u) {
            var h = u.x - this.config.pos.x, g = u.y - this.config.pos.y;
            return Math.sqrt(Math.pow(Math.abs(h), 2) + Math.pow(Math.abs(g), 2)) > this.config.sensitivity;
          }, initDnDMarker: function() {
            var u = this.config.marker = document.createElement("div");
            u.className = "gantt_drag_marker", u.innerHTML = "", document.body.appendChild(u);
          }, backupEventTarget: function(u, h) {
            if (l.config.touch) {
              var g = h(u), f = g.target || g.srcElement, y = f.cloneNode(true);
              this.config.original_target = d(g), this.config.original_target.target = y, this.config.backup_element = f, f.parentNode.appendChild(y), f.style.display = "none", (this.config.mousemoveContainer || document.body).appendChild(f);
            }
          }, getInputMethods: function() {
            var u = [];
            if (u.push({ move: "mousemove", down: "mousedown", up: "mouseup", accessor: function(g) {
              return g;
            } }), l.config.touch) {
              var h = true;
              try {
                document.createEvent("TouchEvent");
              } catch {
                h = false;
              }
              h ? u.push({ move: "touchmove", down: "touchstart", up: "touchend", accessor: function(g) {
                return g.touches && g.touches.length > 1 ? null : g.touches[0] ? { target: document.elementFromPoint(g.touches[0].clientX, g.touches[0].clientY), pageX: g.touches[0].pageX, pageY: g.touches[0].pageY, clientX: g.touches[0].clientX, clientY: g.touches[0].clientY } : g;
              } }) : lt.navigator.pointerEnabled ? u.push({ move: "pointermove", down: "pointerdown", up: "pointerup", accessor: function(g) {
                return g.pointerType == "mouse" ? null : g;
              } }) : lt.navigator.msPointerEnabled && u.push({ move: "MSPointerMove", down: "MSPointerDown", up: "MSPointerUp", accessor: function(g) {
                return g.pointerType == g.MSPOINTER_TYPE_MOUSE ? null : g;
              } });
            }
            return u;
          }, clearDragTimer: function() {
            this._drag_start_timer && (clearTimeout(this._drag_start_timer), this._drag_start_timer = null);
          }, dragStart: function(u, h, g) {
            this.config && this.config.started || (this.config = { obj: u, marker: null, started: false, pos: this.getPosition(h), sensitivity: 4 }, this._settings && N(this.config, this._settings, true), this.traceDragEvents(u, g), l._prevent_touch_scroll = true, document.body.classList.add("gantt_noselect"), l.config.touch && this.dragMove(u, h, g.accessor));
          }, dragMove: function(u, h, g) {
            var f = g(h);
            if (!f) return false;
            if (!this.config.marker && !this.config.started) {
              var y = this.getPosition(f);
              if (l.config.touch || this.checkPositionChange(y)) {
                if (this.config.started = true, this.config.ignore = false, l._touch_drag = true, this.callEvent("onBeforeDragStart", [u, this.config.original_target]) === false) return this.config.ignore = true, false;
                this.backupEventTarget(h, g), this.initDnDMarker(), l._touch_feedback(), this.callEvent("onAfterDragStart", [u, this.config.original_target]);
              } else this.config.ignore = true;
            }
            return this.config.ignore ? false : h.targetTouches && !f.target ? void 0 : (f.pos = this.getPosition(f), this.config.marker.style.left = f.pos.x + "px", this.config.marker.style.top = f.pos.y + "px", this.callEvent("onDragMove", [u, f]), true);
          }, dragEnd: function(u) {
            var h = this.config.backup_element;
            h && h.parentNode && h.parentNode.removeChild(h), l._prevent_touch_scroll = false, this.config.marker && (this.config.marker.parentNode.removeChild(this.config.marker), this.config.marker = null, this.callEvent("onDragEnd", [])), this.config.started = false, l._touch_drag = false, document.body.classList.remove("gantt_noselect");
          }, getPosition: function(u) {
            var h = 0, g = 0;
            return u.pageX || u.pageY ? (h = u.pageX, g = u.pageY) : (u.clientX || u.clientY) && (h = u.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, g = u.clientY + document.body.scrollTop + document.documentElement.scrollTop), { x: h, y: g };
          } }, c;
        }(e);
        e.$services.setService("dnd", function() {
          return a;
        });
        var r = /* @__PURE__ */ function(l) {
          var d = {};
          function c(u, h, g) {
            g = g || u;
            var f = l.config, y = l.templates;
            l.config[u] && d[g] != f[u] && (h && y[g] || (y[g] = l.date.date_to_str(f[u]), d[g] = f[u]));
          }
          return { initTemplates: function() {
            var u = l.locale.labels;
            u.gantt_save_btn = u.icon_save, u.gantt_cancel_btn = u.icon_cancel, u.gantt_delete_btn = u.icon_delete;
            var h = l.date, g = h.date_to_str, f = l.config, y = g(f.xml_date || f.date_format, f.server_utc), v = h.str_to_date(f.xml_date || f.date_format, f.server_utc);
            c("date_scale", true, void 0, l.config, l.templates), c("date_grid", true, "grid_date_format", l.config, l.templates), c("task_date", true, void 0, l.config, l.templates), l.mixin(l.templates, { xml_format: void 0, format_date: y, xml_date: void 0, parse_date: v, progress_text: function(b, _, m) {
              return "";
            }, grid_header_class: function(b, _) {
              return "";
            }, task_text: function(b, _, m) {
              return m.text;
            }, task_class: function(b, _, m) {
              return "";
            }, task_end_date: function(b) {
              return l.templates.task_date(b);
            }, grid_row_class: function(b, _, m) {
              return "";
            }, task_row_class: function(b, _, m) {
              return "";
            }, timeline_cell_class: function(b, _) {
              return "";
            }, timeline_cell_content: function(b, _) {
              return "";
            }, scale_cell_class: function(b) {
              return "";
            }, scale_row_class: function(b) {
              return "";
            }, grid_indent: function(b) {
              return "<div class='gantt_tree_indent'></div>";
            }, grid_folder: function(b) {
              return "<div class='gantt_tree_icon gantt_folder_" + (b.$open ? "open" : "closed") + "'></div>";
            }, grid_file: function(b) {
              return "<div class='gantt_tree_icon gantt_file'></div>";
            }, grid_open: function(b) {
              return "<div class='gantt_tree_icon gantt_" + (b.$open ? "close" : "open") + "'></div>";
            }, grid_blank: function(b) {
              return "<div class='gantt_tree_icon gantt_blank'></div>";
            }, date_grid: function(b, _, m) {
              return _ && l.isUnscheduledTask(_) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(_) : l.templates.grid_date_format(b, m);
            }, task_time: function(b, _, m) {
              return l.isUnscheduledTask(m) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(m) : l.templates.task_date(b) + " - " + l.templates.task_end_date(_);
            }, task_unscheduled_time: function(b) {
              return "";
            }, time_picker: g(f.time_picker), link_class: function(b) {
              return "";
            }, link_description: function(b) {
              var _ = l.getTask(b.source), m = l.getTask(b.target);
              return "<b>" + _.text + "</b> &ndash;  <b>" + m.text + "</b>";
            }, drag_link: function(b, _, m, p) {
              b = l.getTask(b);
              var k = l.locale.labels, $ = "<b>" + b.text + "</b> " + (_ ? k.link_start : k.link_end) + "<br/>";
              return m && ($ += "<b> " + (m = l.getTask(m)).text + "</b> " + (p ? k.link_start : k.link_end) + "<br/>"), $;
            }, drag_link_class: function(b, _, m, p) {
              var k = "";
              return b && m && (k = " " + (l.isLinkAllowed(b, m, _, p) ? "gantt_link_allow" : "gantt_link_deny")), "gantt_link_tooltip" + k;
            }, tooltip_date_format: h.date_to_str("%Y-%m-%d"), tooltip_text: function(b, _, m) {
              return `<div>Task: ${m.text}</div>
				<div>Start date: ${l.templates.tooltip_date_format(b)}</div>
				<div>End date: ${l.templates.tooltip_date_format(_)}</div>`;
            }, baseline_text: function(b, _, m) {
              return "";
            } });
          }, initTemplate: c };
        }(e);
        e.$services.setService("templateLoader", function() {
          return r;
        }), nt(e);
        var s = new Jn();
        s.registerProvider("global", function() {
          var l = { min_date: e._min_date, max_date: e._max_date, selected_task: null };
          return e.$data && e.$data.tasksStore && (l.selected_task = e.$data.tasksStore.getSelectedId()), l;
        }), e.getState = s.getState, e.$services.setService("state", function() {
          return s;
        }), N(e, Hn), e.Promise = Kn, e.env = ht, function(l) {
          var d = Zn.create();
          N(l, d);
          var c, u = l.createDatastore({ name: "task", type: "treeDatastore", rootId: function() {
            return l.config.root_id;
          }, initItem: R(function(_) {
            this.defined(_.id) || (_.id = this.uid()), _.start_date && (_.start_date = l.date.parseDate(_.start_date, "parse_date")), _.end_date && (_.end_date = l.date.parseDate(_.end_date, "parse_date"));
            var m = null;
            (_.duration || _.duration === 0) && (_.duration = m = 1 * _.duration), m && (_.start_date && !_.end_date ? _.end_date = this.calculateEndDate(_) : !_.start_date && _.end_date && (_.start_date = this.calculateEndDate({ start_date: _.end_date, duration: -_.duration, task: _ }))), l.config.deadlines !== false && _.deadline && (_.deadline = l.date.parseDate(_.deadline, "parse_date")), _.progress = Number(_.progress) || 0, this._isAllowedUnscheduledTask(_) && this._set_default_task_timing(_), this._init_task_timing(_), _.start_date && _.end_date && this.correctTaskWorkTime(_), _.$source = [], _.$target = [];
            var p = this.$data.tasksStore.getItem(_.id);
            return p && !j(_.open) && (_.$open = p.$open), _.parent === void 0 && (_.parent = this.config.root_id), _.open && (_.$open = true), _;
          }, l), getConfig: function() {
            return l.config;
          } }), h = l.createDatastore({ name: "link", initItem: R(function(_) {
            return this.defined(_.id) || (_.id = this.uid()), _;
          }, l) });
          function g(_) {
            var m = l.isTaskVisible(_);
            if (!m && l.isTaskExists(_)) {
              var p = l.getParent(_);
              l.isTaskExists(p) && l.isTaskVisible(p) && (p = l.getTask(p), l.isSplitTask(p) && (m = true));
            }
            return m;
          }
          function f(_) {
            if (l.isTaskExists(_.source)) {
              var m = l.getTask(_.source);
              m.$source = m.$source || [], m.$source.push(_.id);
            }
            if (l.isTaskExists(_.target)) {
              var p = l.getTask(_.target);
              p.$target = p.$target || [], p.$target.push(_.id);
            }
          }
          function y(_) {
            if (l.isTaskExists(_.source)) {
              for (var m = l.getTask(_.source), p = 0; p < m.$source.length; p++) if (m.$source[p] == _.id) {
                m.$source.splice(p, 1);
                break;
              }
            }
            if (l.isTaskExists(_.target)) {
              var k = l.getTask(_.target);
              for (p = 0; p < k.$target.length; p++) if (k.$target[p] == _.id) {
                k.$target.splice(p, 1);
                break;
              }
            }
          }
          function v() {
            for (var _ = null, m = l.$data.tasksStore.getItems(), p = 0, k = m.length; p < k; p++) (_ = m[p]).$source = [], _.$target = [];
            var $ = l.$data.linksStore.getItems();
            for (p = 0, k = $.length; p < k; p++) f($[p]);
          }
          function b(_) {
            var m = _.source, p = _.target;
            for (var k in _.events) (function($, w) {
              m.attachEvent($, function() {
                return p.callEvent(w, Array.prototype.slice.call(arguments));
              }, w);
            })(k, _.events[k]);
          }
          l.attachEvent("onDestroy", function() {
            u.destructor(), h.destructor();
          }), l.attachEvent("onLinkValidation", function(_) {
            if (l.isLinkExists(_.id) || _.id === "predecessor_generated") return true;
            for (var m = l.getTask(_.source).$source, p = 0; p < m.length; p++) {
              var k = l.getLink(m[p]), $ = _.source == k.source, w = _.target == k.target, x = _.type == k.type;
              if ($ && w && x) return false;
            }
            return true;
          }), u.attachEvent("onBeforeRefreshAll", function() {
            if (!u._skipTaskRecalculation) for (var _ = u.getVisibleItems(), m = 0; m < _.length; m++) {
              var p = _[m];
              p.$index = m, p.$local_index = l.getTaskIndex(p.id), l.resetProjectDates(p);
            }
          }), u.attachEvent("onFilterItem", function(_, m) {
            if (l.config.show_tasks_outside_timescale) return true;
            var p = null, k = null;
            if (l.config.start_date && l.config.end_date) {
              if (l._isAllowedUnscheduledTask(m)) return true;
              if (p = l.config.start_date.valueOf(), k = l.config.end_date.valueOf(), +m.start_date > k || +m.end_date < +p) return false;
            }
            return true;
          }), u.attachEvent("onIdChange", function(_, m) {
            l._update_flags(_, m);
            var p = l.getTask(m);
            u.isSilent() || (p.$split_subtask || p.rollup) && l.eachParent(function(k) {
              l.refreshTask(k.id);
            }, m);
          }), u.attachEvent("onAfterUpdate", function(_) {
            if (l._update_parents(_), l.getState("batchUpdate").batch_update) return true;
            var m = u.getItem(_);
            m.$source || (m.$source = []);
            for (var p = 0; p < m.$source.length; p++) h.refresh(m.$source[p]);
            for (m.$target || (m.$target = []), p = 0; p < m.$target.length; p++) h.refresh(m.$target[p]);
          }), u.attachEvent("onBeforeItemMove", function(_, m, p) {
            return !Et(_, l, u) || (console.log("The placeholder task cannot be moved to another position."), false);
          }), u.attachEvent("onAfterItemMove", function(_, m, p) {
            var k = l.getTask(_);
            this.getNextSibling(_) !== null ? k.$drop_target = this.getNextSibling(_) : this.getPrevSibling(_) !== null ? k.$drop_target = "next:" + this.getPrevSibling(_) : k.$drop_target = "next:null";
          }), u.attachEvent("onStoreUpdated", function(_, m, p) {
            if (p == "delete" && l._update_flags(_, null), !l.$services.getService("state").getState("batchUpdate").batch_update) {
              if (l.config.fit_tasks && p !== "paint") {
                var k = l.getState();
                de(l);
                var $ = l.getState();
                if (+k.min_date != +$.min_date || +k.max_date != +$.max_date) return l.render(), l.callEvent("onScaleAdjusted", []), true;
              }
              p == "add" || p == "move" || p == "delete" ? l.$layout && (this.$config.name != "task" || p != "add" && p != "delete" || this._skipTaskRecalculation != "lightbox" && (this._skipTaskRecalculation = true), l.$layout.resize()) : _ || h.refresh();
            }
          }), h.attachEvent("onAfterAdd", function(_, m) {
            f(m);
          }), h.attachEvent("onAfterUpdate", function(_, m) {
            v();
          }), h.attachEvent("onAfterDelete", function(_, m) {
            y(m);
          }), h.attachEvent("onAfterSilentDelete", function(_, m) {
            y(m);
          }), h.attachEvent("onBeforeIdChange", function(_, m) {
            y(l.mixin({ id: _ }, l.$data.linksStore.getItem(m))), f(l.$data.linksStore.getItem(m));
          }), h.attachEvent("onFilterItem", function(_, m) {
            if (!l.config.show_links) return false;
            var p = g(m.source), k = g(m.target);
            return !(!p || !k || l._isAllowedUnscheduledTask(l.getTask(m.source)) || l._isAllowedUnscheduledTask(l.getTask(m.target))) && l.callEvent("onBeforeLinkDisplay", [_, m]);
          }), c = {}, l.attachEvent("onBeforeTaskDelete", function(_, m) {
            return c[_] = ce.getSubtreeLinks(l, _), true;
          }), l.attachEvent("onAfterTaskDelete", function(_, m) {
            c[_] && l.$data.linksStore.silent(function() {
              for (var p in c[_]) l.isLinkExists(p) && l.$data.linksStore.removeItem(p), y(c[_][p]);
              c[_] = null;
            });
          }), l.attachEvent("onAfterLinkDelete", function(_, m) {
            l.refreshTask(m.source), l.refreshTask(m.target);
          }), l.attachEvent("onParse", v), b({ source: h, target: l, events: { onItemLoading: "onLinkLoading", onBeforeAdd: "onBeforeLinkAdd", onAfterAdd: "onAfterLinkAdd", onBeforeUpdate: "onBeforeLinkUpdate", onAfterUpdate: "onAfterLinkUpdate", onBeforeDelete: "onBeforeLinkDelete", onAfterDelete: "onAfterLinkDelete", onIdChange: "onLinkIdChange" } }), b({ source: u, target: l, events: { onItemLoading: "onTaskLoading", onBeforeAdd: "onBeforeTaskAdd", onAfterAdd: "onAfterTaskAdd", onBeforeUpdate: "onBeforeTaskUpdate", onAfterUpdate: "onAfterTaskUpdate", onBeforeDelete: "onBeforeTaskDelete", onAfterDelete: "onAfterTaskDelete", onIdChange: "onTaskIdChange", onBeforeItemMove: "onBeforeTaskMove", onAfterItemMove: "onAfterTaskMove", onFilterItem: "onBeforeTaskDisplay", onItemOpen: "onTaskOpened", onItemClose: "onTaskClosed", onBeforeSelect: "onBeforeTaskSelected", onAfterSelect: "onTaskSelected", onAfterUnselect: "onTaskUnselected" } }), l.$data = { tasksStore: u, linksStore: h };
        }(e), e.dataProcessor = Ke.DEPRECATED_api, e.createDataProcessor = Ke.createDataProcessor, function(l) {
          l.ext || (l.ext = {});
          for (var d = [ni, ai, si, oi, li, di, ci, ui, gi], c = 0; c < d.length; c++) d[c] && d[c](l);
        }(e), function(l) {
          l.getGridColumn = function(d) {
            for (var c = l.config.columns, u = 0; u < c.length; u++) if (c[u].name == d) return c[u];
            return null;
          }, l.getGridColumns = function() {
            return l.config.columns.slice();
          };
        }(e), function(l) {
          l.isReadonly = function(d) {
            return typeof d != "number" && typeof d != "string" || !l.isTaskExists(d) || (d = l.getTask(d)), (!d || !d[this.config.editable_property]) && (d && d[this.config.readonly_property] || this.config.readonly);
          };
        }(e), fi(e), function(l) {
          var d = new tn(l), c = new en(d);
          N(l, xi.create(d, c));
        }(e), $i(e), function(l) {
          l.getTaskType = function(d) {
            return "task";
          };
        }(e), function(l) {
          function d() {
            return l._cached_functions.update_if_changed(l), l._cached_functions.active || l._cached_functions.activate(), true;
          }
          l._cached_functions = { cache: {}, mode: false, critical_path_mode: false, wrap_methods: function(u, h) {
            if (h._prefetch_originals) for (var g in h._prefetch_originals) h[g] = h._prefetch_originals[g];
            for (h._prefetch_originals = {}, g = 0; g < u.length; g++) this.prefetch(u[g], h);
          }, prefetch: function(u, h) {
            var g = h[u];
            if (g) {
              var f = this;
              h._prefetch_originals[u] = g, h[u] = function() {
                for (var y = new Array(arguments.length), v = 0, b = arguments.length; v < b; v++) y[v] = arguments[v];
                if (f.active) {
                  var _ = f.get_arguments_hash(Array.prototype.slice.call(y));
                  f.cache[u] || (f.cache[u] = {});
                  var m = f.cache[u];
                  if (f.has_cached_value(m, _)) return f.get_cached_value(m, _);
                  var p = g.apply(this, y);
                  return f.cache_value(m, _, p), p;
                }
                return g.apply(this, y);
              };
            }
            return g;
          }, cache_value: function(u, h, g) {
            this.is_date(g) && (g = new Date(g)), u[h] = g;
          }, has_cached_value: function(u, h) {
            return u.hasOwnProperty(h);
          }, get_cached_value: function(u, h) {
            var g = u[h];
            return this.is_date(g) && (g = new Date(g)), g;
          }, is_date: function(u) {
            return u && u.getUTCDate;
          }, get_arguments_hash: function(u) {
            for (var h = [], g = 0; g < u.length; g++) h.push(this.stringify_argument(u[g]));
            return "(" + h.join(";") + ")";
          }, stringify_argument: function(u) {
            return (u.id ? u.id : this.is_date(u) ? u.valueOf() : u) + "";
          }, activate: function() {
            this.clear(), this.active = true;
          }, deactivate: function() {
            this.clear(), this.active = false;
          }, clear: function() {
            this.cache = {};
          }, setup: function(u) {
            var h = [], g = ["_isProjectEnd", "_getProjectEnd", "_getSlack"];
            this.mode == "auto" ? u.config.highlight_critical_path && (h = g) : this.mode === true && (h = g), this.wrap_methods(h, u);
          }, update_if_changed: function(u) {
            (this.critical_path_mode != u.config.highlight_critical_path || this.mode !== u.config.optimize_render) && (this.critical_path_mode = u.config.highlight_critical_path, this.mode = u.config.optimize_render, this.setup(u));
          } }, l.attachEvent("onBeforeGanttRender", d), l.attachEvent("onBeforeDataRender", d), l.attachEvent("onBeforeSmartRender", function() {
            d();
          }), l.attachEvent("onBeforeParse", d), l.attachEvent("onDataRender", function() {
            l._cached_functions.deactivate();
          });
          var c = null;
          l.attachEvent("onSmartRender", function() {
            c && clearTimeout(c), c = setTimeout(function() {
              l._cached_functions.deactivate();
            }, 1e3);
          }), l.attachEvent("onBeforeGanttReady", function() {
            return l._cached_functions.update_if_changed(l), true;
          });
        }(e), wi(e), function(l) {
          l.destructor = function() {
            for (var d in this.clearAll(), this.callEvent("onDestroy", []), this.$root && delete this.$root.gantt, this._eventRemoveAll && this._eventRemoveAll(), this.$layout && this.$layout.destructor(), this.resetLightbox && this.resetLightbox(), this.ext.inlineEditors && this.ext.inlineEditors.destructor(), this._dp && this._dp.destructor && this._dp.destructor(), this.$services.destructor(), this.detachAllEvents(), this) d.indexOf("$") === 0 && delete this[d];
            this.$destroyed = true;
          };
        }(e);
        var o = new Ui({ en: Ni, ar: Si, be: Ti, ca: Ei, cn: Ci, cs: Di, da: Ai, de: Ii, el: Mi, es: Li, fa: Pi, fi: Ri, fr: Hi, he: Oi, hr: Bi, hu: zi, id: Wi, it: ji, jp: Fi, kr: Vi, nb: qi, nl: Gi, no: Yi, pl: Ji, pt: Ki, ro: Xi, ru: Zi, si: Qi, sk: ta, sv: ea, tr: na, ua: ia });
        return e.i18n = { addLocale: o.addLocale, setLocale: function(l) {
          if (typeof l == "string") {
            var d = o.getLocale(l);
            d || (d = o.getLocale("en")), e.locale = d;
          } else if (l) if (e.locale) for (var c in l) l[c] && typeof l[c] == "object" ? (e.locale[c] || (e.locale[c] = {}), e.mixin(e.locale[c], l[c], true)) : e.locale[c] = l[c];
          else e.locale = l;
        }, getLocale: o.getLocale }, e.i18n.setLocale("en"), e;
      }
      function sa(t) {
        var e = "data-dhxbox", n = null;
        function i(_, m) {
          var p = _.callback;
          y.hide(_.box), n = _.box = null, p && p(m);
        }
        function a(_) {
          if (n) {
            var m = _.which || _.keyCode, p = false;
            if (v.keyboard) {
              if (m == 13 || m == 32) {
                var k = _.target || _.srcElement;
                Y(k).indexOf("gantt_popup_button") > -1 && k.click ? k.click() : (i(n, true), p = true);
              }
              m == 27 && (i(n, false), p = true);
            }
            return p ? (_.preventDefault && _.preventDefault(), !(_.cancelBubble = true)) : void 0;
          }
        }
        var r = vt(t.$root) || document;
        function s(_) {
          s.cover || (s.cover = document.createElement("div"), s.cover.onkeydown = a, s.cover.className = "dhx_modal_cover", document.body.appendChild(s.cover)), s.cover.style.display = _ ? "inline-block" : "none";
        }
        function o(_, m, p) {
          return "<div " + t._waiAria.messageButtonAttrString(_) + " class='gantt_popup_button " + ("gantt_" + m.toLowerCase().replace(/ /g, "_") + "_button") + "' data-result='" + p + "' result='" + p + "' ><div>" + _ + "</div></div>";
        }
        function l() {
          for (var _ = [].slice.apply(arguments, [0]), m = 0; m < _.length; m++) if (_[m]) return _[m];
        }
        function d(_, m, p) {
          var k = _.tagName ? _ : function(x, S, T) {
            var E = document.createElement("div"), C = at();
            t._waiAria.messageModalAttr(E, C), E.className = " gantt_modal_box gantt-" + x.type, E.setAttribute(e, 1);
            var D = "";
            if (x.width && (E.style.width = x.width), x.height && (E.style.height = x.height), x.title && (D += '<div class="gantt_popup_title">' + x.title + "</div>"), D += '<div class="gantt_popup_text" id="' + C + '"><span>' + (x.content ? "" : x.text) + '</span></div><div  class="gantt_popup_controls">', S && (D += o(l(x.ok, t.locale.labels.message_ok, "OK"), "ok", true)), T && (D += o(l(x.cancel, t.locale.labels.message_cancel, "Cancel"), "cancel", false)), x.buttons) for (var A = 0; A < x.buttons.length; A++) {
              var I = x.buttons[A];
              D += typeof I == "object" ? o(I.label, I.css || "gantt_" + I.label.toLowerCase() + "_button", I.value || A) : o(I, I, A);
            }
            if (D += "</div>", E.innerHTML = D, x.content) {
              var M = x.content;
              typeof M == "string" && (M = document.getElementById(M)), M.style.display == "none" && (M.style.display = ""), E.childNodes[x.title ? 1 : 0].appendChild(M);
            }
            return E.onclick = function(L) {
              var P = L.target || L.srcElement;
              if (P.className || (P = P.parentNode), ot(P, ".gantt_popup_button")) {
                var H = P.getAttribute("data-result");
                i(x, H = H == "true" || H != "false" && H);
              }
            }, x.box = E, (S || T) && (n = x), E;
          }(_, m, p);
          _.hidden || s(true), document.body.appendChild(k);
          var $ = Math.abs(Math.floor(((window.innerWidth || document.documentElement.offsetWidth) - k.offsetWidth) / 2)), w = Math.abs(Math.floor(((window.innerHeight || document.documentElement.offsetHeight) - k.offsetHeight) / 2));
          return _.position == "top" ? k.style.top = "-3px" : k.style.top = w + "px", k.style.left = $ + "px", k.onkeydown = a, y.focus(k), _.hidden && y.hide(k), t.callEvent("onMessagePopup", [k]), k;
        }
        function c(_) {
          return d(_, true, false);
        }
        function u(_) {
          return d(_, true, true);
        }
        function h(_) {
          return d(_);
        }
        function g(_, m, p) {
          return typeof _ != "object" && (typeof m == "function" && (p = m, m = ""), _ = { text: _, type: m, callback: p }), _;
        }
        function f(_, m, p, k) {
          return typeof _ != "object" && (_ = { text: _, type: m, expire: p, id: k }), _.id = _.id || at(), _.expire = _.expire || v.expire, _;
        }
        t.event(r, "keydown", a, true);
        var y = function() {
          var _ = g.apply(this, arguments);
          return _.type = _.type || "alert", h(_);
        };
        y.hide = function(_) {
          for (; _ && _.getAttribute && !_.getAttribute(e); ) _ = _.parentNode;
          _ && (_.parentNode.removeChild(_), s(false), t.callEvent("onAfterMessagePopup", [_]));
        }, y.focus = function(_) {
          setTimeout(function() {
            var m = Zt(_);
            m.length && m[0].focus && m[0].focus();
          }, 1);
        };
        var v = function(_, m, p, k) {
          switch ((_ = f.apply(this, arguments)).type = _.type || "info", _.type.split("-")[0]) {
            case "alert":
              return c(_);
            case "confirm":
              return u(_);
            case "modalbox":
              return h(_);
            default:
              return function($) {
                v.area || (v.area = document.createElement("div"), v.area.className = "gantt_message_area", v.area.style[v.position] = "5px", document.body.appendChild(v.area)), v.hide($.id);
                var w = document.createElement("div");
                return w.innerHTML = "<div>" + $.text + "</div>", w.className = "gantt-info gantt-" + $.type, w.onclick = function() {
                  v.hide($.id), $ = null;
                }, t._waiAria.messageInfoAttr(w), v.position == "bottom" && v.area.firstChild ? v.area.insertBefore(w, v.area.firstChild) : v.area.appendChild(w), $.expire > 0 && (v.timers[$.id] = window.setTimeout(function() {
                  v && v.hide($.id);
                }, $.expire)), v.pull[$.id] = w, w = null, $.id;
              }(_);
          }
        };
        v.seed = (/* @__PURE__ */ new Date()).valueOf(), v.uid = at, v.expire = 4e3, v.keyboard = true, v.position = "top", v.pull = {}, v.timers = {}, v.hideAll = function() {
          for (var _ in v.pull) v.hide(_);
        }, v.hide = function(_) {
          var m = v.pull[_];
          m && m.parentNode && (window.setTimeout(function() {
            m.parentNode.removeChild(m), m = null;
          }, 2e3), m.className += " hidden", v.timers[_] && window.clearTimeout(v.timers[_]), delete v.pull[_]);
        };
        var b = [];
        return t.attachEvent("onMessagePopup", function(_) {
          b.push(_);
        }), t.attachEvent("onAfterMessagePopup", function(_) {
          for (var m = 0; m < b.length; m++) b[m] === _ && (b.splice(m, 1), m--);
        }), t.attachEvent("onDestroy", function() {
          s.cover && s.cover.parentNode && s.cover.parentNode.removeChild(s.cover);
          for (var _ = 0; _ < b.length; _++) b[_].parentNode && b[_].parentNode.removeChild(b[_]);
          b = null, v.area && v.area.parentNode && v.area.parentNode.removeChild(v.area), v = null;
        }), { alert: function() {
          var _ = g.apply(this, arguments);
          return _.type = _.type || "confirm", c(_);
        }, confirm: function() {
          var _ = g.apply(this, arguments);
          return _.type = _.type || "alert", u(_);
        }, message: v, modalbox: y };
      }
      function rn(t, e) {
        var n = this.$config[t];
        return n ? (n.$extendedConfig || (n.$extendedConfig = true, Object.setPrototypeOf(n, e)), n) : e;
      }
      function oa(t, e) {
        var n, i, a;
        N(t, (n = e, { $getConfig: function() {
          return i || (i = n ? n.$getConfig() : this.$gantt.config), this.$config.config ? rn.call(this, "config", i) : i;
        }, $getTemplates: function() {
          return a || (a = n ? n.$getTemplates() : this.$gantt.templates), this.$config.templates ? rn.call(this, "templates", a) : a;
        } }));
      }
      const la = function(t) {
        var e = {}, n = {};
        function i(a, r, s, o) {
          var l = e[a];
          if (!l || !l.create) return false;
          a != "resizer" || s.mode || (o.$config.cols ? s.mode = "x" : s.mode = "y"), a != "viewcell" || s.view != "scrollbar" || s.scroll || (o.$config.cols ? s.scroll = "y" : s.scroll = "x"), (s = V(s)).id || n[s.view] || (s.id = s.view), s.id && !s.css && (s.css = s.id + "_cell");
          var d = new l.create(r, s, this, t);
          return l.configure && l.configure(d), oa(d, o), d.$id || (d.$id = s.id || t.uid()), d.$parent || typeof r != "object" || (d.$parent = r), d.$config || (d.$config = s), n[d.$id] && (d.$id = t.uid()), n[d.$id] = d, d;
        }
        return { initUI: function(a, r) {
          var s = "cell";
          return a.view ? s = "viewcell" : a.resizer ? s = "resizer" : a.rows || a.cols ? s = "layout" : a.views && (s = "multiview"), i.call(this, s, null, a, r);
        }, reset: function() {
          n = {};
        }, registerView: function(a, r, s) {
          e[a] = { create: r, configure: s };
        }, createView: i, getView: function(a) {
          return n[a];
        } };
      };
      var da = /* @__PURE__ */ function(t) {
        return function(e) {
          var n = { click: {}, doubleclick: {}, contextMenu: {} };
          function i(h, g, f, y) {
            n[h][g] || (n[h][g] = []), n[h][g].push({ handler: f, root: y });
          }
          function a(h) {
            h = h || window.event;
            var g = e.locate(h), f = s(h, n.click), y = true;
            if (g !== null ? y = !e.checkEvent("onTaskClick") || e.callEvent("onTaskClick", [g, h]) : e.callEvent("onEmptyClick", [h]), y) {
              if (!o(f, h, g)) return;
              switch (h.target.nodeName) {
                case "SELECT":
                case "INPUT":
                  return;
              }
              g && e.getTask(g) && !e._multiselect && e.config.select_task && e.selectTask(g);
            }
          }
          function r(h) {
            var g = (h = h || window.event).target || h.srcElement, f = e.locate(g), y = e.locate(g, e.config.link_attribute), v = !e.checkEvent("onContextMenu") || e.callEvent("onContextMenu", [f, y, h]);
            return v || (h.preventDefault ? h.preventDefault() : h.returnValue = false), v;
          }
          function s(h, g) {
            for (var f = h.target || h.srcElement, y = []; f; ) {
              var v = t.getClassName(f);
              if (v) {
                v = v.split(" ");
                for (var b = 0; b < v.length; b++) if (v[b] && g[v[b]]) for (var _ = g[v[b]], m = 0; m < _.length; m++) _[m].root && !t.isChildOf(f, _[m].root) || y.push(_[m].handler);
              }
              f = f.parentNode;
            }
            return y;
          }
          function o(h, g, f) {
            for (var y = true, v = 0; v < h.length; v++) {
              var b = h[v].call(e, g, f, g.target || g.srcElement);
              y = y && !(b !== void 0 && b !== true);
            }
            return y;
          }
          function l(h) {
            h = h || window.event;
            var g = e.locate(h), f = s(h, n.doubleclick), y = !e.checkEvent("onTaskDblClick") || g === null || e.callEvent("onTaskDblClick", [g, h]);
            if (y) {
              if (!o(f, h, g)) return;
              g !== null && e.getTask(g) && y && e.config.details_on_dblclick && !e.isReadonly(g) && e.showLightbox(g);
            }
          }
          function d(h) {
            if (e.checkEvent("onMouseMove")) {
              var g = e.locate(h);
              e._last_move_event = h, e.callEvent("onMouseMove", [g, h]);
            }
          }
          var c = e._createDomEventScope();
          function u(h) {
            c.detachAll(), h && (c.attach(h, "click", a), c.attach(h, "dblclick", l), c.attach(h, "mousemove", d), c.attach(h, "contextmenu", r));
          }
          return { reset: u, global: function(h, g, f) {
            i(h, g, f, null);
          }, delegate: i, detach: function(h, g, f, y) {
            if (n[h] && n[h][g]) {
              for (var v = n[h], b = v[g], _ = 0; _ < b.length; _++) b[_].root == y && (b.splice(_, 1), _--);
              b.length || delete v[g];
            }
          }, callHandler: function(h, g, f, y) {
            var v = n[h][g];
            if (v) for (var b = 0; b < v.length; b++) (f || v[b].root) && v[b].root !== f || v[b].handler.apply(this, y);
          }, onDoubleClick: l, onMouseMove: d, onContextMenu: r, onClick: a, destructor: function() {
            u(), n = null, c = null;
          } };
        };
      }(Ne);
      const ca = { init: da };
      function sn(t, e, n) {
        return !!e && !(e.left > t.x_end || e.left + e.width < t.x) && !(e.top > t.y_end || e.top + e.height < t.y);
      }
      function At(t) {
        return t.config.smart_rendering && t._smart_render;
      }
      function Ft(t, e, n) {
        return { top: e.getItemTop(t.id), height: e.getItemHeight(t.id), left: 0, right: 1 / 0 };
      }
      function _t(t, e, n, i, a) {
        var r = e.getItemIndexByTopPosition(a.y) || 0, s = e.getItemIndexByTopPosition(a.y_end) || i.count(), o = Math.max(0, r - 1), l = Math.min(i.count(), s + 1);
        const d = [];
        if (t.config.keyboard_navigation && t.getSelectedId() && d.push(t.getSelectedId()), t.$ui.getView("grid") && t.ext.inlineEditors && t.ext.inlineEditors.getState().id) {
          let c = t.ext.inlineEditors.getState().id;
          i.exists(c) && d.push(c);
        }
        return { start: o, end: l, ids: d };
      }
      var ua = function(t) {
        var e = /* @__PURE__ */ function(n) {
          var i = {}, a = {};
          function r(o) {
            var l = null;
            return typeof o.view == "string" ? l = n.$ui.getView(o.view) : o.view && (l = o.view), l;
          }
          function s(o, l, d) {
            if (a[o]) return a[o];
            l.renderer || n.assert(false, "Invalid renderer call");
            var c = null, u = null, h = null, g = null, f = null;
            typeof l.renderer == "function" ? (c = l.renderer, h = Ft) : (c = l.renderer.render, u = l.renderer.update, g = l.renderer.onrender, l.renderer.isInViewPort ? f = l.renderer.isInViewPort : h = l.renderer.getRectangle, h || h === null || (h = Ft));
            var y = l.filter;
            return d && d.setAttribute(n.config.layer_attribute, true), a[o] = { render_item: function(v, b, _, m, p) {
              if (b = b || d, !y || y(v)) {
                var k = m || r(l), $ = p || (k ? k.$getConfig() : null), w = _;
                !w && $ && $.smart_rendering && (w = k.getViewPort());
                var x = null;
                !At(n) && (h || f) && w ? (f ? f(v, w, k, $, n) : sn(w, h(v, k, $, n))) && (x = c.call(n, v, k, $, w)) : x = c.call(n, v, k, $, w), this.append(v, x, b);
                var S = b.nodeType == 11;
                g && !S && x && g.call(n, v, x, k);
              } else this.remove_item(v.id);
            }, clear: function(v) {
              this.rendered = i[o] = {}, l.append || this.clear_container(v);
            }, clear_container: function(v) {
              (v = v || d) && (v.innerHTML = "");
            }, get_visible_range: function(v) {
              var b, _, m = r(l), p = m ? m.$getConfig() : null;
              return p && p.smart_rendering && (b = m.getViewPort()), m && b && (typeof l.renderer == "function" ? _ = _t(n, m, 0, v, b) : l.renderer && l.renderer.getVisibleRange && (_ = l.renderer.getVisibleRange(n, m, p, v, b))), _ || (_ = { start: 0, end: v.count() }), _;
            }, prepare_data: function(v) {
              if (l.renderer && l.renderer.prepareData) return l.renderer.prepareData(v, n, l);
            }, render_items: function(v, b) {
              b = b || d;
              var _ = document.createDocumentFragment();
              this.clear(b);
              var m = null, p = r(l), k = p ? p.$getConfig() : null;
              k && k.smart_rendering && (m = p.getViewPort());
              for (var $ = 0, w = v.length; $ < w; $++) this.render_item(v[$], _, m, p, k);
              b.appendChild(_, b);
              var x = {};
              v.forEach(function(E) {
                x[E.id] = E;
              });
              var S = {};
              if (g) {
                var T = {};
                for (var $ in this.rendered) S[$] || (T[$] = this.rendered[$], g.call(n, x[$], this.rendered[$], p));
              }
            }, update_items: function(v, b) {
              var _ = r(l), m = _ ? _.$getConfig() : null;
              if (_ && _.$getConfig().smart_rendering && !At(n) && this.rendered && (h || f)) {
                b = b || d;
                var p = document.createDocumentFragment(), k = null;
                _ && (k = _.getViewPort());
                var $ = {};
                v.forEach(function(I) {
                  $[I.id] = I;
                });
                var w = {}, x = {};
                for (var S in this.rendered) x[S] = true, w[S] = true;
                for (var T = {}, E = (S = 0, v.length); S < E; S++) {
                  var C = v[S], D = this.rendered[C.id];
                  x[C.id] = false, D && D.parentNode ? (f ? f(C, k, _, m, n) : sn(k, h(C, _, m, n))) ? (u && u.call(n, C, D, _, m, k), this.restore(C, p)) : x[C.id] = true : (T[v[S].id] = true, this.render_item(v[S], p, k, _, m));
                }
                for (var S in x) x[S] && this.hide(S);
                if (p.childNodes.length && b.appendChild(p, b), g) {
                  var A = {};
                  for (var S in this.rendered) w[S] && !T[S] || (A[S] = this.rendered[S], g.call(n, $[S], this.rendered[S], _));
                }
              }
            }, append: function(v, b, _) {
              this.rendered && (b ? (this.rendered[v.id] && this.rendered[v.id].parentNode ? this.replace_item(v.id, b) : _.appendChild(b), this.rendered[v.id] = b) : this.rendered[v.id] && this.remove_item(v.id));
            }, replace_item: function(v, b) {
              var _ = this.rendered[v];
              _ && _.parentNode && _.parentNode.replaceChild(b, _), this.rendered[v] = b;
            }, remove_item: function(v) {
              this.hide(v), delete this.rendered[v];
            }, hide: function(v) {
              var b = this.rendered[v];
              b && b.parentNode && b.parentNode.removeChild(b);
            }, restore: function(v, b) {
              var _ = this.rendered[v.id];
              _ ? _.parentNode || this.append(v, _, b || d) : this.render_item(v, b || d);
            }, change_id: function(v, b) {
              this.rendered[b] = this.rendered[v], delete this.rendered[v];
            }, rendered: i[o], node: d, destructor: function() {
              this.clear(), delete a[o], delete i[o];
            } }, a[o];
          }
          return { getRenderer: s, clearRenderers: function() {
            for (var o in a) s(o).destructor();
          } };
        }(t);
        return { createGroup: function(n, i, a, r) {
          var s = { tempCollection: [], renderers: {}, container: n, filters: [], getLayers: function() {
            this._add();
            var o = [];
            for (var l in this.renderers) o.push(this.renderers[l]);
            return o;
          }, getLayer: function(o) {
            return this.renderers[o];
          }, _add: function(o) {
            o && (o.id = o.id || at(), this.tempCollection.push(o));
            for (var l = this.container(), d = this.tempCollection, c = 0; c < d.length; c++) if (o = d[c], this.container() || o && o.container && G(o.container, document.body)) {
              var u = o.container, h = o.id, g = o.topmost;
              if (!u.parentNode) if (g) l.appendChild(u);
              else {
                var f = i ? i() : l.firstChild;
                f && f.parentNode == l ? l.insertBefore(u, f) : l.appendChild(u);
              }
              this.renderers[h] = e.getRenderer(h, o, u), r && r(o, t), this.tempCollection.splice(c, 1), c--;
            }
          }, addLayer: function(o) {
            if (o) {
              typeof o == "function" && (o = { renderer: o }), o.filter === void 0 ? o.filter = on(a || []) : o.filter instanceof Array && (o.filter.push(a), o.filter = on(o.filter)), o.container || (o.container = document.createElement("div"));
              var l = this;
              o.requestUpdate = function() {
                t.config.smart_rendering && !At(t) && l.renderers[o.id] && l.onUpdateRequest(l.renderers[o.id]);
              };
            }
            return this._add(o), o ? o.id : void 0;
          }, onUpdateRequest: function(o) {
          }, eachLayer: function(o) {
            for (var l in this.renderers) o(this.renderers[l]);
          }, removeLayer: function(o) {
            this.renderers[o] && (this.renderers[o].destructor(), delete this.renderers[o]);
          }, clear: function() {
            for (var o in this.renderers) this.renderers[o].destructor();
            this.renderers = {};
          } };
          return t.attachEvent("onDestroy", function() {
            s.clear(), s = null;
          }), s;
        } };
      };
      function on(t) {
        return t instanceof Array || (t = Array.prototype.slice.call(arguments, 0)), function(e) {
          for (var n = true, i = 0, a = t.length; i < a; i++) {
            var r = t[i];
            r && (n = n && r(e.id, e) !== false);
          }
          return n;
        };
      }
      function ln(t, e, n) {
        if (!t.start_date || !t.end_date) return null;
        var i = e.posFromDate(t.start_date), a = e.posFromDate(t.end_date), r = Math.min(i, a) - 200, s = Math.max(i, a) + 200;
        return { top: e.getItemTop(t.id), height: e.getItemHeight(t.id), left: r, width: s - r };
      }
      function dn() {
        var t = [], e = false;
        function n() {
          t = [], e = false;
        }
        function i(r, s, o) {
          s.$getConfig(), r.getVisibleItems().forEach(function(l) {
            var d = function(c, u, h, g) {
              if (!g.isTaskExists(c.source) || !g.isTaskExists(c.target)) return null;
              var f = ln(g.getTask(c.source), u), y = ln(g.getTask(c.target), u);
              if (!f || !y) return null;
              var v = 100, b = Math.min(f.left, y.left) - v, _ = Math.max(f.left + f.width, y.left + y.width) + v, m = Math.min(f.top, y.top) - v, p = Math.max(f.top + f.height, y.top + y.height) + v;
              return { top: m, height: p - m, bottom: p, left: b, width: _ - b, right: _ };
            }(l, s, 0, o);
            d && t.push({ id: l.id, rec: d });
          }), t.sort(function(l, d) {
            return l.rec.right < d.rec.right ? -1 : 1;
          }), e = true;
        }
        var a = false;
        return function(r, s, o, l, d) {
          (function(f) {
            a || (a = true, f.attachEvent("onPreFilter", n), f.attachEvent("onStoreUpdated", n), f.attachEvent("onClearAll", n), f.attachEvent("onBeforeStoreUpdate", n));
          })(l), e || i(l, s, r);
          for (var c = [], u = 0; u < t.length; u++) {
            var h = t[u], g = h.rec;
            g.right < d.x || g.left < d.x_end && g.right > d.x && g.top < d.y_end && g.bottom > d.y && c.push(h.id);
          }
          return { ids: c };
        };
      }
      function cn(t, e, n, i, a) {
        var r = n.$gantt.getTask(t.source), s = n.$gantt.getTask(t.target), o = n.getItemTop(r.id), l = n.getItemHeight(r.id), d = n.getItemTop(s.id), c = n.getItemHeight(s.id);
        if (e.y > o + l && e.y > d + c || e.y_end < d && e.y_end < o) return false;
        var u = 100, h = n.posFromDate(r.start_date), g = n.posFromDate(r.end_date), f = n.posFromDate(s.start_date), y = n.posFromDate(s.end_date);
        if (h > g) {
          var v = g;
          g = h, h = v;
        }
        return f > y && (v = y, y = f, f = v), h += -100, g += u, f += -100, y += u, !(e.x > g && e.x > y) && !(e.x_end < h && e.x_end < f);
      }
      function ha(t, e) {
        if (t.view) {
          var n = t.view;
          typeof n == "string" && (n = e.$ui.getView(n)), n && n.attachEvent && n.attachEvent("onScroll", function() {
            e.$services.getService("state").getState("batchUpdate").batch_update || n.$config.$skipSmartRenderOnScroll || t.requestUpdate && t.requestUpdate();
          });
        }
      }
      var It = function() {
        function t(e, n, i, a) {
          e && (this.$container = Qt(e), this.$parent = e), this.$config = N(n, { headerHeight: 33 }), this.$gantt = a, this.$domEvents = a._createDomEventScope(), this.$id = n.id || "c" + at(), this.$name = "cell", this.$factory = i, nt(this);
        }
        return t.prototype.destructor = function() {
          this.$parent = this.$container = this.$view = null, this.$gantt.$services.getService("mouseEvents").detach("click", "gantt_header_arrow", this._headerClickHandler), this.$domEvents.detachAll(), this.callEvent("onDestroy", []), this.detachAllEvents();
        }, t.prototype.cell = function(e) {
          return null;
        }, t.prototype.scrollTo = function(e, n) {
          var i = this.$view;
          this.$config.html && (i = this.$view.firstChild), 1 * e == e && (i.scrollLeft = e), 1 * n == n && (i.scrollTop = n);
        }, t.prototype.clear = function() {
          this.getNode().innerHTML = "", this.getNode().className = "gantt_layout_content", this.getNode().style.padding = "0";
        }, t.prototype.resize = function(e) {
          if (this.$parent) return this.$parent.resize(e);
          e === false && (this.$preResize = true);
          var n = this.$container, i = n.offsetWidth, a = n.offsetHeight, r = this.getSize();
          n === document.body && (i = document.body.offsetWidth, a = document.body.offsetHeight), i < r.minWidth && (i = r.minWidth), i > r.maxWidth && (i = r.maxWidth), a < r.minHeight && (a = r.minHeight), a > r.maxHeight && (a = r.maxHeight), this.setSize(i, a), this.$preResize, this.$preResize = false;
        }, t.prototype.hide = function() {
          this._hide(true), this.resize();
        }, t.prototype.show = function(e) {
          this._hide(false), e && this.$parent && this.$parent.show(), this.resize();
        }, t.prototype._hide = function(e) {
          if (e === true && this.$view.parentNode) this.$view.parentNode.removeChild(this.$view);
          else if (e === false && !this.$view.parentNode) {
            var n = this.$parent.cellIndex(this.$id);
            this.$parent.moveView(this, n);
          }
          this.$config.hidden = e;
        }, t.prototype.$toHTML = function(e, n) {
          e === void 0 && (e = ""), n = [n || "", this.$config.css || ""].join(" ");
          var i = this.$config, a = "";
          return i.raw ? e = typeof i.raw == "string" ? i.raw : "" : (e || (e = "<div class='gantt_layout_content' " + (n ? " class='" + n + "' " : "") + " >" + (i.html || "") + "</div>"), i.header && (a = "<div class='gantt_layout_header'>" + (i.canCollapse ? "<div class='gantt_layout_header_arrow'></div>" : "") + "<div class='gantt_layout_header_content'>" + i.header + "</div></div>")), "<div class='gantt_layout_cell " + n + "' data-cell-id='" + this.$id + "'>" + a + e + "</div>";
        }, t.prototype.$fill = function(e, n) {
          this.$view = e, this.$parent = n, this.init();
        }, t.prototype.getNode = function() {
          return this.$view.querySelector("gantt_layout_cell") || this.$view;
        }, t.prototype.init = function() {
          var e = this;
          this._headerClickHandler = function(n) {
            Z(n, "data-cell-id") == e.$id && e.toggle();
          }, this.$gantt.$services.getService("mouseEvents").delegate("click", "gantt_header_arrow", this._headerClickHandler), this.callEvent("onReady", []);
        }, t.prototype.toggle = function() {
          this.$config.collapsed = !this.$config.collapsed, this.resize();
        }, t.prototype.getSize = function() {
          var e = { height: this.$config.height || 0, width: this.$config.width || 0, gravity: this.$config.gravity || 1, minHeight: this.$config.minHeight || 0, minWidth: this.$config.minWidth || 0, maxHeight: this.$config.maxHeight || 1e11, maxWidth: this.$config.maxWidth || 1e11 };
          if (this.$config.collapsed) {
            var n = this.$config.mode === "x";
            e[n ? "width" : "height"] = e[n ? "maxWidth" : "maxHeight"] = this.$config.headerHeight;
          }
          return e;
        }, t.prototype.getContentSize = function() {
          var e = this.$lastSize.contentX;
          e !== 1 * e && (e = this.$lastSize.width);
          var n = this.$lastSize.contentY;
          return n !== 1 * n && (n = this.$lastSize.height), { width: e, height: n };
        }, t.prototype._getBorderSizes = function() {
          var e = { top: 0, right: 0, bottom: 0, left: 0, horizontal: 0, vertical: 0 };
          return this._currentBorders && (this._currentBorders[this._borders.left] && (e.left = 1, e.horizontal++), this._currentBorders[this._borders.right] && (e.right = 1, e.horizontal++), this._currentBorders[this._borders.top] && (e.top = 1, e.vertical++), this._currentBorders[this._borders.bottom] && (e.bottom = 1, e.vertical++)), e;
        }, t.prototype.setSize = function(e, n) {
          this.$view.style.width = e + "px", this.$view.style.height = n + "px";
          var i = this._getBorderSizes(), a = n - i.vertical, r = e - i.horizontal;
          this.$lastSize = { x: e, y: n, contentX: r, contentY: a }, this.$config.header ? this._sizeHeader() : this._sizeContent();
        }, t.prototype._borders = { left: "gantt_layout_cell_border_left", right: "gantt_layout_cell_border_right", top: "gantt_layout_cell_border_top", bottom: "gantt_layout_cell_border_bottom" }, t.prototype._setBorders = function(e, n) {
          n || (n = this);
          var i = n.$view;
          for (var a in this._borders) Ht(i, this._borders[a]);
          typeof e == "string" && (e = [e]);
          var r = {};
          for (a = 0; a < e.length; a++) bt(i, e[a]), r[e[a]] = true;
          n._currentBorders = r;
        }, t.prototype._sizeContent = function() {
          var e = this.$view.childNodes[0];
          e && e.className == "gantt_layout_content" && (e.style.height = this.$lastSize.contentY + "px");
        }, t.prototype._sizeHeader = function() {
          var e = this.$lastSize;
          e.contentY -= this.$config.headerHeight;
          var n = this.$view.childNodes[0], i = this.$view.childNodes[1], a = this.$config.mode === "x";
          if (this.$config.collapsed) if (i.style.display = "none", a) {
            n.className = "gantt_layout_header collapsed_x", n.style.width = e.y + "px";
            var r = Math.floor(e.y / 2 - e.x / 2);
            n.style.transform = "rotate(90deg) translate(" + r + "px, " + r + "px)", i.style.display = "none";
          } else n.className = "gantt_layout_header collapsed_y";
          else n.className = a ? "gantt_layout_header" : "gantt_layout_header vertical", n.style.width = "auto", n.style.transform = "", i.style.display = "", i.style.height = e.contentY + "px";
          n.style.height = this.$config.headerHeight + "px";
        }, t;
      }();
      function z(t, e) {
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        function i() {
          this.constructor = t;
        }
        t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
      }
      var un = function(t) {
        function e(n, i, a) {
          var r = t.apply(this, arguments) || this;
          return n && (r.$root = true), r._parseConfig(i), r.$name = "layout", r;
        }
        return z(e, t), e.prototype.destructor = function() {
          this.$container && this.$view && Ce(this.$view);
          for (var n = 0; n < this.$cells.length; n++) this.$cells[n].destructor();
          this.$cells = [], t.prototype.destructor.call(this);
        }, e.prototype._resizeScrollbars = function(n, i) {
          var a = false, r = [], s = [];
          const o = [];
          function l(f) {
            f.$parent.show(), a = true, r.push(f);
          }
          function d(f) {
            f.$parent.hide(), a = true, s.push(f);
          }
          for (var c, u = 0; u < i.length; u++) n[(c = i[u]).$config.scroll] ? d(c) : c.shouldHide() ? o.push(c) : c.shouldShow() ? l(c) : c.isVisible() ? r.push(c) : s.push(c);
          var h = {};
          for (u = 0; u < r.length; u++) r[u].$config.group && (h[r[u].$config.group] = true);
          for (o.forEach(function(f) {
            f.$config.group && h[f.$config.group] || d(f);
          }), u = 0; u < s.length; u++) if ((c = s[u]).$config.group && h[c.$config.group]) {
            l(c);
            for (var g = 0; g < r.length; g++) if (r[g] == c) {
              this.$gantt.$scrollbarRepaint = true;
              break;
            }
          }
          return a;
        }, e.prototype._syncCellSizes = function(n, i) {
          if (n) {
            var a = {};
            return this._eachChild(function(r) {
              r.$config.group && r.$name != "scrollbar" && r.$name != "resizer" && (a[r.$config.group] || (a[r.$config.group] = []), a[r.$config.group].push(r));
            }), a[n] && this._syncGroupSize(a[n], i), a[n];
          }
        }, e.prototype._syncGroupSize = function(n, i) {
          if (n.length) for (var a = n[0].$parent._xLayout ? "width" : "height", r = n[0].$parent.getNextSibling(n[0].$id) ? 1 : -1, s = i.value, o = i.isGravity, l = 0; l < n.length; l++) {
            var d = n[l].getSize(), c = r > 0 ? n[l].$parent.getNextSibling(n[l].$id) : n[l].$parent.getPrevSibling(n[l].$id);
            c.$name == "resizer" && (c = r > 0 ? c.$parent.getNextSibling(c.$id) : c.$parent.getPrevSibling(c.$id));
            var u = c.getSize();
            if (o) n[l].$config.gravity = s;
            else if (c[a]) {
              var h = d.gravity + u.gravity, g = d[a] + u[a], f = h / g;
              n[l].$config.gravity = f * s, c.$config[a] = g - s, c.$config.gravity = h - f * s;
            } else n[l].$config[a] = s;
            var y = this.$gantt.$ui.getView("grid");
            !y || n[l].$content !== y || y.$config.scrollable || o || (this.$gantt.config.grid_width = s);
          }
        }, e.prototype.resize = function(n) {
          var i = false;
          if (this.$root && !this._resizeInProgress && (this.callEvent("onBeforeResize", []), i = true, this._resizeInProgress = true), t.prototype.resize.call(this, true), t.prototype.resize.call(this, false), i) {
            var a = [];
            a = (a = (a = a.concat(this.getCellsByType("viewCell"))).concat(this.getCellsByType("viewLayout"))).concat(this.getCellsByType("hostCell"));
            for (var r = this.getCellsByType("scroller"), s = 0; s < a.length; s++) a[s].$config.hidden || a[s].setContentSize();
            var o = this._getAutosizeMode(this.$config.autosize), l = this._resizeScrollbars(o, r);
            if (this.$config.autosize && (this.autosize(this.$config.autosize), a.forEach(function(d) {
              const c = d.$parent, u = c.getContentSize(o);
              o.x && (c.$config.$originalWidthStored || (c.$config.$originalWidthStored = true, c.$config.$originalWidth = c.$config.width), c.$config.width = u.width), o.y && (c.$config.$originalHeightStored || (c.$config.$originalHeightStored = true, c.$config.$originalHeight = c.$config.height), c.$config.height = u.height);
            }), l = true), l) for (this.resize(), s = 0; s < a.length; s++) a[s].$config.hidden || a[s].setContentSize();
            this.callEvent("onResize", []);
          }
          i && (this._resizeInProgress = false);
        }, e.prototype._eachChild = function(n, i) {
          if (n(i = i || this), i.$cells) for (var a = 0; a < i.$cells.length; a++) this._eachChild(n, i.$cells[a]);
        }, e.prototype.isChild = function(n) {
          var i = false;
          return this._eachChild(function(a) {
            a !== n && a.$content !== n || (i = true);
          }), i;
        }, e.prototype.getCellsByType = function(n) {
          var i = [];
          if (n === this.$name && i.push(this), this.$content && this.$content.$name == n && i.push(this.$content), this.$cells) for (var a = 0; a < this.$cells.length; a++) {
            var r = e.prototype.getCellsByType.call(this.$cells[a], n);
            r.length && i.push.apply(i, r);
          }
          return i;
        }, e.prototype.getNextSibling = function(n) {
          var i = this.cellIndex(n);
          return i >= 0 && this.$cells[i + 1] ? this.$cells[i + 1] : null;
        }, e.prototype.getPrevSibling = function(n) {
          var i = this.cellIndex(n);
          return i >= 0 && this.$cells[i - 1] ? this.$cells[i - 1] : null;
        }, e.prototype.cell = function(n) {
          for (var i = 0; i < this.$cells.length; i++) {
            var a = this.$cells[i];
            if (a.$id === n) return a;
            var r = a.cell(n);
            if (r) return r;
          }
        }, e.prototype.cellIndex = function(n) {
          for (var i = 0; i < this.$cells.length; i++) if (this.$cells[i].$id === n) return i;
          return -1;
        }, e.prototype.moveView = function(n, i) {
          if (this.$cells[i] !== n) return window.alert("Not implemented");
          i += this.$config.header ? 1 : 0;
          var a = this.$view;
          i >= a.childNodes.length ? a.appendChild(n.$view) : a.insertBefore(n.$view, a.childNodes[i]);
        }, e.prototype._parseConfig = function(n) {
          this.$cells = [], this._xLayout = !n.rows;
          for (var i = n.rows || n.cols || n.views, a = 0; a < i.length; a++) {
            var r = i[a];
            r.mode = this._xLayout ? "x" : "y";
            var s = this.$factory.initUI(r, this);
            s ? (s.$parent = this, this.$cells.push(s)) : (i.splice(a, 1), a--);
          }
        }, e.prototype.getCells = function() {
          return this.$cells;
        }, e.prototype.render = function() {
          var n = Ee(this.$container, this.$toHTML());
          this.$fill(n, null), this.callEvent("onReady", []), this.resize(), this.render = this.resize;
        }, e.prototype.$fill = function(n, i) {
          this.$view = n, this.$parent = i;
          for (var a = De(n, "gantt_layout_cell"), r = a.length - 1; r >= 0; r--) {
            var s = this.$cells[r];
            s.$fill(a[r], this), s.$config.hidden && s.$view.parentNode.removeChild(s.$view);
          }
        }, e.prototype.$toHTML = function() {
          for (var n = this._xLayout ? "x" : "y", i = [], a = 0; a < this.$cells.length; a++) i.push(this.$cells[a].$toHTML());
          return t.prototype.$toHTML.call(this, i.join(""), (this.$root ? "gantt_layout_root " : "") + "gantt_layout gantt_layout_" + n);
        }, e.prototype.getContentSize = function(n) {
          for (var i, a, r, s = 0, o = 0, l = 0; l < this.$cells.length; l++) (a = this.$cells[l]).$config.hidden || (i = a.getContentSize(n), a.$config.view === "scrollbar" && n[a.$config.scroll] && (i.height = 0, i.width = 0), a.$config.resizer && (this._xLayout ? i.height = 0 : i.width = 0), r = a._getBorderSizes(), this._xLayout ? (s += i.width + r.horizontal, o = Math.max(o, i.height + r.vertical)) : (s = Math.max(s, i.width + r.horizontal), o += i.height + r.vertical));
          return { width: s += (r = this._getBorderSizes()).horizontal, height: o += r.vertical };
        }, e.prototype._cleanElSize = function(n) {
          return 1 * (n || "").toString().replace("px", "") || 0;
        }, e.prototype._getBoxStyles = function(n) {
          var i = null, a = ["width", "height", "paddingTop", "paddingBottom", "paddingLeft", "paddingRight", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"], r = { boxSizing: (i = window.getComputedStyle ? window.getComputedStyle(n, null) : { width: n.clientWidth, height: n.clientHeight }).boxSizing == "border-box" };
          i.MozBoxSizing && (r.boxSizing = i.MozBoxSizing == "border-box");
          for (var s = 0; s < a.length; s++) r[a[s]] = i[a[s]] ? this._cleanElSize(i[a[s]]) : 0;
          var o = { horPaddings: r.paddingLeft + r.paddingRight + r.borderLeftWidth + r.borderRightWidth, vertPaddings: r.paddingTop + r.paddingBottom + r.borderTopWidth + r.borderBottomWidth, borderBox: r.boxSizing, innerWidth: r.width, innerHeight: r.height, outerWidth: r.width, outerHeight: r.height };
          return o.borderBox ? (o.innerWidth -= o.horPaddings, o.innerHeight -= o.vertPaddings) : (o.outerWidth += o.horPaddings, o.outerHeight += o.vertPaddings), o;
        }, e.prototype._getAutosizeMode = function(n) {
          var i = { x: false, y: false };
          return n === "xy" ? i.x = i.y = true : n === "y" || n === true ? i.y = true : n === "x" && (i.x = true), i;
        }, e.prototype.autosize = function(n) {
          var i = this._getAutosizeMode(n), a = this._getBoxStyles(this.$container), r = this.getContentSize(n), s = this.$container;
          i.x && (a.borderBox && (r.width += a.horPaddings), s.style.width = r.width + "px"), i.y && (a.borderBox && (r.height += a.vertPaddings), s.style.height = r.height + "px");
        }, e.prototype.getSize = function() {
          this._sizes = [];
          for (var n = 0, i = 0, a = 1e11, r = 0, s = 1e11, o = 0, l = 0; l < this.$cells.length; l++) {
            var d = this._sizes[l] = this.$cells[l].getSize();
            this.$cells[l].$config.hidden || (this._xLayout ? (!d.width && d.minWidth ? n += d.minWidth : n += d.width, a += d.maxWidth, i += d.minWidth, r = Math.max(r, d.height), s = Math.min(s, d.maxHeight), o = Math.max(o, d.minHeight)) : (!d.height && d.minHeight ? r += d.minHeight : r += d.height, s += d.maxHeight, o += d.minHeight, n = Math.max(n, d.width), a = Math.min(a, d.maxWidth), i = Math.max(i, d.minWidth)));
          }
          var c = t.prototype.getSize.call(this);
          return c.maxWidth >= 1e5 && (c.maxWidth = a), c.maxHeight >= 1e5 && (c.maxHeight = s), c.minWidth = c.minWidth != c.minWidth ? 0 : c.minWidth, c.minHeight = c.minHeight != c.minHeight ? 0 : c.minHeight, this._xLayout ? (c.minWidth += this.$config.margin * this.$cells.length || 0, c.minWidth += 2 * this.$config.padding || 0, c.minHeight += 2 * this.$config.padding || 0) : (c.minHeight += this.$config.margin * this.$cells.length || 0, c.minHeight += 2 * this.$config.padding || 0), c;
        }, e.prototype._calcFreeSpace = function(n, i, a) {
          var r = a ? i.minWidth : i.minHeight, s = i.maxWidth, o = n;
          return o ? (o > s && (o = s), o < r && (o = r), this._free -= o) : ((o = Math.floor(this._free / this._gravity * i.gravity)) > s && (o = s, this._free -= o, this._gravity -= i.gravity), o < r && (o = r, this._free -= o, this._gravity -= i.gravity)), o;
        }, e.prototype._calcSize = function(n, i, a) {
          var r = n, s = a ? i.minWidth : i.minHeight, o = a ? i.maxWidth : i.maxHeight;
          return r || (r = Math.floor(this._free / this._gravity * i.gravity)), r > o && (r = o), r < s && (r = s), r;
        }, e.prototype._configureBorders = function() {
          this.$root && this._setBorders([this._borders.left, this._borders.top, this._borders.right, this._borders.bottom], this);
          for (var n = this._xLayout ? this._borders.right : this._borders.bottom, i = this.$cells, a = i.length - 1, r = a; r >= 0; r--) if (!i[r].$config.hidden) {
            a = r;
            break;
          }
          for (r = 0; r < i.length; r++) if (!i[r].$config.hidden) {
            var s = r >= a, o = "";
            !s && i[r + 1] && i[r + 1].$config.view == "scrollbar" && (this._xLayout ? s = true : o = "gantt_layout_cell_border_transparent"), this._setBorders(s ? [] : [n, o], i[r]);
          }
        }, e.prototype._updateCellVisibility = function() {
          for (var n = this._visibleCells || {}, i = !this._visibleCells, a = {}, r = null, s = [], o = 0; o < this._sizes.length; o++) (r = this.$cells[o]).$config.hide_empty && s.push(r), !i && r.$config.hidden && n[r.$id] ? r._hide(true) : r.$config.hidden || n[r.$id] || r._hide(false), r.$config.hidden || (a[r.$id] = true);
          for (this._visibleCells = a, o = 0; o < s.length; o++) {
            var l = (r = s[o]).$cells, d = true;
            l.forEach(function(c) {
              c.$config.hidden || c.$config.resizer || (d = false);
            }), r.$config.hidden = d;
          }
        }, e.prototype.setSize = function(n, i) {
          this._configureBorders(), t.prototype.setSize.call(this, n, i), i = this.$lastSize.contentY, n = this.$lastSize.contentX;
          var a, r, s = this.$config.padding || 0;
          this.$view.style.padding = s + "px", this._gravity = 0, this._free = this._xLayout ? n : i, this._free -= 2 * s, this._updateCellVisibility();
          for (var o = 0; o < this._sizes.length; o++) if (!(a = this.$cells[o]).$config.hidden) {
            var l = this.$config.margin || 0;
            a.$name != "resizer" || l || (l = -1);
            var d = a.$view, c = this._xLayout ? "marginRight" : "marginBottom";
            o !== this.$cells.length - 1 && (d.style[c] = l + "px", this._free -= l), r = this._sizes[o], this._xLayout ? r.width || (this._gravity += r.gravity) : r.height || (this._gravity += r.gravity);
          }
          for (o = 0; o < this._sizes.length; o++) if (!(a = this.$cells[o]).$config.hidden) {
            var u = (r = this._sizes[o]).width, h = r.height;
            this._xLayout ? this._calcFreeSpace(u, r, true) : this._calcFreeSpace(h, r, false);
          }
          for (o = 0; o < this.$cells.length; o++) if (!(a = this.$cells[o]).$config.hidden) {
            r = this._sizes[o];
            var g = void 0, f = void 0;
            this._xLayout ? (g = this._calcSize(r.width, r, true), f = i - 2 * s) : (g = n - 2 * s, f = this._calcSize(r.height, r, false)), a.setSize(g, f);
          }
        }, e;
      }(It), _a = function(t) {
        function e(n, i, a) {
          for (var r = t.apply(this, arguments) || this, s = 0; s < r.$cells.length; s++) r.$cells[s].$config.hidden = s !== 0;
          return r.$cell = r.$cells[0], r.$name = "viewLayout", r;
        }
        return z(e, t), e.prototype.cell = function(n) {
          var i = t.prototype.cell.call(this, n);
          return i.$view || this.$fill(null, this), i;
        }, e.prototype.moveView = function(n) {
          var i = this.$view;
          this.$cell && (this.$cell.$config.hidden = true, i.removeChild(this.$cell.$view)), this.$cell = n, i.appendChild(n.$view);
        }, e.prototype.setSize = function(n, i) {
          It.prototype.setSize.call(this, n, i);
        }, e.prototype.setContentSize = function() {
          var n = this.$lastSize;
          this.$cell.setSize(n.contentX, n.contentY);
        }, e.prototype.getSize = function() {
          var n = t.prototype.getSize.call(this);
          if (this.$cell) {
            var i = this.$cell.getSize();
            if (this.$config.byMaxSize) for (var a = 0; a < this.$cells.length; a++) {
              var r = this.$cells[a].getSize();
              for (var s in i) i[s] = Math.max(i[s], r[s]);
            }
            for (var o in n) n[o] = n[o] || i[o];
            n.gravity = Math.max(n.gravity, i.gravity);
          }
          return n;
        }, e;
      }(un), ga = function(t) {
        function e(n, i, a) {
          var r = t.apply(this, arguments) || this;
          if (i.view) {
            i.id && (this.$id = at());
            var s = V(i);
            if (delete s.config, delete s.templates, this.$content = this.$factory.createView(i.view, this, s, this), !this.$content) return false;
          }
          return r.$name = "viewCell", r;
        }
        return z(e, t), e.prototype.destructor = function() {
          this.clear(), t.prototype.destructor.call(this);
        }, e.prototype.clear = function() {
          if (this.$initialized = false, this.$content) {
            var n = this.$content.unload || this.$content.destructor;
            n && n.call(this.$content);
          }
          t.prototype.clear.call(this);
        }, e.prototype.scrollTo = function(n, i) {
          this.$content && this.$content.scrollTo ? this.$content.scrollTo(n, i) : t.prototype.scrollTo.call(this, n, i);
        }, e.prototype._setContentSize = function(n, i) {
          var a = this._getBorderSizes();
          if (typeof n == "number") {
            var r = n + a.horizontal;
            this.$config.width = r;
          }
          if (typeof i == "number") {
            var s = i + a.vertical;
            this.$config.height = s;
          }
        }, e.prototype.setSize = function(n, i) {
          if (t.prototype.setSize.call(this, n, i), !this.$preResize && this.$content && !this.$initialized) {
            this.$initialized = true;
            var a = this.$view.childNodes[0], r = this.$view.childNodes[1];
            r || (r = a), this.$content.init(r);
          }
        }, e.prototype.setContentSize = function() {
          !this.$preResize && this.$content && this.$initialized && this.$content.setSize(this.$lastSize.contentX, this.$lastSize.contentY);
        }, e.prototype.getContentSize = function() {
          var n = t.prototype.getContentSize.call(this);
          if (this.$content && this.$initialized) {
            var i = this.$content.getSize();
            n.width = i.contentX === void 0 ? i.width : i.contentX, n.height = i.contentY === void 0 ? i.height : i.contentY;
          }
          var a = this._getBorderSizes();
          return n.width += a.horizontal, n.height += a.vertical, n;
        }, e;
      }(It), fa = function(t) {
        var e = ["altKey", "shiftKey", "metaKey"];
        function n(a, r, s, o) {
          var l = t.apply(this, arguments) || this;
          this.$config = N(r, { scroll: "x" }), l._scrollHorizontalHandler = R(l._scrollHorizontalHandler, l), l._scrollVerticalHandler = R(l._scrollVerticalHandler, l), l._outerScrollVerticalHandler = R(l._outerScrollVerticalHandler, l), l._outerScrollHorizontalHandler = R(l._outerScrollHorizontalHandler, l), l._mouseWheelHandler = R(l._mouseWheelHandler, l), this.$config.hidden = true;
          var d = o.config.scroll_size;
          return o.env.isIE && (d += 1), this._isHorizontal() ? (l.$config.height = d, l.$parent.$config.height = d) : (l.$config.width = d, l.$parent.$config.width = d), this.$config.scrollPosition = 0, l.$name = "scroller", l;
        }
        function i(a, r) {
          if (r.push(a), a.$cells) for (var s = 0; s < a.$cells.length; s++) i(a.$cells[s], r);
        }
        return z(n, t), n.prototype.init = function(a) {
          a.innerHTML = this.$toHTML(), this.$view = a.firstChild, this.$view || this.init(), this._isVertical() ? this._initVertical() : this._initHorizontal(), this._initMouseWheel(), this._initLinkedViews();
        }, n.prototype.$toHTML = function() {
          return "<div class='gantt_layout_cell " + (this._isHorizontal() ? "gantt_hor_scroll" : "gantt_ver_scroll") + "'><div style='" + (this._isHorizontal() ? "width:2000px" : "height:2000px") + "'></div></div>";
        }, n.prototype._getRootParent = function() {
          for (var a = this.$parent; a && a.$parent; ) a = a.$parent;
          if (a) return a;
        }, n.prototype._eachView = function() {
          var a = [];
          return i(this._getRootParent(), a), a;
        }, n.prototype._getLinkedViews = function() {
          for (var a = this._eachView(), r = [], s = 0; s < a.length; s++) a[s].$config && (this._isVertical() && a[s].$config.scrollY == this.$id || this._isHorizontal() && a[s].$config.scrollX == this.$id) && r.push(a[s]);
          return r;
        }, n.prototype._initHorizontal = function() {
          this.$scroll_hor = this.$view, this.$domEvents.attach(this.$view, "scroll", this._scrollHorizontalHandler);
        }, n.prototype._initLinkedViews = function() {
          for (var a = this._getLinkedViews(), r = this._isVertical() ? "gantt_layout_outer_scroll gantt_layout_outer_scroll_vertical" : "gantt_layout_outer_scroll gantt_layout_outer_scroll_horizontal", s = 0; s < a.length; s++) bt(a[s].$view || a[s].getNode(), r);
        }, n.prototype._initVertical = function() {
          this.$scroll_ver = this.$view, this.$domEvents.attach(this.$view, "scroll", this._scrollVerticalHandler);
        }, n.prototype._updateLinkedViews = function() {
        }, n.prototype._initMouseWheel = function() {
          ht.isFF ? this.$domEvents.attach(this._getRootParent().$view, "wheel", this._mouseWheelHandler, { passive: false }) : this.$domEvents.attach(this._getRootParent().$view, "mousewheel", this._mouseWheelHandler, { passive: false });
        }, n.prototype.scrollHorizontally = function(a) {
          if (!this._scrolling) {
            this._scrolling = true, this.$scroll_hor.scrollLeft = a, this.$config.codeScrollLeft = a, a = this.$scroll_hor.scrollLeft;
            for (var r = this._getLinkedViews(), s = 0; s < r.length; s++) r[s].scrollTo && r[s].scrollTo(a, void 0);
            var o = this.$config.scrollPosition;
            this.$config.scrollPosition = a, this.callEvent("onScroll", [o, a, this.$config.scroll]), this._scrolling = false;
          }
        }, n.prototype.scrollVertically = function(a) {
          if (!this._scrolling) {
            this._scrolling = true, this.$scroll_ver.scrollTop = a, a = this.$scroll_ver.scrollTop;
            for (var r = this._getLinkedViews(), s = 0; s < r.length; s++) r[s].scrollTo && r[s].scrollTo(void 0, a);
            var o = this.$config.scrollPosition;
            this.$config.scrollPosition = a, this.callEvent("onScroll", [o, a, this.$config.scroll]), this._scrolling = false;
          }
        }, n.prototype._isVertical = function() {
          return this.$config.scroll == "y";
        }, n.prototype._isHorizontal = function() {
          return this.$config.scroll == "x";
        }, n.prototype._scrollHorizontalHandler = function(a) {
          if (!this._isVertical() && !this._scrolling) {
            if (/* @__PURE__ */ new Date() - (this._wheel_time || 0) < 100) return true;
            var r = this.$scroll_hor.scrollLeft;
            this.scrollHorizontally(r), this._oldLeft = this.$scroll_hor.scrollLeft;
          }
        }, n.prototype._outerScrollHorizontalHandler = function(a) {
          this._isVertical();
        }, n.prototype.show = function() {
          this.$parent.show();
        }, n.prototype.hide = function() {
          this.$parent.hide();
        }, n.prototype._getScrollSize = function() {
          for (var a, r = 0, s = 0, o = this._isHorizontal(), l = this._getLinkedViews(), d = o ? "scrollWidth" : "scrollHeight", c = o ? "contentX" : "contentY", u = o ? "x" : "y", h = this._getScrollOffset(), g = 0; g < l.length; g++) if ((a = l[g]) && a.$content && a.$content.getSize && !a.$config.hidden) {
            var f, y = a.$content.getSize();
            if (f = y.hasOwnProperty(d) ? y[d] : y[c], h) y[c] > y[u] && y[c] > r && f > y[u] - h + 2 && (r = f + (o ? 0 : 2), s = y[u]);
            else {
              var v = Math.max(y[c] - f, 0);
              (f += v) > Math.max(y[u] - v, 0) && f > r && (r = f, s = y[u]);
            }
          }
          return { outerScroll: s, innerScroll: r };
        }, n.prototype.scroll = function(a) {
          this._isHorizontal() ? this.scrollHorizontally(a) : this.scrollVertically(a);
        }, n.prototype.getScrollState = function() {
          return { visible: this.isVisible(), direction: this.$config.scroll, size: this.$config.outerSize, scrollSize: this.$config.scrollSize || 0, position: this.$config.scrollPosition || 0 };
        }, n.prototype.setSize = function(a, r) {
          t.prototype.setSize.apply(this, arguments);
          var s = this._getScrollSize(), o = (this._isVertical() ? r : a) - this._getScrollOffset() + (this._isHorizontal() ? 1 : 0);
          s.innerScroll && o > s.outerScroll && (s.innerScroll += o - s.outerScroll), this.$config.scrollSize = s.innerScroll, this.$config.width = a, this.$config.height = r, this._setScrollSize(s.innerScroll);
        }, n.prototype.isVisible = function() {
          return !(!this.$parent || !this.$parent.$view.parentNode);
        }, n.prototype.shouldShow = function() {
          var a = this._getScrollSize();
          return !(!a.innerScroll && this.$parent && this.$parent.$view.parentNode) && !(!a.innerScroll || this.$parent && this.$parent.$view.parentNode);
        }, n.prototype.shouldHide = function() {
          return !(this._getScrollSize().innerScroll || !this.$parent || !this.$parent.$view.parentNode);
        }, n.prototype.toggleVisibility = function() {
          this.shouldHide() ? this.hide() : this.shouldShow() && this.show();
        }, n.prototype._getScaleOffset = function(a) {
          var r = 0;
          return !a || a.$config.view != "timeline" && a.$config.view != "grid" || (r = a.$content.$getConfig().scale_height), r;
        }, n.prototype._getScrollOffset = function() {
          var a = 0;
          if (this._isVertical()) {
            var r = this.$parent.$parent;
            a = Math.max(this._getScaleOffset(r.getPrevSibling(this.$parent.$id)), this._getScaleOffset(r.getNextSibling(this.$parent.$id)));
          } else for (var s = this._getLinkedViews(), o = 0; o < s.length; o++) {
            var l = s[o].$parent.$cells, d = l[l.length - 1];
            if (d && d.$config.view == "scrollbar" && d.$config.hidden === false) {
              a = d.$config.width;
              break;
            }
          }
          return a || 0;
        }, n.prototype._setScrollSize = function(a) {
          var r = this._isHorizontal() ? "width" : "height", s = this._isHorizontal() ? this.$scroll_hor : this.$scroll_ver, o = this._getScrollOffset(), l = s.firstChild;
          o ? this._isVertical() ? (this.$config.outerSize = this.$config.height - o + 3, s.style.height = this.$config.outerSize + "px", s.style.top = o - 1 + "px", bt(s, this.$parent._borders.top), bt(s.parentNode, "gantt_task_vscroll")) : (this.$config.outerSize = this.$config.width - o + 1, s.style.width = this.$config.outerSize + "px") : (s.style.top = "auto", Ht(s, this.$parent._borders.top), Ht(s.parentNode, "gantt_task_vscroll"), this.$config.outerSize = this.$config.height), l.style[r] = a + "px";
        }, n.prototype._scrollVerticalHandler = function(a) {
          if (!this._scrollHorizontalHandler() && !this._scrolling) {
            var r = this.$scroll_ver.scrollTop;
            r != this._oldTop && (this.scrollVertically(r), this._oldTop = this.$scroll_ver.scrollTop);
          }
        }, n.prototype._outerScrollVerticalHandler = function(a) {
          this._scrollHorizontalHandler();
        }, n.prototype._checkWheelTarget = function(a) {
          for (var r = this._getLinkedViews().concat(this), s = 0; s < r.length; s++) if (G(a, r[s].$view)) return true;
          return false;
        }, n.prototype._mouseWheelHandler = function(a) {
          var r = a.target || a.srcElement;
          if (this._checkWheelTarget(r)) {
            this._wheel_time = /* @__PURE__ */ new Date();
            var s = {}, o = { x: 1, y: 1 }, l = this.$gantt.config.wheel_scroll_sensitivity;
            typeof l == "number" && l ? o = { x: l, y: l } : {}.toString.apply(l) == "[object Object]" && (o = { x: l.x, y: l.y });
            var d = ht.isFF, c = d ? a.deltaX : a.wheelDeltaX, u = d ? a.deltaY : a.wheelDelta, h = -20;
            d && (h = a.deltaMode !== 0 ? -40 : -10);
            var g = d ? c * h * o.x : 2 * c * o.x, f = d ? u * h * o.y : u * o.y, y = this.$gantt.config.horizontal_scroll_key;
            if (y !== false && e.indexOf(y) >= 0 && (!a[y] || a.deltaX || a.wheelDeltaX || (g = 2 * f, f = 0)), g && Math.abs(g) > Math.abs(f)) {
              if (this._isVertical()) return;
              if (s.x || !this.$scroll_hor || !this.$scroll_hor.offsetWidth) return true;
              var v = g / -40, b = this._oldLeft, _ = b + 30 * v;
              if (this.scrollHorizontally(_), this.$scroll_hor.scrollLeft = _, b == this.$scroll_hor.scrollLeft) return true;
              this._oldLeft = this.$scroll_hor.scrollLeft;
            } else {
              if (this._isHorizontal()) return;
              if (s.y || !this.$scroll_ver || !this.$scroll_ver.offsetHeight) return true;
              v = f / -40, f === void 0 && (v = a.detail);
              var m = this._oldTop, p = this.$scroll_ver.scrollTop + 30 * v;
              if (this.scrollVertically(p), this.$scroll_ver.scrollTop = p, m == this.$scroll_ver.scrollTop) return true;
              this._oldTop = this.$scroll_ver.scrollTop;
            }
            return a.preventDefault && a.preventDefault(), a.cancelBubble = true, false;
          }
        }, n;
      }(It);
      function hn(t) {
        var e = {}, n = {}, i = null, a = -1, r = null, s = /* @__PURE__ */ function(o) {
          var l = -1, d = -1;
          return { resetCache: function() {
            l = -1, d = -1;
          }, _getRowHeight: function() {
            return l === -1 && (l = o.$getConfig().row_height), l;
          }, _refreshState: function() {
            this.resetCache(), d = true;
            var c = o.$config.rowStore;
            if (c) for (var u = this._getRowHeight(), h = 0; h < c.fullOrder.length; h++) {
              var g = c.getItem(c.fullOrder[h]);
              if (g && g.row_height && g.row_height !== u) {
                d = false;
                break;
              }
            }
          }, canUseSimpleCalculation: function() {
            return d === -1 && this._refreshState(), d;
          }, getRowTop: function(c) {
            return o.$config.rowStore ? c * this._getRowHeight() : 0;
          }, getItemHeight: function(c) {
            return this._getRowHeight();
          }, getTotalHeight: function() {
            return o.$config.rowStore ? o.$config.rowStore.countVisible() * this._getRowHeight() : 0;
          }, getItemIndexByTopPosition: function(c) {
            return o.$config.rowStore ? Math.floor(c / this._getRowHeight()) : 0;
          } };
        }(t);
        return { _resetTopPositionHeight: function() {
          e = {}, n = {}, s.resetCache();
        }, _resetHeight: function() {
          var o = this.$config.rowStore, l = this.getCacheStateTotalHeight(o);
          r ? this.shouldClearHeightCache(r, l) && (r = l, i = null) : r = l, a = -1, s.resetCache();
        }, getRowTop: function(o) {
          if (s.canUseSimpleCalculation()) return s.getRowTop(o);
          var l = this.$config.rowStore;
          if (!l) return 0;
          if (n[o] !== void 0) return n[o];
          for (var d = l.getIndexRange(), c = 0, u = 0, h = 0; h < d.length; h++) n[h] = c, c += this.getItemHeight(d[h].id), h < o && (u = c);
          return u;
        }, getItemTop: function(o) {
          if (this.$config.rowStore) {
            if (e[o] !== void 0) return e[o];
            var l = this.$config.rowStore;
            if (!l) return 0;
            var d = l.getIndexById(o);
            if (d === -1 && l.getParent && l.exists(o)) {
              var c = l.getParent(o);
              if (l.exists(c)) {
                var u = l.getItem(c);
                if (this.$gantt.isSplitTask(u)) return this.getItemTop(c);
              }
            }
            return e[o] = this.getRowTop(d), e[o];
          }
          return 0;
        }, getItemHeight: function(o) {
          if (s.canUseSimpleCalculation()) return s.getItemHeight(o);
          if (!i && this.$config.rowStore && this._fillHeightCache(this.$config.rowStore), i[o] !== void 0) return i[o];
          var l = this.$getConfig().row_height;
          if (this.$config.rowStore) {
            var d = this.$config.rowStore;
            if (!d) return l;
            var c = d.getItem(o);
            return i[o] = c && c.row_height || l;
          }
          return l;
        }, _fillHeightCache: function(o) {
          if (o) {
            i = {};
            var l = this.$getConfig().row_height;
            o.eachItem(function(d) {
              return i[d.id] = d && d.row_height || l;
            });
          }
        }, getCacheStateTotalHeight: function(o) {
          var l = this.$getConfig().row_height, d = {}, c = [], u = 0;
          return o && o.eachItem(function(h) {
            c.push(h), d[h.id] = h.row_height, u += h.row_height || l;
          }), { globalHeight: l, items: c, count: c.length, sumHeight: u };
        }, shouldClearHeightCache: function(o, l) {
          if (o.count != l.count || o.globalHeight != l.globalHeight || o.sumHeight != l.sumHeight) return true;
          for (var d in o.items) {
            var c = l.items[d];
            if (c !== void 0 && c != o.items[d]) return true;
          }
          return false;
        }, getTotalHeight: function() {
          if (s.canUseSimpleCalculation()) return s.getTotalHeight();
          if (a != -1) return a;
          if (this.$config.rowStore) {
            var o = this.$config.rowStore;
            this._fillHeightCache(o);
            var l = this.getItemHeight.bind(this), d = o.getVisibleItems(), c = 0;
            return d.forEach(function(u) {
              c += l(u.id);
            }), a = c, c;
          }
          return 0;
        }, getItemIndexByTopPosition: function(o) {
          if (this.$config.rowStore) {
            if (s.canUseSimpleCalculation()) return s.getItemIndexByTopPosition(o);
            for (var l = this.$config.rowStore, d = 0; d < l.countVisible(); d++) {
              var c = this.getRowTop(d), u = this.getRowTop(d + 1);
              if (!u) {
                var h = l.getIdByIndex(d);
                u = c + this.getItemHeight(h);
              }
              if (o >= c && o < u) return d;
            }
            return l.countVisible() + 2;
          }
          return 0;
        } };
      }
      const pa = function() {
        return { render: function() {
        }, destroy: function() {
        } };
      };
      var Vt = function(t, e, n, i) {
        this.$config = N({}, e || {}), this.$scaleHelper = new oe(i), this.$gantt = i, this._posFromDateCache = {}, this._timelineDragScroll = null, N(this, hn(this)), nt(this);
      };
      Vt.prototype = { init: function(t) {
        t.innerHTML += "<div class='gantt_task' style='width:inherit;height:inherit;'></div>", this.$task = t.childNodes[0], this.$task.innerHTML = "<div class='gantt_task_scale'></div><div class='gantt_data_area'></div>", this.$task_scale = this.$task.childNodes[0], this.$task_data = this.$task.childNodes[1], this.$task_data.innerHTML = "<div class='gantt_task_bg'></div><div class='gantt_task_baselines'></div><div class='gantt_links_area'></div><div class='gantt_bars_area'></div><div class='gantt_task_constraints'></div><div class='gantt_task_deadlines'></div>", this.$task_bg = this.$task_data.childNodes[0], this.$task_baselines = this.$task_data.childNodes[1], this.$task_links = this.$task_data.childNodes[2], this.$task_bars = this.$task_data.childNodes[3], this.$task_constraints = this.$task_data.childNodes[4], this.$task_deadlines = this.$task_data.childNodes[5], this._tasks = { col_width: 0, width: [], full_width: 0, trace_x: [], rendered: {} };
        var e = this.$getConfig(), n = e[this.$config.bind + "_attribute"], i = e[this.$config.bindLinks + "_attribute"];
        !n && this.$config.bind && (n = "data-" + this.$config.bind + "-id"), !i && this.$config.bindLinks && (i = "data-" + this.$config.bindLinks + "-id"), this.$config.item_attribute = n || null, this.$config.link_attribute = i || null;
        var a = this._createLayerConfig();
        this.$config.layers || (this.$config.layers = a.tasks), this.$config.linkLayers || (this.$config.linkLayers = a.links), this._attachLayers(this.$gantt), this.callEvent("onReady", []), this.$gantt.ext.dragTimeline && (this._timelineDragScroll = this.$gantt.ext.dragTimeline.create(), this._timelineDragScroll.attach(this));
      }, setSize: function(t, e) {
        var n = this.$getConfig();
        if (1 * t === t && (this.$config.width = t), 1 * e === e) {
          this.$config.height = e;
          var i = Math.max(this.$config.height - n.scale_height);
          this.$task_data.style.height = i + "px";
        }
        this.refresh(), this.$task_bg.style.backgroundImage = "", n.smart_rendering && this.$config.rowStore ? this.$task_bg.style.height = this.getTotalHeight() + "px" : this.$task_bg.style.height = "";
        for (var a = this._tasks, r = this.$task_data.childNodes, s = 0, o = r.length; s < o; s++) {
          var l = r[s];
          l.hasAttribute("data-layer") && l.style && (l.style.width = a.full_width + "px");
        }
      }, isVisible: function() {
        return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$task.offsetWidth;
      }, getSize: function() {
        var t = this.$getConfig(), e = this.$config.rowStore ? this.getTotalHeight() : 0, n = this.isVisible() ? this._tasks.full_width : 0;
        return { x: this.isVisible() ? this.$config.width : 0, y: this.isVisible() ? this.$config.height : 0, contentX: this.isVisible() ? n : 0, contentY: this.isVisible() ? t.scale_height + e : 0, scrollHeight: this.isVisible() ? e : 0, scrollWidth: this.isVisible() ? n : 0 };
      }, scrollTo: function(t, e) {
        if (this.isVisible()) {
          var n = false;
          this.$config.scrollTop = this.$config.scrollTop || 0, this.$config.scrollLeft = this.$config.scrollLeft || 0, 1 * e === e && (this.$config.scrollTop = e, this.$task_data.scrollTop = this.$config.scrollTop, n = true), 1 * t === t && (this.$task.scrollLeft = t, this.$config.scrollLeft = this.$task.scrollLeft, this._refreshScales(), n = true), n && this.callEvent("onScroll", [this.$config.scrollLeft, this.$config.scrollTop]);
        }
      }, _refreshScales: function() {
        if (this.isVisible() && this.$getConfig().smart_scales) {
          var t = this.getViewPort(), e = this._scales;
          this.$task_scale.innerHTML = this._getScaleChunkHtml(e, t.x, t.x_end);
        }
      }, getViewPort: function() {
        var t = this.$config.scrollLeft || 0, e = this.$config.scrollTop || 0, n = this.$config.height || 0, i = this.$config.width || 0;
        return { y: e, y_end: e + n, x: t, x_end: t + i, height: n, width: i };
      }, _createLayerConfig: function() {
        var t = this, e = function() {
          return t.isVisible();
        };
        this.$gantt;
        var n = [{ expose: true, renderer: this.$gantt.$ui.layers.taskBar(), container: this.$task_bars, filter: [e, function(i, a) {
          return !a.hide_bar;
        }] }];
        return n.push({ renderer: this.$gantt.$ui.layers.taskBg(), container: this.$task_bg, filter: [e] }), { tasks: n, links: [{ expose: true, renderer: this.$gantt.$ui.layers.link(), container: this.$task_links, filter: [e] }] };
      }, _attachLayers: function(t) {
        this._taskLayers = [], this._linkLayers = [];
        var e = this, n = this.$gantt.$services.getService("layers");
        if (this.$config.bind) {
          this._bindStore();
          var i = n.getDataRender(this.$config.bind);
          i || (i = n.createDataRender({ name: this.$config.bind, defaultContainer: function() {
            return e.$task_data;
          } })), i.container = function() {
            return e.$task_data;
          };
          for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {
            typeof (d = a[r]) == "string" && (d = this.$gantt.$ui.layers[d]()), (typeof d == "function" || d && d.render && d.update) && (d = { renderer: d }), d.view = this;
            var s = i.addLayer(d);
            this._taskLayers.push(s), d.expose && (this._taskRenderer = i.getLayer(s));
          }
          this._initStaticBackgroundRender();
        }
        if (this.$config.bindLinks) {
          e.$config.linkStore = e.$gantt.getDatastore(e.$config.bindLinks);
          var o = n.getDataRender(this.$config.bindLinks);
          o || (o = n.createDataRender({ name: this.$config.bindLinks, defaultContainer: function() {
            return e.$task_data;
          } }));
          var l = this.$config.linkLayers;
          for (r = 0; l && r < l.length; r++) {
            var d;
            typeof d == "string" && (d = this.$gantt.$ui.layers[d]()), (d = l[r]).view = this;
            var c = o.addLayer(d);
            this._taskLayers.push(c), l[r].expose && (this._linkRenderer = o.getLayer(c));
          }
        }
      }, _initStaticBackgroundRender: function() {
        var t = this, e = pa(), n = t.$config.rowStore;
        n && (this._staticBgHandler = n.attachEvent("onStoreUpdated", function(i, a, r) {
          if (i === null && t.isVisible()) {
            var s = t.$getConfig();
            if (s.static_background || s.timeline_placeholder) {
              var o = t.$gantt.getDatastore(t.$config.bind), l = t.$task_bg_static;
              if (l || ((l = document.createElement("div")).className = "gantt_task_bg", t.$task_bg_static = l, t.$task_bg.nextSibling ? t.$task_data.insertBefore(l, t.$task_bg.nextSibling) : t.$task_data.appendChild(l)), o) {
                var d = t.getTotalHeight();
                s.timeline_placeholder && (d = s.timeline_placeholder.height || t.$task_data.offsetHeight || 99999), e.render(l, s, t.getScale(), d, t.getItemHeight(a ? a.id : null));
              }
            } else s.static_background && t.$task_bg_static && t.$task_bg_static.parentNode && t.$task_bg_static.parentNode.removeChild(t.$task_bg_static);
          }
        }), this.attachEvent("onDestroy", function() {
        }), this._initStaticBackgroundRender = function() {
        });
      }, _clearLayers: function(t) {
        var e = this.$gantt.$services.getService("layers"), n = e.getDataRender(this.$config.bind), i = e.getDataRender(this.$config.bindLinks);
        if (this._taskLayers) for (var a = 0; a < this._taskLayers.length; a++) n.removeLayer(this._taskLayers[a]);
        if (this._linkLayers) for (a = 0; a < this._linkLayers.length; a++) i.removeLayer(this._linkLayers[a]);
        this._linkLayers = [], this._taskLayers = [];
      }, _render_tasks_scales: function() {
        var t = this.$getConfig(), e = "", n = 0, i = 0, a = this.$gantt.getState();
        if (this.isVisible()) {
          var r = this.$scaleHelper, s = this._getScales();
          i = t.scale_height;
          var o = this.$config.width;
          t.autosize != "x" && t.autosize != "xy" || (o = Math.max(t.autosize_min_width, 0));
          var l = r.prepareConfigs(s, t.min_column_width, o, i - 1, a.min_date, a.max_date, t.rtl), d = this._tasks = l[l.length - 1];
          this._scales = l, this._posFromDateCache = {}, e = this._getScaleChunkHtml(l, 0, this.$config.width), n = d.full_width + "px", i += "px";
        }
        this.$task_scale.style.height = i, this.$task_data.style.width = this.$task_scale.style.width = n, this.$task_scale.innerHTML = e;
      }, _getScaleChunkHtml: function(t, e, n) {
        for (var i = [], a = this.$gantt.templates.scale_row_class, r = 0; r < t.length; r++) {
          var s = "gantt_scale_line", o = a(t[r]);
          o && (s += " " + o), i.push('<div class="' + s + '" style="height:' + t[r].height + "px;position:relative;line-height:" + t[r].height + 'px">' + this._prepareScaleHtml(t[r], e, n, r) + "</div>");
        }
        return i.join("");
      }, _prepareScaleHtml: function(t, e, n, i) {
        var a = this.$getConfig(), r = this.$gantt.templates, s = [], o = null, l = null, d = t.format || t.template || t.date;
        typeof d == "string" && (d = this.$gantt.date.date_to_str(d));
        var c = 0, u = t.count;
        !a.smart_scales || isNaN(e) || isNaN(n) || (c = Tt(t.left, e), u = Tt(t.left, n) + 1), l = t.css || function() {
        }, !t.css && a.inherit_scale_class && (l = r.scale_cell_class);
        for (var h = c; h < u && t.trace_x[h]; h++) {
          o = new Date(t.trace_x[h]);
          var g = d.call(this, o), f = t.width[h];
          t.height;
          var y = t.left[h], v = "", b = "", _ = "";
          if (f) {
            v = "width:" + f + "px;" + (a.smart_scales ? "position:absolute;left:" + y + "px" : "");
            const p = this.getViewPort(), k = (a.scales[i] || {}).sticky;
            let $ = "";
            const w = 70;
            if (k !== false && f > w || k === true) {
              if (y < p.x && y + f / 2 - w / 2 < p.x) $ = ` style='position:absolute;left: ${p.x - y + 10}px;' `;
              else if (y + f / 2 + w / 2 > p.x_end && f > w) {
                let x = p.x_end - y - 10, S = "-100%";
                x < w && (x = w, S = `-${x}px`), $ = ` style='position:absolute;left: ${x}px;transform: translate(${S},0);' `;
              }
            }
            _ = "gantt_scale_cell" + (h == t.count - 1 ? " gantt_last_cell" : ""), (b = l.call(this, o)) && (_ += " " + b);
            var m = `<div class='${_}' ${this.$gantt._waiAria.getTimelineCellAttr(g)} style='${v}'><span ${$}>${g}</span></div>`;
            s.push(m);
          }
        }
        return s.join("");
      }, dateFromPos: function(t) {
        var e = this._tasks;
        if (t < 0 || t > e.full_width || !e.full_width) return null;
        var n = Tt(this._tasks.left, t), i = this._tasks.left[n], a = e.width[n] || e.col_width, r = 0;
        a && (r = (t - i) / a, e.rtl && (r = 1 - r));
        var s = 0;
        return r && (s = this._getColumnDuration(e, e.trace_x[n])), new Date(e.trace_x[n].valueOf() + Math.round(r * s));
      }, posFromDate: function(t) {
        if (!this.isVisible() || !t) return 0;
        var e = String(t.valueOf());
        if (this._posFromDateCache[e] !== void 0) return this._posFromDateCache[e];
        var n = this.columnIndexByDate(t);
        this.$gantt.assert(n >= 0, "Invalid day index");
        var i = Math.floor(n), a = n % 1, r = this._tasks.left[Math.min(i, this._tasks.width.length - 1)];
        i == this._tasks.width.length && (r += this._tasks.width[this._tasks.width.length - 1]), a && (i < this._tasks.width.length ? r += this._tasks.width[i] * (a % 1) : r += 1);
        var s = Math.round(r);
        return this._posFromDateCache[e] = s, Math.round(s);
      }, _getNextVisibleColumn: function(t, e, n) {
        for (var i = +e[t], a = t; n[i]; ) i = +e[++a];
        return a;
      }, _getPrevVisibleColumn: function(t, e, n) {
        for (var i = +e[t], a = t; n[i]; ) i = +e[--a];
        return a;
      }, _getClosestVisibleColumn: function(t, e, n) {
        var i = this._getNextVisibleColumn(t, e, n);
        return e[i] || (i = this._getPrevVisibleColumn(t, e, n)), i;
      }, columnIndexByDate: function(t) {
        var e = new Date(t).valueOf(), n = this._tasks.trace_x_ascending, i = this._tasks.ignore_x, a = this.$gantt.getState();
        if (e <= a.min_date) return this._tasks.rtl ? n.length : 0;
        if (e >= a.max_date) return this._tasks.rtl ? 0 : n.length;
        var r = Tt(n, e), s = this._getClosestVisibleColumn(r, n, i), o = n[s], l = this._tasks.trace_index_transition;
        if (!o) return l ? l[0] : 0;
        var d = (t - n[s]) / this._getColumnDuration(this._tasks, n[s]);
        return l ? l[s] + (1 - d) : s + d;
      }, getItemPosition: function(t, e, n) {
        var i, a, r;
        let s = e || t.start_date || t.$auto_start_date, o = n || t.end_date || t.$auto_end_date;
        return this._tasks.rtl ? (a = this.posFromDate(s), i = this.posFromDate(o)) : (i = this.posFromDate(s), a = this.posFromDate(o)), r = Math.max(a - i, 0), { left: i, top: this.getItemTop(t.id), height: this.getBarHeight(t.id), width: r, rowHeight: this.getItemHeight(t.id) };
      }, getBarHeight: function(t, e) {
        var n = this.$getConfig(), i = this.$config.rowStore.getItem(t), a = i.task_height || i.bar_height || n.bar_height || n.task_height, r = this.getItemHeight(t);
        return a == "full" && (a = r - (n.bar_height_padding || 3)), a = Math.min(a, r), e && (a = Math.round(a / Math.sqrt(2))), Math.max(a, 0);
      }, getScale: function() {
        return this._tasks;
      }, _getScales: function() {
        var t = this.$getConfig(), e = this.$scaleHelper, n = [e.primaryScale(t)].concat(e.getSubScales(t));
        return e.sortScales(n), n;
      }, _getColumnDuration: function(t, e) {
        return this.$gantt.date.add(e, t.step, t.unit) - e;
      }, _bindStore: function() {
        if (this.$config.bind) {
          var t = this.$gantt.getDatastore(this.$config.bind);
          if (this.$config.rowStore = t, t && !t._timelineCacheAttached) {
            var e = this;
            t._timelineCacheAttached = t.attachEvent("onBeforeFilter", function() {
              e._resetTopPositionHeight();
            });
          }
        }
      }, _unbindStore: function() {
        if (this.$config.bind) {
          var t = this.$gantt.getDatastore(this.$config.bind);
          t && t._timelineCacheAttached && (t.detachEvent(t._timelineCacheAttached), t._timelineCacheAttached = false);
        }
      }, refresh: function() {
        this._bindStore(), this.$config.bindLinks && (this.$config.linkStore = this.$gantt.getDatastore(this.$config.bindLinks)), this._resetTopPositionHeight(), this._resetHeight(), this._initStaticBackgroundRender(), this._render_tasks_scales();
      }, destructor: function() {
        var t = this.$gantt;
        this._clearLayers(t), this._unbindStore(), this.$task = null, this.$task_scale = null, this.$task_data = null, this.$task_bg = null, this.$task_links = null, this.$task_bars = null, this.$gantt = null, this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler), this.$config.rowStore = null), this.$config.linkStore && (this.$config.linkStore = null), this._timelineDragScroll && (this._timelineDragScroll.destructor(), this._timelineDragScroll = null), this.callEvent("onDestroy", []), this.detachAllEvents();
      } };
      class ma {
        constructor(e) {
          this._scrollOrder = 0;
          const { gantt: n, grid: i, dnd: a, getCurrentX: r } = e;
          this.$gantt = n, this.$grid = i, this._dnd = a, this.getCurrentX = r, this._scrollView = this.$gantt.$ui.getView(this.$grid.$config.scrollX), this.attachEvents();
        }
        attachEvents() {
          this.isScrollable() && (this._dnd.attachEvent("onDragMove", (e, n) => {
            const i = this.$grid.$grid.getBoundingClientRect(), a = i.right, r = i.left, s = this.getCurrentX(n.clientX);
            return s >= a - 20 && (this.autoscrollRight(), this.autoscrollStart()), s <= r + 20 && (this.autoscrollLeft(), this.autoscrollStart()), s < a - 20 && s > r + 20 && this.autoscrollStop(), true;
          }), this._dnd.attachEvent("onDragEnd", () => {
            this.autoscrollStop();
          }));
        }
        autoscrollStart() {
          if (this._scrollOrder === 0) return;
          const e = 10 * this._scrollOrder, n = this._scrollView.getScrollState();
          this._scrollView.scrollTo(n.position + e), setTimeout(() => {
            this.autoscrollStart();
          }, 50);
        }
        autoscrollRight() {
          this._scrollOrder = 1;
        }
        autoscrollLeft() {
          this._scrollOrder = -1;
        }
        autoscrollStop() {
          this._scrollOrder = 0;
        }
        getCorrection() {
          return this.isScrollable() ? this._scrollView.getScrollState().position : 0;
        }
        isScrollable() {
          return !!this.$grid.$config.scrollable;
        }
      }
      const _n = "data-column-id";
      class va {
        constructor(e, n) {
          this._targetMarker = null, this.calculateCurrentPosition = (i) => {
            const a = this.$grid.$grid.getBoundingClientRect(), r = a.right, s = a.left;
            let o = i;
            return o > r && (o = r), o < s && (o = s), o;
          }, this.$gantt = e, this.$grid = n;
        }
        init() {
          const e = this.$gantt.$services.getService("dnd");
          this._dnd = new e(this.$grid.$grid_scale, { updates_per_second: 60 }), this._scrollableGrid = new ma({ gantt: this.$gantt, grid: this.$grid, dnd: this._dnd, getCurrentX: this.calculateCurrentPosition }), this.attachEvents();
        }
        attachEvents() {
          this._dnd.attachEvent("onBeforeDragStart", (e, n) => {
            if (this._draggedCell = this.$gantt.utils.dom.closest(n.target, ".gantt_grid_head_cell"), !this._draggedCell) return;
            const i = this.$grid.$getConfig().columns, a = this._draggedCell.getAttribute(_n);
            let r, s;
            return i.map(function(o, l) {
              o.name === a && (r = o, s = l);
            }), this.$grid.callEvent("onBeforeColumnDragStart", [{ draggedColumn: r, draggedIndex: s }]) !== false && !(!this._draggedCell || !r) && (this._gridConfig = this.$grid.$getConfig(), this._originAutoscroll = this.$gantt.config.autoscroll, this.$gantt.config.autoscroll = false, true);
          }), this._dnd.attachEvent("onAfterDragStart", (e, n) => {
            this._draggedCell && (this._dnd.config.column = this._draggedCell.getAttribute(_n), this._dnd.config.marker.innerHTML = this._draggedCell.outerHTML, this._dnd.config.marker.classList.add("gantt_column_drag_marker"), this._dnd.config.marker.style.height = this._gridConfig.scale_height + "px", this._dnd.config.marker.style.lineHeight = this._gridConfig.scale_height + "px", this._draggedCell.classList.add("gantt_grid_head_cell_dragged"));
          }), this._dnd.attachEvent("onDragMove", (e, n) => {
            if (!this._draggedCell) return;
            this._dragX = n.clientX;
            const i = this.calculateCurrentPosition(n.clientX), a = this.findColumnsIndexes(), r = a.targetIndex, s = a.draggedIndex, o = this.$grid.$getConfig().columns, l = o[s], d = o[r];
            return this.$grid.callEvent("onColumnDragMove", [{ draggedColumn: l, targetColumn: d, draggedIndex: s, targetIndex: r }]) === false ? (this.cleanTargetMarker(), false) : (this.setMarkerPosition(i), this.drawTargetMarker(a), true);
          }), this._dnd.attachEvent("onDragEnd", () => {
            this._draggedCell && (this.$gantt.config.autoscroll = this._originAutoscroll, this._draggedCell.classList.remove("gantt_grid_head_cell_dragged"), this.cleanTargetMarker(), this.reorderColumns());
          });
        }
        reorderColumns() {
          const { targetIndex: e, draggedIndex: n } = this.findColumnsIndexes(), i = this.$grid.$getConfig().columns, a = i[n], r = i[e];
          this.$grid.callEvent("onBeforeColumnReorder", [{ draggedColumn: a, targetColumn: r, draggedIndex: n, targetIndex: e }]) !== false && e !== n && (i.splice(n, 1), i.splice(e, 0, a), this.$gantt.render(), this.$grid.callEvent("onAfterColumnReorder", [{ draggedColumn: a, targetColumn: r, draggedIndex: n, targetIndex: e }]));
        }
        findColumnsIndexes() {
          const e = this._dnd.config.column, n = this.$grid.$getConfig().columns;
          let i, a, r, s;
          const o = { startX: 0, endX: 0 };
          let l, d = 0, c = n.length - 1, u = (f, y) => f <= y, h = (f) => ++f;
          this.$gantt.config.rtl && (d = n.length - 1, c = 0, u = (f, y) => f >= y, h = (f) => --f);
          const g = this._dragX - this.$grid.$grid.getBoundingClientRect().left + this._scrollableGrid.getCorrection();
          for (let f = d; u(f, c) && (i === void 0 || a === void 0); f = h(f)) n[f].hide || (o.startX = o.endX, o.endX += n[f].width, g >= o.startX && (g <= o.endX || !u(h(f), c)) && (i = f, r = o.startX, s = o.endX, l = (g - o.startX) / (o.endX - o.startX)), e === n[f].name && (a = f));
          return { targetIndex: i, draggedIndex: a, xBefore: r, xAfter: s, columnRelativePos: l };
        }
        setMarkerPosition(e, n = 10) {
          const { marker: i } = this._dnd.config, a = this._dnd._obj.getBoundingClientRect();
          i.style.top = `${a.y + n}px`, i.style.left = `${e}px`;
        }
        drawTargetMarker({ targetIndex: e, draggedIndex: n, xBefore: i, xAfter: a, columnRelativePos: r }) {
          let s;
          this._targetMarker || (this._targetMarker = document.createElement("div"), bt(this._targetMarker, "gantt_grid_target_marker"), this._targetMarker.style.display = "none", this._targetMarker.style.height = `${this._gridConfig.scale_height}px`), this._targetMarker.parentNode || this.$grid.$grid_scale.appendChild(this._targetMarker), s = e > n ? a : e < n ? i : r > 0.5 ? a : i, this._targetMarker.style.left = `${s}px`, this._targetMarker.style.display = "block";
        }
        cleanTargetMarker() {
          this._targetMarker && this._targetMarker.parentNode && this.$grid.$grid_scale.removeChild(this._targetMarker), this._targetMarker = null;
        }
      }
      function me(t) {
        var e = [];
        return { delegate: function(n, i, a, r) {
          e.push([n, i, a, r]), t.$services.getService("mouseEvents").delegate(n, i, a, r);
        }, destructor: function() {
          for (var n = t.$services.getService("mouseEvents"), i = 0; i < e.length; i++) {
            var a = e[i];
            n.detach(a[0], a[1], a[2], a[3]);
          }
          e = [];
        } };
      }
      var ve = function(t, e, n, i) {
        this.$config = N({}, e || {}), this.$gantt = i, this.$parent = t, nt(this), this.$state = {}, N(this, hn(this));
      };
      ve.prototype = { init: function(t) {
        var e = this.$gantt, n = e._waiAria.gridAttrString(), i = e._waiAria.gridDataAttrString(), a = this.$getConfig(), r = a.reorder_grid_columns || false;
        this.$config.reorder_grid_columns !== void 0 && (r = this.$config.reorder_grid_columns), t.innerHTML = "<div class='gantt_grid' style='height:inherit;width:inherit;' " + n + "></div>", this.$grid = t.childNodes[0], this.$grid.innerHTML = "<div class='gantt_grid_scale' " + e._waiAria.gridScaleRowAttrString() + "></div><div class='gantt_grid_data' " + i + "></div>", this.$grid_scale = this.$grid.childNodes[0], this.$grid_data = this.$grid.childNodes[1];
        var s = a[this.$config.bind + "_attribute"];
        if (!s && this.$config.bind && (s = "data-" + this.$config.bind + "-id"), this.$config.item_attribute = s || null, !this.$config.layers) {
          var o = this._createLayerConfig();
          this.$config.layers = o;
        }
        var l = { init: function() {
        }, doOnRender: function() {
        } };
        this._renderHeaderResizers = l.doOnRender, this._mouseDelegates = me(e);
        var d = function(c, u) {
          var h = { row_before_start: c.bind(function(g, f, y) {
            var v = u.$getConfig(), b = u.$config.rowStore;
            if (!Z(y, v.task_grid_row_resizer_attribute)) return false;
            var _ = this.locate(y, v.task_grid_row_resizer_attribute), m = b.getItem(_);
            return u.callEvent("onBeforeRowResize", [m]) !== false && void 0;
          }, c), row_after_start: c.bind(function(g, f, y) {
            var v = u.$getConfig(), b = this.locate(y, v.task_grid_row_resizer_attribute);
            g.config.marker.innerHTML = "", g.config.marker.className += " gantt_row_grid_resize_area", g.config.marker.style.width = u.$grid.offsetWidth + "px", g.config.drag_id = b;
          }, c), row_drag_move: c.bind(function(g, f, y) {
            var v = u.$config.rowStore, b = u.$getConfig(), _ = g.config, m = _.drag_id, p = u.getItemHeight(m), k = u.getItemTop(m) - f.scrollTop, $ = W(u.$grid_data), w = parseInt(_.marker.style.top, 10), x = k + $.y, S = 0, T = b.min_task_grid_row_height;
            return (S = w - x) < T && (S = T), _.marker.style.left = $.x + "px", _.marker.style.top = x - 1 + "px", _.marker.style.height = Math.abs(S) + 1 + "px", _.marker_height = S, u.callEvent("onRowResize", [m, v.getItem(m), S + p]), true;
          }, c), row_drag_end: c.bind(function(g, f, y) {
            var v = u.$config.rowStore, b = g.config, _ = b.drag_id, m = v.getItem(_), p = u.getItemHeight(_), k = b.marker_height;
            u.callEvent("onBeforeRowResizeEnd", [_, m, k]) !== false && m.row_height != k && (m.row_height = k, c.updateTask(_), u.callEvent("onAfterRowResize", [_, m, p, k]), this.render());
          }, c) };
          return { init: function() {
            var g = c.$services.getService("dnd"), f = u.$getConfig(), y = new g(u.$grid_data, { updates_per_second: 60 });
            c.defined(f.dnd_sensitivity) && (y.config.sensitivity = f.dnd_sensitivity), y.attachEvent("onBeforeDragStart", function(v, b) {
              return h.row_before_start(y, v, b);
            }), y.attachEvent("onAfterDragStart", function(v, b) {
              return h.row_after_start(y, v, b);
            }), y.attachEvent("onDragMove", function(v, b) {
              return h.row_drag_move(y, v, b);
            }), y.attachEvent("onDragEnd", function(v, b) {
              return h.row_drag_end(y, v, b);
            });
          } };
        }(e, this);
        d.init(), this._addLayers(this.$gantt), this._initEvents(), r && (this._columnDND = new va(e, this), this._columnDND.init()), this.callEvent("onReady", []);
      }, _validateColumnWidth: function(t, e) {
        var n = t[e];
        if (n && n != "*") {
          var i = this.$gantt, a = 1 * n;
          isNaN(a) ? i.assert(false, "Wrong " + e + " value of column " + t.name) : t[e] = a;
        }
      }, setSize: function(t, e) {
        this.$config.width = this.$state.width = t, this.$config.height = this.$state.height = e;
        for (var n, i = this.getGridColumns(), a = 0, r = (d = this.$getConfig()).grid_elastic_columns, s = 0, o = i.length; s < o; s++) this._validateColumnWidth(i[s], "min_width"), this._validateColumnWidth(i[s], "max_width"), this._validateColumnWidth(i[s], "width"), a += 1 * i[s].width;
        if (!isNaN(a) && this.$config.scrollable || (a = n = this._setColumnsWidth(t + 1)), this.$config.scrollable && r && !isNaN(a)) {
          let u = "width";
          r == "min_width" && (u = "min_width");
          let h = 0;
          i.forEach(function(g) {
            h += g[u] || d.min_grid_column_width;
          });
          var l = Math.max(h, t);
          a = this._setColumnsWidth(l), n = t;
        }
        this.$config.scrollable ? (this.$grid_scale.style.width = a + "px", this.$grid_data.style.width = a + "px") : (this.$grid_scale.style.width = "inherit", this.$grid_data.style.width = "inherit"), this.$config.width -= 1;
        var d = this.$getConfig();
        n !== t && (n !== void 0 ? (d.grid_width = n, this.$config.width = n - 1) : isNaN(a) || (this._setColumnsWidth(a), d.grid_width = a, this.$config.width = a - 1));
        var c = Math.max(this.$state.height - d.scale_height, 0);
        this.$grid_data.style.height = c + "px", this.refresh();
      }, getSize: function() {
        var t = this.$getConfig(), e = this.$config.rowStore ? this.getTotalHeight() : 0, n = this._getGridWidth();
        return { x: this.$state.width, y: this.$state.height, contentX: this.isVisible() ? n : 0, contentY: this.isVisible() ? t.scale_height + e : 0, scrollHeight: this.isVisible() ? e : 0, scrollWidth: this.isVisible() ? n : 0 };
      }, _bindStore: function() {
        if (this.$config.bind) {
          var t = this.$gantt.getDatastore(this.$config.bind);
          if (this.$config.rowStore = t, t && !t._gridCacheAttached) {
            var e = this;
            t._gridCacheAttached = t.attachEvent("onBeforeFilter", function() {
              e._resetTopPositionHeight();
            });
          }
        }
      }, _unbindStore: function() {
        if (this.$config.bind) {
          var t = this.$gantt.getDatastore(this.$config.bind);
          t && t._gridCacheAttached && (t.detachEvent(t._gridCacheAttached), t._gridCacheAttached = false);
        }
      }, refresh: function() {
        this._bindStore(), this._resetTopPositionHeight(), this._resetHeight(), this._initSmartRenderingPlaceholder(), this._calculateGridWidth(), this._renderGridHeader();
      }, getViewPort: function() {
        var t = this.$config.scrollLeft || 0, e = this.$config.scrollTop || 0, n = this.$config.height || 0, i = this.$config.width || 0;
        return { y: e, y_end: e + n, x: t, x_end: t + i, height: n, width: i };
      }, scrollTo: function(t, e) {
        if (this.isVisible()) {
          var n = false;
          this.$config.scrollTop = this.$config.scrollTop || 0, this.$config.scrollLeft = this.$config.scrollLeft || 0, 1 * t == t && (this.$config.scrollLeft = this.$state.scrollLeft = this.$grid.scrollLeft = t, n = true), 1 * e == e && (this.$config.scrollTop = this.$state.scrollTop = this.$grid_data.scrollTop = e, n = true), n && this.callEvent("onScroll", [this.$config.scrollLeft, this.$config.scrollTop]);
        }
      }, getColumnIndex: function(t, e) {
        for (var n = this.$getConfig().columns, i = 0, a = 0; a < n.length; a++) if (e && n[a].hide && i++, n[a].name == t) return a - i;
        return null;
      }, getColumn: function(t) {
        var e = this.getColumnIndex(t);
        return e === null ? null : this.$getConfig().columns[e];
      }, getGridColumns: function() {
        return this.$getConfig().columns.slice();
      }, isVisible: function() {
        return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$grid.offsetWidth;
      }, _createLayerConfig: function() {
        var t = this.$gantt, e = this;
        return [{ renderer: t.$ui.layers.gridLine(), container: this.$grid_data, filter: [function() {
          return e.isVisible();
        }] }, { renderer: t.$ui.layers.gridTaskRowResizer(), container: this.$grid_data, append: true, filter: [function() {
          return t.config.resize_rows;
        }] }];
      }, _addLayers: function(t) {
        if (this.$config.bind) {
          this._taskLayers = [];
          var e = this, n = this.$gantt.$services.getService("layers"), i = n.getDataRender(this.$config.bind);
          i || (i = n.createDataRender({ name: this.$config.bind, defaultContainer: function() {
            return e.$grid_data;
          } }));
          for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {
            var s = a[r];
            s.view = this;
            var o = i.addLayer(s);
            this._taskLayers.push(o);
          }
          this._bindStore(), this._initSmartRenderingPlaceholder();
        }
      }, _refreshPlaceholderOnStoreUpdate: function(t) {
        var e = this.$getConfig(), n = this.$config.rowStore;
        if (n && t === null && this.isVisible() && e.smart_rendering) {
          var i;
          if (this.$config.scrollY) {
            var a = this.$gantt.$ui.getView(this.$config.scrollY);
            a && (i = a.getScrollState().scrollSize);
          }
          if (i || (i = n ? this.getTotalHeight() : 0), i) {
            this.$rowsPlaceholder && this.$rowsPlaceholder.parentNode && this.$rowsPlaceholder.parentNode.removeChild(this.$rowsPlaceholder);
            var r = this.$rowsPlaceholder = document.createElement("div");
            r.style.visibility = "hidden", r.style.height = i + "px", r.style.width = "1px", this.$grid_data.appendChild(r);
          }
        }
      }, _initSmartRenderingPlaceholder: function() {
        var t = this.$config.rowStore;
        t && (this._initSmartRenderingPlaceholder = function() {
        }, this._staticBgHandler = t.attachEvent("onStoreUpdated", R(this._refreshPlaceholderOnStoreUpdate, this)));
      }, _initEvents: function() {
        var t = this.$gantt;
        this._mouseDelegates.delegate("click", "gantt_close", t.bind(function(e, n, i) {
          var a = this.$config.rowStore;
          if (!a) return true;
          var r = Z(e, this.$config.item_attribute);
          return r && a.close(r.getAttribute(this.$config.item_attribute)), false;
        }, this), this.$grid), this._mouseDelegates.delegate("click", "gantt_open", t.bind(function(e, n, i) {
          var a = this.$config.rowStore;
          if (!a) return true;
          var r = Z(e, this.$config.item_attribute);
          return r && a.open(r.getAttribute(this.$config.item_attribute)), false;
        }, this), this.$grid);
      }, _clearLayers: function(t) {
        var e = this.$gantt.$services.getService("layers").getDataRender(this.$config.bind);
        if (this._taskLayers) for (var n = 0; n < this._taskLayers.length; n++) e.removeLayer(this._taskLayers[n]);
        this._taskLayers = [];
      }, _getColumnWidth: function(t, e, n) {
        var i = t.min_width || e.min_grid_column_width, a = Math.max(n, i || 10);
        return t.max_width && (a = Math.min(a, t.max_width)), a;
      }, _checkGridColumnMinWidthLimits: function(t, e) {
        for (var n = 0, i = t.length; n < i; n++) {
          var a = 1 * t[n].width;
          !t[n].min_width && a < e.min_grid_column_width && (t[n].min_width = a);
        }
      }, _getGridWidthLimits: function() {
        for (var t = this.$getConfig(), e = this.getGridColumns(), n = 0, i = 0, a = 0; a < e.length; a++) n += e[a].min_width ? e[a].min_width : t.min_grid_column_width, i !== void 0 && (i = e[a].max_width ? i + e[a].max_width : void 0);
        return this._checkGridColumnMinWidthLimits(e, t), [n, i];
      }, _setColumnsWidth: function(t, e) {
        var n = this.$getConfig(), i = this.getGridColumns(), a = 0, r = t;
        e = window.isNaN(e) ? -1 : e;
        for (var s = 0, o = i.length; s < o; s++) a += 1 * i[s].width;
        if (window.isNaN(a)) for (this._calculateGridWidth(), a = 0, s = 0, o = i.length; s < o; s++) a += 1 * i[s].width;
        var l = r - a, d = 0;
        for (s = 0; s < e + 1; s++) d += i[s].width;
        for (a -= d, s = e + 1; s < i.length; s++) {
          var c = i[s], u = Math.round(l * (c.width / a));
          l < 0 ? c.min_width && c.width + u < c.min_width ? u = c.min_width - c.width : !c.min_width && n.min_grid_column_width && c.width + u < n.min_grid_column_width && (u = n.min_grid_column_width - c.width) : c.max_width && c.width + u > c.max_width && (u = c.max_width - c.width), a -= c.width, c.width += u, l -= u;
        }
        for (var h = l > 0 ? 1 : -1; l > 0 && h === 1 || l < 0 && h === -1; ) {
          var g = l;
          for (s = e + 1; s < i.length; s++) {
            var f;
            if ((f = i[s].width + h) == this._getColumnWidth(i[s], n, f) && (l -= h, i[s].width = f), !l) break;
          }
          if (g == l) break;
        }
        return l && e > -1 && (f = i[e].width + l) == this._getColumnWidth(i[e], n, f) && (i[e].width = f), this._getColsTotalWidth();
      }, _getColsTotalWidth: function() {
        for (var t = this.getGridColumns(), e = 0, n = 0; n < t.length; n++) {
          var i = parseFloat(t[n].width);
          if (window.isNaN(i)) return false;
          e += i;
        }
        return e;
      }, _calculateGridWidth: function() {
        for (var t = this.$getConfig(), e = this.getGridColumns(), n = 0, i = [], a = [], r = 0; r < e.length; r++) {
          var s = parseFloat(e[r].width);
          window.isNaN(s) && (s = t.min_grid_column_width || 10, i.push(r)), a[r] = s, n += s;
        }
        var o = this._getGridWidth() + 1;
        if (t.autofit || i.length) {
          var l = o - n;
          if (t.autofit && !t.grid_elastic_columns) for (r = 0; r < a.length; r++) {
            var d = Math.round(l / (a.length - r));
            a[r] += d, (c = this._getColumnWidth(e[r], t, a[r])) != a[r] && (d = c - a[r], a[r] = c), l -= d;
          }
          else if (i.length) for (r = 0; r < i.length; r++) {
            d = Math.round(l / (i.length - r));
            var c, u = i[r];
            a[u] += d, (c = this._getColumnWidth(e[u], t, a[u])) != a[u] && (d = c - a[u], a[u] = c), l -= d;
          }
          for (r = 0; r < a.length; r++) e[r].width = a[r];
        } else {
          var h = o != n;
          this.$config.width = n - 1, t.grid_width = n, h && this.$parent._setContentSize(this.$config.width, null);
        }
      }, _renderGridHeader: function() {
        var t = this.$gantt, e = this.$getConfig(), n = this.$gantt.locale, i = this.$gantt.templates, a = this.getGridColumns();
        e.rtl && (a = a.reverse());
        for (var r = [], s = 0, o = n.labels, l = e.scale_height - 1, d = 0; d < a.length; d++) {
          var c = d == a.length - 1, u = a[d];
          u.name || (u.name = t.uid() + "");
          var h = 1 * u.width, g = this._getGridWidth();
          c && g > s + h && (u.width = h = g - s), s += h;
          var f = t._sort && u.name == t._sort.name ? `<div data-column-id="${u.name}" class="gantt_sort gantt_${t._sort.direction}"></div>` : "", y = ["gantt_grid_head_cell", "gantt_grid_head_" + u.name, c ? "gantt_last_cell" : "", i.grid_header_class(u.name, u)].join(" "), v = "width:" + (h - (c ? 1 : 0)) + "px;", b = u.label || o["column_" + u.name] || o[u.name];
          b = b || "";
          var _ = "<div class='" + y + "' style='" + v + "' " + t._waiAria.gridScaleCellAttrString(u, b) + " data-column-id='" + u.name + "' column_id='" + u.name + "' data-column-name='" + u.name + "' data-column-index='" + d + "'>" + b + f + "</div>";
          r.push(_);
        }
        this.$grid_scale.style.height = e.scale_height + "px", this.$grid_scale.style.lineHeight = l + "px", this.$grid_scale.innerHTML = r.join(""), this._renderHeaderResizers && this._renderHeaderResizers();
      }, _getGridWidth: function() {
        return this.$config.width;
      }, destructor: function() {
        this._clearLayers(this.$gantt), this._mouseDelegates && (this._mouseDelegates.destructor(), this._mouseDelegates = null), this._unbindStore(), this.$grid = null, this.$grid_scale = null, this.$grid_data = null, this.$gantt = null, this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler), this.$config.rowStore = null), this.callEvent("onDestroy", []), this.detachAllEvents();
      } };
      const ka = { init: function(t, e) {
        var n = e.$gantt;
        n.attachEvent("onTaskClick", function(i, a) {
          if (n._is_icon_open_click(a)) return true;
          var r = t.getState(), s = t.locateCell(a.target);
          return !s || !t.getEditorConfig(s.columnName) || (t.isVisible() && r.id == s.id && r.columnName == s.columnName || t.startEdit(s.id, s.columnName), false);
        }), n.attachEvent("onEmptyClick", function() {
          return t.isVisible() && t.isChanged() ? t.save() : t.hide(), true;
        }), n.attachEvent("onTaskDblClick", function(i, a) {
          var r = t.getState(), s = t.locateCell(a.target);
          return !s || !t.isVisible() || s.columnName != r.columnName;
        });
      }, onShow: function(t, e, n) {
        var i = n.$gantt;
        i.ext && i.ext.keyboardNavigation && i.ext.keyboardNavigation.attachEvent("onKeyDown", function(a, r) {
          var s = i.constants.KEY_CODES, o = false;
          return r.keyCode === s.SPACE && t.isVisible() && (o = true), !o;
        }), e.onkeydown = function(a) {
          a = a || window.event;
          var r = i.constants.KEY_CODES;
          if (!(a.defaultPrevented || a.shiftKey && a.keyCode != r.TAB)) {
            var s = true;
            switch (a.keyCode) {
              case i.keys.edit_save:
                t.save();
                break;
              case i.keys.edit_cancel:
                t.hide();
                break;
              case r.UP:
              case r.DOWN:
                t.isVisible() && (t.hide(), s = false);
                break;
              case r.TAB:
                a.shiftKey ? t.editPrevCell(true) : t.editNextCell(true);
                break;
              default:
                s = false;
            }
            s && a.preventDefault();
          }
        };
      }, onHide: function() {
      }, destroy: function() {
      } }, ya = { init: function(t, e) {
        var n = t, i = e.$gantt, a = null, r = i.ext.keyboardNavigation;
        r.attachEvent("onBeforeFocus", function(s) {
          var o = t.locateCell(s);
          if (clearTimeout(a), o) {
            var l = o.columnName, d = o.id, c = n.getState();
            if (n.isVisible() && c.id == d && c.columnName === l) return false;
          }
          return true;
        }), r.attachEvent("onFocus", function(s) {
          var o = t.locateCell(s), l = t.getState();
          return clearTimeout(a), !o || o.id == l.id && o.columnName == l.columnName || n.isVisible() && n.save(), true;
        }), t.attachEvent("onHide", function() {
          clearTimeout(a);
        }), r.attachEvent("onBlur", function() {
          return a = setTimeout(function() {
            n.save();
          }), true;
        }), i.attachEvent("onTaskDblClick", function(s, o) {
          var l = t.getState(), d = t.locateCell(o.target);
          return !d || !t.isVisible() || d.columnName != l.columnName;
        }), i.attachEvent("onTaskClick", function(s, o) {
          if (i._is_icon_open_click(o)) return true;
          var l = t.getState(), d = t.locateCell(o.target);
          return !d || !t.getEditorConfig(d.columnName) || (t.isVisible() && l.id == d.id && l.columnName == d.columnName || t.startEdit(d.id, d.columnName), false);
        }), i.attachEvent("onEmptyClick", function() {
          return n.save(), true;
        }), r.attachEvent("onKeyDown", function(s, o) {
          var l = t.locateCell(o.target), d = !!l && t.getEditorConfig(l.columnName), c = t.getState(), u = i.constants.KEY_CODES, h = o.keyCode, g = false;
          switch (h) {
            case u.ENTER:
              t.isVisible() ? (t.save(), o.preventDefault(), g = true) : d && !(o.ctrlKey || o.metaKey || o.shiftKey) && (n.startEdit(l.id, l.columnName), o.preventDefault(), g = true);
              break;
            case u.ESC:
              t.isVisible() && (t.hide(), o.preventDefault(), g = true);
              break;
            case u.UP:
            case u.DOWN:
              break;
            case u.LEFT:
            case u.RIGHT:
              (d && t.isVisible() || c.editorType === "date") && (g = true);
              break;
            case u.SPACE:
              t.isVisible() && (g = true), d && !t.isVisible() && (n.startEdit(l.id, l.columnName), o.preventDefault(), g = true);
              break;
            case u.DELETE:
              d && !t.isVisible() ? (n.startEdit(l.id, l.columnName), g = true) : d && t.isVisible() && (g = true);
              break;
            case u.TAB:
              if (t.isVisible()) {
                o.shiftKey ? t.editPrevCell(true) : t.editNextCell(true);
                var f = t.getState();
                f.id && r.focus({ type: "taskCell", id: f.id, column: f.columnName }), o.preventDefault(), g = true;
              }
              break;
            default:
              if (t.isVisible()) g = true;
              else if (h >= 48 && h <= 57 || h > 95 && h < 112 || h >= 64 && h <= 91 || h > 185 && h < 193 || h > 218 && h < 223) {
                var y = s.modifiers, v = y.alt || y.ctrl || y.meta || y.shift;
                y.alt || v && r.getCommandHandler(s, "taskCell") || d && !t.isVisible() && (n.startEdit(l.id, l.columnName), g = true);
              }
          }
          return !g;
        });
      }, onShow: function(t, e, n) {
      }, onHide: function(t, e, n) {
        const i = n.$gantt;
        i && i.focus();
      }, destroy: function() {
      } };
      function St(t) {
        var e = function() {
        };
        return e.prototype = { show: function(n, i, a, r) {
        }, hide: function() {
        }, set_value: function(n, i, a, r) {
          this.get_input(r).value = n;
        }, get_value: function(n, i, a) {
          return this.get_input(a).value || "";
        }, is_changed: function(n, i, a, r) {
          var s = this.get_value(i, a, r);
          return s && n && s.valueOf && n.valueOf ? s.valueOf() != n.valueOf() : s != n;
        }, is_valid: function(n, i, a, r) {
          return true;
        }, save: function(n, i, a) {
        }, get_input: function(n) {
          return n.querySelector("input");
        }, focus: function(n) {
          var i = this.get_input(n);
          i && (i.focus && i.focus(), i.select && i.select());
        } }, e;
      }
      function ba(t) {
        var e = St();
        function n() {
          return e.apply(this, arguments) || this;
        }
        return z(n, e), N(n.prototype, { show: function(i, a, r, s) {
          var o = `<div role='cell'><input type='text' name='${a.name}' title='${a.name}'></div>`;
          s.innerHTML = o;
        } }, true), n;
      }
      function xa(t) {
        var e = St();
        function n() {
          return e.apply(this, arguments) || this;
        }
        return z(n, e), N(n.prototype, { show: function(i, a, r, s) {
          var o = r.min || 0, l = r.max || 100, d = `<div role='cell'><input type='number' min='${o}' max='${l}' name='${a.name}' title='${a.name}'></div>`;
          s.innerHTML = d, s.oninput = function(c) {
            +c.target.value < o && (c.target.value = o), +c.target.value > l && (c.target.value = l);
          };
        }, get_value: function(i, a, r) {
          return this.get_input(r).value || "";
        }, is_valid: function(i, a, r, s) {
          return !isNaN(parseInt(i, 10));
        } }, true), n;
      }
      function $a(t) {
        var e = St();
        function n() {
          return e.apply(this, arguments) || this;
        }
        return z(n, e), N(n.prototype, { show: function(i, a, r, s) {
          for (var o = `<div role='cell'><select name='${a.name}' title='${a.name}'>`, l = [], d = r.options || [], c = 0; c < d.length; c++) l.push("<option value='" + r.options[c].key + "'>" + d[c].label + "</option>");
          o += l.join("") + "</select></div>", s.innerHTML = o;
        }, get_input: function(i) {
          return i.querySelector("select");
        } }, true), n;
      }
      function wa(t) {
        var e = St(), n = "%Y-%m-%d", i = null, a = null;
        function r() {
          return e.apply(this, arguments) || this;
        }
        return z(r, e), N(r.prototype, { show: function(s, o, l, d) {
          i || (i = t.date.date_to_str(n)), a || (a = t.date.str_to_date(n));
          var c = null, u = null;
          c = typeof l.min == "function" ? l.min(s, o) : l.min, u = typeof l.max == "function" ? l.max(s, o) : l.max;
          var h = `<div style='width:140px' role='cell'><input type='date' ${c ? " min='" + i(c) + "' " : ""} ${u ? " max='" + i(u) + "' " : ""} name='${o.name}' title='${o.name}'></div>`;
          d.innerHTML = h, d.oninput = function(g) {
            +t.date.str_to_date("%Y-%m-%d")(g.target.value) < +c && (g.target.value = t.date.date_to_str("%Y-%m-%d")(c)), +t.date.str_to_date("%Y-%m-%d")(g.target.value) > +u && (g.target.value = t.date.date_to_str("%Y-%m-%d")(u));
          };
        }, set_value: function(s, o, l, d) {
          s && s.getFullYear ? this.get_input(d).value = i(s) : this.get_input(d).value = s;
        }, is_valid: function(s, o, l, d) {
          return !(!s || isNaN(s.getTime()));
        }, get_value: function(s, o, l) {
          var d;
          try {
            d = a(this.get_input(l).value || "");
          } catch {
            d = null;
          }
          return d;
        } }, true), r;
      }
      function Sa(t) {
        var e = St();
        function n() {
          return e.apply(this, arguments) || this;
        }
        function i(l) {
          return l.formatter || t.ext.formatters.linkFormatter();
        }
        function a(l, d) {
          for (var c = (l || "").split(d.delimiter || ","), u = 0; u < c.length; u++) {
            var h = c[u].trim();
            h ? c[u] = h : (c.splice(u, 1), u--);
          }
          return c.sort(), c;
        }
        function r(l, d, c) {
          for (var u = l.$target, h = [], g = 0; g < u.length; g++) {
            var f = c.getLink(u[g]);
            h.push(i(d).format(f));
          }
          return h.join((d.delimiter || ",") + " ");
        }
        function s(l) {
          return l.source + "_" + l.target + "_" + l.type + "_" + (l.lag || 0);
        }
        function o(l, d, c) {
          var u = function(v, b, _) {
            var m = [];
            return [...new Set(b)].forEach(function(p) {
              var k = i(_).parse(p);
              k && (k.target = v, k.id = "predecessor_generated", t.isLinkAllowed(k) && (k.id = void 0, m.push(k)));
            }), m;
          }(l.id, d, c), h = {};
          l.$target.forEach(function(v) {
            var b = t.getLink(v);
            h[s(b)] = b.id;
          });
          var g = [];
          u.forEach(function(v) {
            var b = s(v);
            h[b] ? delete h[b] : g.push(v);
          });
          var f = [];
          for (var y in h) f.push(h[y]);
          return { add: g, remove: f };
        }
        return z(n, e), N(n.prototype, { show: function(l, d, c, u) {
          var h = `<div role='cell'><input type='text' name='${d.name}' title='${d.name}'></div>`;
          u.innerHTML = h;
        }, hide: function() {
        }, set_value: function(l, d, c, u) {
          this.get_input(u).value = r(l, c.editor, t);
        }, get_value: function(l, d, c) {
          return a(this.get_input(c).value || "", d.editor);
        }, save: function(l, d, c) {
          var u = o(t.getTask(l), this.get_value(l, d, c), d.editor);
          (u.add.length || u.remove.length) && t.batchUpdate(function() {
            u.add.forEach(function(h) {
              t.addLink(h);
            }), u.remove.forEach(function(h) {
              t.deleteLink(h);
            }), t.autoSchedule && t.autoSchedule();
          });
        }, is_changed: function(l, d, c, u) {
          var h = this.get_value(d, c, u), g = a(r(l, c.editor, t), c.editor);
          return h.join() !== g.join();
        } }, true), n;
      }
      function Ta(t) {
        var e = St();
        function n() {
          return e.apply(this, arguments) || this;
        }
        function i(a) {
          return a.formatter || t.ext.formatters.durationFormatter();
        }
        return z(n, e), N(n.prototype, { show: function(a, r, s, o) {
          var l = `<div role='cell'><input type='text' name='${r.name}' title='${r.name}'></div>`;
          o.innerHTML = l;
        }, set_value: function(a, r, s, o) {
          this.get_input(o).value = i(s.editor).format(a);
        }, get_value: function(a, r, s) {
          return i(r.editor).parse(this.get_input(s).value || "");
        } }, true), n;
      }
      function Ea(t) {
        return function(n, i, a) {
          a == "keepDates" ? function(r, s) {
            s == "duration" ? r.end_date = t.calculateEndDate(r) : s != "end_date" && s != "start_date" || (r.duration = t.calculateDuration(r));
          }(n, i) : a == "keepDuration" ? function(r, s) {
            s == "end_date" ? r.start_date = e(r) : s != "start_date" && s != "duration" || (r.end_date = t.calculateEndDate(r));
          }(n, i) : function(r, s) {
            t.config.schedule_from_end ? s == "end_date" || s == "duration" ? r.start_date = e(r) : s == "start_date" && (r.duration = t.calculateDuration(r)) : s == "start_date" || s == "duration" ? r.end_date = t.calculateEndDate(r) : s == "end_date" && (r.duration = t.calculateDuration(r));
          }(n, i);
        };
        function e(n) {
          return t.calculateEndDate({ start_date: n.end_date, duration: -n.duration, task: n });
        }
      }
      function Ca(t) {
        t.config.editor_types = { text: new (ba())(), number: new (xa())(), select: new ($a())(), date: new (wa(t))(), predecessor: new (Sa(t))(), duration: new (Ta(t))() };
      }
      function Da(t) {
        var e = /* @__PURE__ */ function(a) {
          var r = null;
          return { setMapping: function(s) {
            r = s;
          }, getMapping: function() {
            return r || (a.config.keyboard_navigation_cells && a.ext.keyboardNavigation ? ya : ka);
          } };
        }(t), n = {};
        nt(n);
        var i = { init: Ca, createEditors: function(a) {
          function r(u, h) {
            var g = a.$getConfig(), f = function(b, _) {
              for (var m = a.$getConfig(), p = a.getItemTop(b), k = a.getItemHeight(b), $ = a.getGridColumns(), w = 0, x = 0, S = 0, T = 0; T < $.length; T++) {
                if ($[T].name == _) {
                  S = $[T].width;
                  break;
                }
                m.rtl ? x += $[T].width : w += $[T].width;
              }
              return m.rtl ? { top: p, right: x, height: k, width: S } : { top: p, left: w, height: k, width: S };
            }(u, h), y = document.createElement("div");
            y.className = "gantt_grid_editor_placeholder", y.setAttribute(a.$config.item_attribute, u), y.setAttribute(a.$config.bind + "_id", u), y.setAttribute("data-column-name", h);
            var v = function(b, _) {
              for (var m = b.getGridColumns(), p = 0; p < m.length; p++) if (m[p].name == _) return p;
              return 0;
            }(a, h);
            return y.setAttribute("data-column-index", v), t._waiAria.inlineEditorAttr(y), g.rtl ? y.style.cssText = ["top:" + f.top + "px", "right:" + f.right + "px", "width:" + f.width + "px", "height:" + f.height + "px"].join(";") : y.style.cssText = ["top:" + f.top + "px", "left:" + f.left + "px", "width:" + f.width + "px", "height:" + f.height + "px"].join(";"), y;
          }
          var s = Ea(t), o = [], l = [], d = null, c = { _itemId: null, _columnName: null, _editor: null, _editorType: null, _placeholder: null, locateCell: function(u) {
            if (!G(u, a.$grid)) return null;
            var h = Z(u, a.$config.item_attribute), g = Z(u, "data-column-name");
            if (h && g) {
              var f = g.getAttribute("data-column-name");
              return { id: h.getAttribute(a.$config.item_attribute), columnName: f };
            }
            return null;
          }, getEditorConfig: function(u) {
            return a.getColumn(u).editor;
          }, init: function() {
            var u = e.getMapping();
            u.init && u.init(this, a), d = a.$gantt.getDatastore(a.$config.bind);
            var h = this;
            o.push(d.attachEvent("onIdChange", function(g, f) {
              h._itemId == g && (h._itemId = f);
            })), o.push(d.attachEvent("onStoreUpdated", function() {
              a.$gantt.getState("batchUpdate").batch_update || h.isVisible() && !d.isVisible(h._itemId) && h.hide();
            })), l.push(t.attachEvent("onDataRender", function() {
              h._editor && h._placeholder && !G(h._placeholder, t.$root) && a.$grid_data.appendChild(h._placeholder);
            })), this.init = function() {
            };
          }, getState: function() {
            return { editor: this._editor, editorType: this._editorType, placeholder: this._placeholder, id: this._itemId, columnName: this._columnName };
          }, startEdit: function(u, h) {
            if (this.isVisible() && this.save(), d.exists(u)) {
              var g = { id: u, columnName: h };
              t.isReadonly(d.getItem(u)) ? this.callEvent("onEditPrevent", [g]) : this.callEvent("onBeforeEditStart", [g]) !== false ? (this.show(g.id, g.columnName), this.setValue(), this.callEvent("onEditStart", [g])) : this.callEvent("onEditPrevent", [g]);
            }
          }, isVisible: function() {
            return !(!this._editor || !G(this._placeholder, t.$root));
          }, show: function(u, h) {
            this.isVisible() && this.save();
            var g = { id: u, columnName: h }, f = a.getColumn(g.columnName), y = this.getEditorConfig(f.name);
            if (y) {
              var v = a.$getConfig().editor_types[y.type], b = r(g.id, g.columnName);
              a.$grid_data.appendChild(b), v.show(g.id, f, y, b), this._editor = v, this._placeholder = b, this._itemId = g.id, this._columnName = g.columnName, this._editorType = y.type;
              var _ = e.getMapping();
              _.onShow && _.onShow(this, b, a);
            }
          }, setValue: function() {
            var u = this.getState(), h = u.id, g = u.columnName, f = a.getColumn(g), y = d.getItem(h), v = this.getEditorConfig(g);
            if (v) {
              var b = y[v.map_to];
              v.map_to == "auto" && (b = d.getItem(h)), this._editor.set_value(b, h, f, this._placeholder), this.focus();
            }
          }, focus: function() {
            this._editor.focus(this._placeholder);
          }, getValue: function() {
            var u = a.getColumn(this._columnName);
            return this._editor.get_value(this._itemId, u, this._placeholder);
          }, _getItemValue: function() {
            var u = this.getEditorConfig(this._columnName);
            if (u) {
              var h = t.getTask(this._itemId)[u.map_to];
              return u.map_to == "auto" && (h = d.getItem(this._itemId)), h;
            }
          }, isChanged: function() {
            var u = a.getColumn(this._columnName), h = this._getItemValue();
            return this._editor.is_changed(h, this._itemId, u, this._placeholder);
          }, hide: function() {
            if (this._itemId) {
              var u = this._itemId, h = this._columnName, g = e.getMapping();
              g.onHide && g.onHide(this, this._placeholder, a), this._itemId = null, this._columnName = null, this._editorType = null, this._placeholder && (this._editor && this._editor.hide && this._editor.hide(this._placeholder), this._editor = null, this._placeholder.parentNode && this._placeholder.parentNode.removeChild(this._placeholder), this._placeholder = null, this.callEvent("onEditEnd", [{ id: u, columnName: h }]));
            }
          }, save: function() {
            if (this.isVisible() && d.exists(this._itemId) && this.isChanged()) {
              var u = this._itemId, h = this._columnName;
              if (d.exists(u)) {
                var g = d.getItem(u), f = this.getEditorConfig(h), y = { id: u, columnName: h, newValue: this.getValue(), oldValue: this._getItemValue() };
                if (this.callEvent("onBeforeSave", [y]) !== false && (!this._editor.is_valid || this._editor.is_valid(y.newValue, y.id, a.getColumn(h), this._placeholder))) {
                  var v = f.map_to, b = y.newValue;
                  v != "auto" ? (g[v] = b, s(g, v, t.config.inline_editors_date_processing), d.updateItem(u)) : this._editor.save(u, a.getColumn(h), this._placeholder), this.callEvent("onSave", [y]);
                }
                this.hide();
              }
            } else this.hide();
          }, _findEditableCell: function(u, h) {
            var g = u, f = a.getGridColumns()[g], y = f ? f.name : null;
            if (y) {
              for (; y && !this.getEditorConfig(y); ) y = this._findEditableCell(u + h, h);
              return y;
            }
            return null;
          }, getNextCell: function(u) {
            return this._findEditableCell(a.getColumnIndex(this._columnName, true) + u, u);
          }, getFirstCell: function() {
            return this._findEditableCell(0, 1);
          }, getLastCell: function() {
            return this._findEditableCell(a.getGridColumns().length - 1, -1);
          }, editNextCell: function(u) {
            var h = this.getNextCell(1);
            if (h) {
              var g = this.getNextCell(1);
              g && this.getEditorConfig(g) && this.startEdit(this._itemId, g);
            } else if (u && this.moveRow(1)) {
              var f = this.moveRow(1);
              (h = this.getFirstCell()) && this.getEditorConfig(h) && this.startEdit(f, h);
            }
          }, editPrevCell: function(u) {
            var h = this.getNextCell(-1);
            if (h) {
              var g = this.getNextCell(-1);
              g && this.getEditorConfig(g) && this.startEdit(this._itemId, g);
            } else if (u && this.moveRow(-1)) {
              var f = this.moveRow(-1);
              (h = this.getLastCell()) && this.getEditorConfig(h) && this.startEdit(f, h);
            }
          }, moveRow: function(u) {
            for (var h = u > 0 ? t.getNext : t.getPrev, g = (h = t.bind(h, t))(this._itemId); t.isTaskExists(g) && t.isReadonly(t.getTask(g)); ) g = h(g);
            return g;
          }, editNextRow: function(u) {
            var h = this.getState().id;
            if (t.isTaskExists(h)) {
              var g = null;
              g = u ? this.moveRow(1) : t.getNext(h), t.isTaskExists(g) && this.startEdit(g, this._columnName);
            }
          }, editPrevRow: function(u) {
            var h = this.getState().id;
            if (t.isTaskExists(h)) {
              var g = null;
              g = u ? this.moveRow(-1) : t.getPrev(h), t.isTaskExists(g) && this.startEdit(g, this._columnName);
            }
          }, detachStore: function() {
            o.forEach(function(u) {
              d.detachEvent(u);
            }), l.forEach(function(u) {
              t.detachEvent(u);
            }), o = [], l = [], d = null, this.hide();
          }, destructor: function() {
            this.detachStore(), this.detachAllEvents();
          } };
          return N(c, e), N(c, n), c;
        } };
        return N(i, e), N(i, n), i;
      }
      function ke(t, e, n, i, a) {
        if (!t.start_date || !t.end_date) return null;
        var r = n.getItemTop(t.id), s = n.getItemHeight(t.id);
        if (r > e.y_end || r + s < e.y) return false;
        var o = n.posFromDate(t.start_date), l = n.posFromDate(t.end_date), d = Math.min(o, l) - 200, c = Math.max(o, l) + 200;
        return !(d > e.x_end || c < e.x);
      }
      function gn(t) {
        function e(r, s, o) {
          if (t._isAllowedUnscheduledTask(r) || !t._isTaskInTimelineLimits(r)) return;
          var l = s.getItemPosition(r), d = o, c = s.$getTemplates(), u = t.getTaskType(r.type), h = s.getBarHeight(r.id, u == d.types.milestone), g = 0;
          u == d.types.milestone && (g = (h - l.height) / 2);
          var f = Math.floor((s.getItemHeight(r.id) - h) / 2);
          const y = t.config.baselines !== false && r.baselines && r.baselines.length, v = t.config.baselines !== false && (t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow");
          if (y && v && r.bar_height !== "full" && r.bar_height < r.row_height) if (u === d.types.milestone) {
            let x = s.getBarHeight(r.id, true), S = Math.sqrt(2 * x * x);
            f = Math.floor((S - h) / 2) + 2;
          } else f = 2;
          u == d.types.milestone && (l.left -= Math.round(h / 2), l.width = h);
          var b = document.createElement("div"), _ = Math.round(l.width);
          s.$config.item_attribute && (b.setAttribute(s.$config.item_attribute, r.id), b.setAttribute(s.$config.bind + "_id", r.id)), d.show_progress && u != d.types.milestone && function(x, S, T, E, C) {
            var D = 1 * x.progress || 0;
            T = Math.max(T - 2, 0);
            var A = document.createElement("div"), I = Math.round(T * D);
            I = Math.min(T, I), A.style.width = I + "px", A.className = "gantt_task_progress", A.innerHTML = C.progress_text(x.start_date, x.end_date, x), E.rtl && (A.style.position = "absolute", A.style.right = "0px");
            var M = document.createElement("div");
            if (M.className = "gantt_task_progress_wrapper", M.appendChild(A), S.appendChild(M), t.config.drag_progress && !t.isReadonly(x)) {
              var L = document.createElement("div"), P = I;
              E.rtl && (P = T - I), L.style.left = P + "px", L.className = "gantt_task_progress_drag", L.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="9" viewBox="0 0 12 9" fill="none">
<path d="M5.58397 1.52543C5.78189 1.22856 6.21811 1.22856 6.41602 1.52543L10.5475 7.72265C10.769 8.05493 10.5308 8.5 10.1315 8.5L1.86852 8.5C1.46917 8.5 1.23097 8.05493 1.45249 7.72265L5.58397 1.52543Z" fill="var(--dhx-gantt-progress-handle-background)" stroke="var(--dhx-gantt-progress-handle-border)"/>
</svg>`, A.appendChild(L), S.appendChild(L);
            }
          }(r, b, _, d, c);
          var m = function(x, S, T) {
            var E = document.createElement("div");
            return t.getTaskType(x.type) != t.config.types.milestone ? E.innerHTML = T.task_text(x.start_date, x.end_date, x) : t.getTaskType(x.type) == t.config.types.milestone && S && (E.style.height = E.style.width = S + "px"), E.className = "gantt_task_content", E;
          }(r, _, c);
          b.appendChild(m);
          var p = function(x, S, T, E) {
            var C = E.$getConfig(), D = [x];
            S && D.push(S);
            var A = t.getState(), I = t.getTask(T);
            if (t.getTaskType(I.type) == C.types.milestone ? D.push("gantt_milestone") : t.getTaskType(I.type) == C.types.project && D.push("gantt_project"), D.push("gantt_bar_" + t.getTaskType(I.type)), t.isSummaryTask(I) && D.push("gantt_dependent_task"), t.isSplitTask(I) && (C.open_split_tasks && !I.$open || !C.open_split_tasks) && D.push("gantt_split_parent"), C.select_task && t.isSelectedTask(T) && D.push("gantt_selected"), T == A.drag_id && (D.push("gantt_drag_" + A.drag_mode), A.touch_drag && D.push("gantt_touch_" + A.drag_mode)), A.link_source_id == T && (D.push("gantt_link_source"), A.link_from_start ? D.push("gantt_link_from_start") : D.push("gantt_link_from_end")), A.link_target_id == T && D.push("gantt_link_target"), C.highlight_critical_path && t.isCriticalTask && t.isCriticalTask(I) && D.push("gantt_critical_task"), A.link_landing_area && A.link_target_id && A.link_source_id && A.link_target_id != A.link_source_id && (A.link_target_id == T || A.link_source_id == T)) {
              var M = A.link_source_id, L = A.link_from_start, P = A.link_to_start, H = "";
              H = t.isLinkAllowed(M, T, L, P) ? P ? "link_start_allow" : "link_finish_allow" : P ? "link_start_deny" : "link_finish_deny", D.push(H);
            }
            return D.join(" ");
          }("gantt_task_line", c.task_class(r.start_date, r.end_date, r), r.id, s);
          (r.color || r.progressColor || r.textColor) && (p += " gantt_task_inline_color"), l.width < 20 && (p += " gantt_thin_task"), b.className = p;
          var k = ["left:" + l.left + "px", "top:" + (f + l.top) + "px", "height:" + h + "px", "line-height:" + Math.max(h < 30 ? h - 2 : h, 0) + "px", "width:" + _ + "px"];
          b.style.cssText = k.join(";"), r.color && b.style.setProperty("--dhx-gantt-task-background", r.color), r.textColor && b.style.setProperty("--dhx-gantt-task-color", r.textColor), r.progressColor && b.style.setProperty("--dhx-gantt-task-progress-color", r.progressColor);
          var $ = function(x, S, T, E) {
            var C = "gantt_left " + i(!S.rtl, x), D = null;
            return E && (D = { type: "marginRight", value: E }), n(x, T.leftside_text, C, D);
          }(r, d, c, g);
          $ && b.appendChild($), $ = function(x, S, T, E) {
            var C = "gantt_right " + i(!!S.rtl, x), D = null;
            return E && (D = { type: "marginLeft", value: E }), n(x, T.rightside_text, C, D);
          }(r, d, c, g), $ && b.appendChild($), t._waiAria.setTaskBarAttr(r, b);
          var w = t.getState();
          return t.isReadonly(r) || (d.drag_resize && !t.isSummaryTask(r) && u != d.types.milestone && a(b, "gantt_task_drag", r, function(x) {
            var S = document.createElement("div");
            return S.className = x, S;
          }, d), d.drag_links && d.show_links && a(b, "gantt_link_control", r, function(x) {
            var S = document.createElement("div");
            S.className = x, S.style.cssText = ["height:" + h + "px", "line-height:" + h + "px"].join(";");
            var T = document.createElement("div");
            T.className = "gantt_link_point";
            var E = false;
            return w.link_source_id && d.touch && (E = true), T.style.display = E ? "block" : "", S.appendChild(T), S;
          }, d, g)), b;
        }
        function n(r, s, o, l) {
          if (!s) return null;
          var d = s(r.start_date, r.end_date, r);
          if (!d) return null;
          var c = document.createElement("div");
          return c.className = "gantt_side_content " + o, c.innerHTML = d, l && (c.style[l.type] = Math.abs(l.value) + "px"), c;
        }
        function i(r, s) {
          var o = r ? { $source: [t.config.links.start_to_start], $target: [t.config.links.start_to_start, t.config.links.finish_to_start] } : { $source: [t.config.links.finish_to_start, t.config.links.finish_to_finish], $target: [t.config.links.finish_to_finish] };
          for (var l in o) for (var d = s[l], c = 0; c < d.length; c++) for (var u = t.getLink(d[c]), h = 0; h < o[l].length; h++) if (u.type == o[l][h]) return "gantt_link_crossing";
          return "";
        }
        function a(r, s, o, l, d, c) {
          var u, h = t.getState();
          +o.start_date >= +h.min_date && ((u = l([s, d.rtl ? "task_right" : "task_left", "task_start_date"].join(" "))).setAttribute("data-bind-property", "start_date"), c && (u.style.marginLeft = c + "px"), r.appendChild(u)), +o.end_date <= +h.max_date && ((u = l([s, d.rtl ? "task_left" : "task_right", "task_end_date"].join(" "))).setAttribute("data-bind-property", "end_date"), c && (u.style.marginRight = c + "px"), r.appendChild(u));
        }
        return function(r, s, o) {
          var l = (o = s.$getConfig()).type_renderers[t.getTaskType(r.type)], d = e;
          return l ? l.call(t, r, function(c) {
            return d.call(t, c, s, o);
          }, s) : d.call(t, r, s, o);
        };
      }
      function fn2(t) {
        return { render: gn(t), update: null, isInViewPort: ke, getVisibleRange: _t };
      }
      function Mt() {
        return console.error("You are trying to use a Pro feature that is not available in the GPL version."), { render: function() {
        }, isInViewPort: function() {
        }, getVisibleRange: function() {
        } };
      }
      function pn(t, e, n) {
        return { top: e.getItemTop(t.id), height: e.getItemHeight(t.id), left: 0, right: 1 / 0 };
      }
      function Ut(t, e) {
        var n = 0, i = t.left.length - 1;
        if (e) for (var a = 0; a < t.left.length; a++) {
          var r = t.left[a];
          if (r < e.x && (n = a), r > e.x_end) {
            i = a;
            break;
          }
        }
        return { start: n, end: i };
      }
      function ye(t, e, n, i) {
        var a = e.width[t];
        if (a <= 0) return false;
        if (!i.config.smart_rendering || At(i)) return true;
        var r = e.left[t] - a, s = e.left[t] + a;
        return r <= n.x_end && s >= n.x;
      }
      function Aa(t, e) {
        var n = e.config.timeline_placeholder;
        if (t = t || [], n && t.filter((l) => l.id === "timeline_placeholder_task").length === 0) {
          var i = e.getState(), a = null, r = i.min_date, s = i.max_date;
          t.length && (a = t[t.length - 1].id);
          var o = { start_date: r, end_date: s, row_height: n.height || 0, id: "timeline_placeholder_task", unscheduled: true, lastTaskId: a, calendar_id: n.calendar || "global", $source: [], $target: [] };
          t.push(o);
        }
      }
      function Ia(t) {
        var e = { current_pos: null, dirs: { left: "left", right: "right", up: "up", down: "down" }, path: [], clear: function() {
          this.current_pos = null, this.path = [];
        }, point: function(a) {
          this.current_pos = t.copy(a);
        }, get_lines: function(a) {
          this.clear(), this.point(a[0]);
          for (var r = 1; r < a.length; r++) this.line_to(a[r]);
          return this.get_path();
        }, line_to: function(a) {
          var r = t.copy(a), s = this.current_pos, o = this._get_line(s, r);
          this.path.push(o), this.current_pos = r;
        }, get_path: function() {
          return this.path;
        }, get_wrapper_sizes: function(a, r, s) {
          var o, l = r.$getConfig().link_wrapper_width, d = a.y - l / 2;
          switch (a.direction) {
            case this.dirs.left:
              o = { top: d, height: l, lineHeight: l, left: a.x - a.size - l / 2, width: a.size + l };
              break;
            case this.dirs.right:
              o = { top: d, lineHeight: l, height: l, left: a.x - l / 2, width: a.size + l };
              break;
            case this.dirs.up:
              o = { top: d - a.size, lineHeight: a.size + l, height: a.size + l, left: a.x - l / 2, width: l };
              break;
            case this.dirs.down:
              o = { top: d, lineHeight: a.size + l, height: a.size + l, left: a.x - l / 2, width: l };
          }
          return o;
        }, get_line_sizes: function(a, r) {
          var s, o = r.$getConfig(), l = o.link_line_width, d = o.link_wrapper_width, c = a.size + l;
          switch (a.direction) {
            case this.dirs.left:
            case this.dirs.right:
              s = { height: l, width: c, marginTop: (d - l) / 2, marginLeft: (d - l) / 2 };
              break;
            case this.dirs.up:
            case this.dirs.down:
              s = { height: c, width: l, marginTop: (d - l) / 2, marginLeft: (d - l) / 2 };
          }
          return s;
        }, render_line: function(a, r, s, o) {
          var l = this.get_wrapper_sizes(a, s, o), d = document.createElement("div");
          d.style.cssText = ["top:" + l.top + "px", "left:" + l.left + "px", "height:" + l.height + "px", "width:" + l.width + "px"].join(";"), d.className = "gantt_line_wrapper";
          var c = this.get_line_sizes(a, s), u = document.createElement("div");
          return u.style.cssText = ["height:" + c.height + "px", "width:" + c.width + "px", "margin-top:" + c.marginTop + "px", "margin-left:" + c.marginLeft + "px"].join(";"), u.className = "gantt_link_line_" + a.direction, d.appendChild(u), d;
        }, render_corner: function(a, r) {
          const s = a.radius, o = r.$getConfig(), l = o.link_line_width || 2, d = document.createElement("div");
          let c, u;
          return d.classList.add("gantt_link_corner"), d.classList.add(`gantt_link_corner_${a.direction.from}_${a.direction.to}`), d.style.width = `${s}px`, d.style.height = `${s}px`, a.direction.from === "right" && a.direction.to === "down" ? (c = "Right", u = "Top", d.style.left = a.x - o.link_line_width / 2 + "px", d.style.top = `${a.y}px`) : a.direction.from === "down" && a.direction.to === "right" ? (c = "Left", u = "Bottom", d.style.left = a.x - o.link_line_width / 2 + "px", d.style.top = `${a.y}px`) : a.direction.from === "right" && a.direction.to === "up" ? (c = "Right", u = "Bottom", d.style.left = a.x - o.link_line_width / 2 + "px", d.style.top = a.y - s + "px") : a.direction.from === "up" && a.direction.to === "right" ? (c = "Left", u = "Top", d.style.left = a.x - o.link_line_width / 2 + "px", d.style.top = a.y - s + "px") : a.direction.from === "left" && a.direction.to === "down" ? (c = "Left", u = "Top", d.style.left = a.x - s - o.link_line_width / 2 + "px", d.style.top = `${a.y}px`) : a.direction.from === "down" && a.direction.to === "left" ? (c = "Right", u = "Bottom", d.style.left = a.x - s - o.link_line_width / 2 + "px", d.style.top = `${a.y}px`) : a.direction.from === "left" && a.direction.to === "up" ? (c = "Left", u = "Bottom", d.style.left = a.x - s - o.link_line_width / 2 + "px", d.style.top = a.y - s + "px") : a.direction.from === "up" && a.direction.to === "left" && (c = "Right", u = "Top", d.style.left = a.x - s - o.link_line_width / 2 + "px", d.style.top = a.y - s + "px"), d.style[`border${u}Width`] = `${l}px`, d.style[`border${c}Width`] = `${l}px`, d.style[`border${c}Style`] = "solid", d.style[`border${u}Style`] = "solid", d.style[`border${u}${c}Radius`] = `${s}px`, d;
        }, render_arrow(a, r) {
          var s = document.createElement("div"), o = a.y, l = a.x, d = r.link_arrow_size;
          s.style.setProperty("--dhx-gantt-icon-size", `${d}px`);
          var c = "gantt_link_arrow gantt_link_arrow_" + a.direction;
          return s.style.top = o + "px", s.style.left = l + "px", s.className = c, s;
        }, _get_line: function(a, r) {
          var s = this.get_direction(a, r), o = { x: a.x, y: a.y, direction: this.get_direction(a, r) };
          return s == this.dirs.left || s == this.dirs.right ? o.size = Math.abs(a.x - r.x) : o.size = Math.abs(a.y - r.y), o;
        }, get_direction: function(a, r) {
          return r.x < a.x ? this.dirs.left : r.x > a.x ? this.dirs.right : r.y > a.y ? this.dirs.down : this.dirs.up;
        } }, n = { path: [], clear: function() {
          this.path = [];
        }, current: function() {
          return this.path[this.path.length - 1];
        }, point: function(a) {
          return a ? (this.path.push(t.copy(a)), a) : this.current();
        }, point_to: function(a, r, s) {
          s = s ? { x: s.x, y: s.y } : t.copy(this.point());
          var o = e.dirs;
          switch (a) {
            case o.left:
              s.x -= r;
              break;
            case o.right:
              s.x += r;
              break;
            case o.up:
              s.y -= r;
              break;
            case o.down:
              s.y += r;
          }
          return this.point(s);
        }, get_points: function(a, r, s, o) {
          var l = this.get_endpoint(a, r, s, o), d = t.config, c = l.e_y - l.y, u = l.e_x - l.x, h = e.dirs, g = r.getItemHeight(a.source);
          this.clear(), this.point({ x: l.x, y: l.y });
          var f = 2 * d.link_arrow_size, y = this.get_line_type(a, r.$getConfig()), v = l.e_x > l.x;
          if (y.from_start && y.to_start) this.point_to(h.left, f), v ? (this.point_to(h.down, c), this.point_to(h.right, u)) : (this.point_to(h.right, u), this.point_to(h.down, c)), this.point_to(h.right, f);
          else if (!y.from_start && y.to_start) if (c !== 0 && (v = l.e_x > l.x + 2 * f), this.point_to(h.right, f), v) u -= f, this.point_to(h.down, c), this.point_to(h.right, u);
          else {
            u -= 2 * f;
            var b = c > 0 ? 1 : -1;
            this.point_to(h.down, b * (g / 2)), this.point_to(h.right, u), this.point_to(h.down, b * (Math.abs(c) - g / 2)), this.point_to(h.right, f);
          }
          else y.from_start || y.to_start ? y.from_start && !y.to_start && (c !== 0 && (v = l.e_x > l.x - 2 * f), this.point_to(h.left, f), v ? (u += 2 * f, b = c > 0 ? 1 : -1, this.point_to(h.down, b * (g / 2)), this.point_to(h.right, u), this.point_to(h.down, b * (Math.abs(c) - g / 2)), this.point_to(h.left, f)) : (u += f, this.point_to(h.down, c), this.point_to(h.right, u))) : (this.point_to(h.right, f), v ? (this.point_to(h.right, u), this.point_to(h.down, c)) : (this.point_to(h.down, c), this.point_to(h.right, u)), this.point_to(h.left, f));
          return this.path;
        }, get_line_type: function(a, r) {
          var s = r.links, o = false, l = false;
          return a.type == s.start_to_start ? o = l = true : a.type == s.finish_to_finish ? o = l = false : a.type == s.finish_to_start ? (o = false, l = true) : a.type == s.start_to_finish ? (o = true, l = false) : t.assert(false, "Invalid link type"), r.rtl && (o = !o, l = !l), { from_start: o, to_start: l };
        }, get_endpoint: function(a, r, s, o) {
          var l = r.$getConfig(), d = this.get_line_type(a, l), c = d.from_start, u = d.to_start, h = i(s, r, l), g = i(o, r, l);
          return { x: c ? h.left : h.left + h.width, e_x: u ? g.left : g.left + g.width, y: h.top + h.rowHeight / 2 - 1, e_y: g.top + g.rowHeight / 2 - 1 };
        } };
        function i(a, r, s) {
          var o = r.getItemPosition(a);
          let l = _i(t, r, a), d = l.maxHeight, c = l.splitChild;
          const u = t.config.baselines !== false && (t.config.baselines.render_mode == "separateRow" || t.config.baselines.render_mode == "individualRow") && a.baselines && a.baselines.length;
          let h;
          l.shrinkHeight && (o.rowHeight = d);
          let g = t.getTaskType(a.type) == s.types.milestone;
          if (g) {
            let f = r.getBarHeight(a.id, true);
            h = Math.sqrt(2 * f * f), l.shrinkHeight && d < f && (f = d, h = d), o.left -= h / 2, o.width = h;
          }
          if (c) if (d >= o.height) {
            const f = hi(t, a.parent);
            u || f ? g ? (o.rowHeight = o.height + 4, o.left += (o.width - o.rowHeight + 4) / 2, o.width = o.rowHeight - 3) : o.rowHeight = o.height + 6 : g && (o.left += (h - o.height) / 2);
          } else o.rowHeight = d + 2, g && (o.left += (o.width - o.rowHeight + 4) / 2, o.width = o.rowHeight - 3);
          else u && (o.rowHeight = o.height + 4);
          return o;
        }
        return { render: function(a, r, s) {
          var o = t.getTask(a.source);
          if (o.hide_bar) return;
          var l = t.getTask(a.target);
          if (l.hide_bar) return;
          var d = n.get_endpoint(a, r, o, l), c = d.e_y - d.y;
          if (!(d.e_x - d.x) && !c) return null;
          var u = n.get_points(a, r, o, l);
          const h = function(v, b) {
            const _ = b.link_radius || 4, m = b.link_arrow_size || 6, p = [];
            for (let $ = 0; $ < v.length; $++) {
              const w = v[$], x = v[$ + 1];
              if (!x || b.link_radius <= 1) p.push({ type: "line", data: w });
              else if (w.direction !== x.direction) {
                if (w.size < _ || x.size < _) {
                  p.push({ type: "line", data: w });
                  continue;
                }
                w.size -= _, p.push({ type: "line", data: w });
                let S = w.x, T = w.y - b.link_line_width / 2;
                switch (w.direction) {
                  case "right":
                    S += w.size;
                    break;
                  case "left":
                    S -= w.size;
                    break;
                  case "down":
                    T += w.size;
                    break;
                  case "up":
                    T -= w.size;
                }
                const E = { x: S, y: T, direction: { from: w.direction, to: x.direction }, radius: _ };
                switch (p.push({ type: "corner", data: E }), x.direction) {
                  case "right":
                    x.x += _, x.size -= _;
                    break;
                  case "left":
                    x.x -= _, x.size -= _;
                    break;
                  case "down":
                    x.y += _, x.size -= _;
                    break;
                  case "up":
                    x.y -= _, x.size -= _;
                }
              } else p.push({ type: "line", data: w });
            }
            const k = v[v.length - 1];
            if (k.direction === "right" || k.direction === "left") {
              k.size -= 3 * m / 4;
              let $ = k.direction === "right" ? k.x + k.size : k.x - k.size - m / 2, w = k.y - b.link_line_width / 2 - m / 2 + 1;
              k.direction === "left" ? (w -= 1, $ -= 2) : $ -= 1;
              const x = { x: $, y: w, size: m, direction: k.direction };
              p.push({ type: "line", data: k }), p.push({ type: "arrow", data: x });
            } else p.push({ type: "line", data: k });
            return p;
          }(e.get_lines(u, r).filter((v) => v.size > 0), s), g = function(v, b, _, m) {
            const p = document.createElement("div");
            return v.forEach((k) => {
              let $;
              k.type === "line" ? $ = e.render_line(k.data, null, b, _.source) : k.type === "corner" ? $ = e.render_corner(k.data, b) : k.type === "arrow" && ($ = e.render_arrow(k.data, m)), p.appendChild($);
            }), p;
          }(h, r, a, s);
          var f = "gantt_task_link";
          a.color && (f += " gantt_link_inline_color");
          var y = t.templates.link_class ? t.templates.link_class(a) : "";
          return y && (f += " " + y), s.highlight_critical_path && t.isCriticalLink && t.isCriticalLink(a) && (f += " gantt_critical_link"), g.className = f, r.$config.link_attribute && (g.setAttribute(r.$config.link_attribute, a.id), g.setAttribute("link_id", a.id)), a.color && g.style.setProperty("--dhx-gantt-link-background", a.color), t._waiAria.linkAttr(a, g), g;
        }, update: null, isInViewPort: cn, getVisibleRange: dn() };
      }
      function Ma(t, e, n, i, a) {
        if (a.$ui.getView("grid") && (a.config.keyboard_navigation && a.getSelectedId() || a.ext.inlineEditors && a.ext.inlineEditors.getState().id)) return true;
        var r = n.getItemTop(t.id), s = n.getItemHeight(t.id);
        return !(r > e.y_end || r + s < e.y);
      }
      function Na(t) {
        let e = {};
        return t.$data.tasksStore.attachEvent("onStoreUpdated", function() {
          e = {};
        }), function(n, i, a, r) {
          const s = n.id + "_" + i + "_" + a.unit + "_" + a.step;
          let o;
          return o = e[s] ? e[s] : e[s] = function(l, d, c, u) {
            let h, g = false, f = {};
            t.config.process_resource_assignments && d === t.config.resource_property ? (h = l.$role == "task" ? t.getResourceAssignments(l.$resource_id, l.$task_id) : t.getResourceAssignments(l.id), g = true) : h = l.$role == "task" ? [] : t.getTaskBy(d, l.id), f = function(x, S, T) {
              const E = S.unit, C = S.step, D = {}, A = {};
              for (let I = 0; I < x.length; I++) {
                const M = x[I];
                let L = M;
                if (T && (L = t.getTask(M.task_id)), L.unscheduled) continue;
                let P = M.start_date || L.start_date, H = M.end_date || L.end_date;
                T && (M.start_date && (P = new Date(Math.max(M.start_date.valueOf(), L.start_date.valueOf()))), M.end_date && (H = new Date(Math.min(M.end_date.valueOf(), L.end_date.valueOf()))), M.mode && M.mode == "fixedDates" && (P = M.start_date, H = M.end_date));
                let U = Tt(S.trace_x, P.valueOf()), gt = new Date(S.trace_x[U] || t.date[E + "_start"](new Date(P))), O = new Date(Math.min(P.valueOf(), gt.valueOf())), tt = t.config.work_time ? t.getTaskCalendar(L) : t;
                for (A[tt.id] = {}; O < H; ) {
                  const X = A[tt.id], B = O.valueOf();
                  O = t.date.add(O, C, E), X[B] !== false && (D[B] || (D[B] = { tasks: [], assignments: [] }), D[B].tasks.push(L), T && D[B].assignments.push(M));
                }
              }
              return D;
            }(h, c, g);
            const y = c.unit, v = c.step, b = [];
            let _, m, p, k, $;
            const w = u.$getConfig();
            for (let x = 0; x < c.trace_x.length; x++) _ = new Date(c.trace_x[x]), m = t.date.add(_, v, y), $ = f[_.valueOf()] || {}, p = $.tasks || [], k = $.assignments || [], p.length || w.resource_render_empty_cells ? b.push({ start_date: _, end_date: m, tasks: p, assignments: k }) : b.push(null);
            return b;
          }(n, i, a, r), o;
        };
      }
      const La = { init: function(t, e) {
        var n = t.$services.getService("dnd");
        if (e.$config.bind && t.getDatastore(e.$config.bind)) {
          var i = new n(e.$grid_data, { updates_per_second: 60 });
          t.defined(e.$getConfig().dnd_sensitivity) && (i.config.sensitivity = e.$getConfig().dnd_sensitivity), i.attachEvent("onBeforeDragStart", t.bind(function(o, l) {
            var d = a(l);
            if (!d || (t.hideQuickInfo && t.hideQuickInfo(), ot(l.target, ".gantt_grid_editor_placeholder"))) return false;
            var c = d.getAttribute(e.$config.item_attribute);
            if (s(c)) return false;
            var u = r().getItem(c);
            return !t.isReadonly(u) && (i.config.initial_open_state = u.$open, !!t.callEvent("onRowDragStart", [c, l.target || l.srcElement, l]) && void 0);
          }, t)), i.attachEvent("onAfterDragStart", t.bind(function(o, l) {
            var d = a(l);
            i.config.marker.innerHTML = d.outerHTML;
            var c = i.config.marker.firstChild;
            c && (c.style.position = "static"), i.config.id = d.getAttribute(e.$config.item_attribute);
            var u = r(), h = u.getItem(i.config.id);
            i.config.index = u.getBranchIndex(i.config.id), i.config.parent = h.parent, h.$open = false, h.$transparent = true, this.refreshData();
          }, t)), i.lastTaskOfLevel = function(o) {
            for (var l = null, d = r().getItems(), c = 0, u = d.length; c < u; c++) d[c].$level == o && (l = d[c]);
            return l ? l.id : null;
          }, i._getGridPos = t.bind(function(o) {
            var l = W(e.$grid_data), d = l.x + e.$grid.scrollLeft, c = o.pos.y - 10, u = e.getItemHeight(i.config.id);
            c < l.y && (c = l.y);
            var h = e.getTotalHeight();
            c > l.y + h - u && (c = l.y + h - u);
            const g = l.y + l.height;
            return c > g - u && (c = g - u), l.x = d, l.y = c, l;
          }, t), i._getTargetY = t.bind(function(o) {
            var l = W(e.$grid_data), d = e.$state.scrollTop || 0, c = t.$grid_data.getBoundingClientRect().height + d, u = o.pageY - l.y + d;
            return u > c ? u = c : u < d && (u = d), u;
          }, t), i._getTaskByY = t.bind(function(o, l) {
            var d = r();
            o = o || 0;
            var c = e.getItemIndexByTopPosition(o);
            return (c = l < c ? c - 1 : c) > d.countVisible() - 1 ? null : d.getIdByIndex(c);
          }, t), i.attachEvent("onDragMove", t.bind(function(o, l) {
            var d = t.$grid_data.getBoundingClientRect(), c = d.height + d.y + (e.$state.scrollTop || 0) + window.scrollY, u = i.config, h = i._getGridPos(l);
            t._waiAria.reorderMarkerAttr(u.marker);
            var g = e.$getConfig(), f = r();
            h.y < c ? u.marker.style.top = h.y + "px" : u.marker.style.top = c + "px", u.marker.style.left = h.x + 10 + "px";
            const y = W(t.$root);
            h.width > y.width && (u.marker.style.width = y.width - 10 - 2 + "px", u.marker.style.overflow = "hidden");
            var v = f.getItem(i.config.id), b = i._getTargetY(l), _ = i._getTaskByY(b, f.getIndexById(v.id));
            function m(D, A) {
              return !f.isChildOf(p.id, A.id) && (D.$level == A.$level || g.order_branch_free);
            }
            if (f.exists(_) || (_ = i.lastTaskOfLevel(g.order_branch_free ? v.$level : 0)) == i.config.id && (_ = null), f.exists(_)) {
              var p = f.getItem(_), k = e.getItemTop(p.id), $ = e.getItemHeight(p.id);
              if (k + $ / 2 < b) {
                var w = f.getIndexById(p.id), x = f.getNext(p.id), S = f.getItem(x);
                if (s(x)) {
                  var T = f.getPrev(S.id);
                  S = f.getItem(T);
                }
                if (S) {
                  if (S.id == v.id) return g.order_branch_free && f.isChildOf(v.id, p.id) && f.getChildren(p.id).length == 1 ? void f.move(v.id, f.getBranchIndex(p.id) + 1, f.getParent(p.id)) : void 0;
                  p = S;
                } else if (x = f.getIdByIndex(w), S = f.getItem(x), s(x) && (T = f.getPrev(S.id), S = f.getItem(T)), m(S, v) && S.id != v.id) return void f.move(v.id, -1, f.getParent(S.id));
              } else if (g.order_branch_free && p.id != v.id && m(p, v) && !s(p.id)) {
                if (!f.hasChild(p.id)) return p.$open = true, void f.move(v.id, -1, p.id);
                if (f.getIndexById(p.id) || $ / 3 < b) return;
              }
              w = f.getIndexById(p.id), T = f.getIdByIndex(w - 1);
              for (var E = f.getItem(T), C = 1; (!E || E.id == p.id) && w - C >= 0; ) T = f.getIdByIndex(w - C), E = f.getItem(T), C++;
              if (v.id == p.id || s(p.id)) return;
              m(p, v) && v.id != p.id ? f.move(v.id, 0, 0, p.id) : p.$level != v.$level - 1 || f.getChildren(p.id).length ? E && m(E, v) && v.id != E.id && f.move(v.id, -1, f.getParent(E.id)) : f.move(v.id, 0, p.id);
            }
            return true;
          }, t)), i.attachEvent("onDragEnd", t.bind(function() {
            var o = r(), l = o.getItem(i.config.id);
            l.$transparent = false, l.$open = i.config.initial_open_state, this.callEvent("onBeforeRowDragEnd", [i.config.id, i.config.parent, i.config.index]) === false ? (o.move(i.config.id, i.config.index, i.config.parent), l.$drop_target = null) : this.callEvent("onRowDragEnd", [i.config.id, l.$drop_target]), t.render(), this.refreshData();
          }, t));
        }
        function a(o) {
          return Z(o, e.$config.item_attribute);
        }
        function r() {
          return t.getDatastore(e.$config.bind);
        }
        function s(o) {
          return Et(o, t, r());
        }
      } }, K = { createDropTargetObject: function(t) {
        var e = { targetParent: null, targetIndex: 0, targetId: null, child: false, nextSibling: false, prevSibling: false };
        return t && N(e, t, true), e;
      }, nextSiblingTarget: function(t, e, n) {
        var i = this.createDropTargetObject();
        return i.targetId = e, i.nextSibling = true, i.targetParent = n.getParent(i.targetId), i.targetIndex = n.getBranchIndex(i.targetId), (n.getParent(t) != i.targetParent || i.targetIndex < n.getBranchIndex(t)) && (i.targetIndex += 1), i;
      }, prevSiblingTarget: function(t, e, n) {
        var i = this.createDropTargetObject();
        return i.targetId = e, i.prevSibling = true, i.targetParent = n.getParent(i.targetId), i.targetIndex = n.getBranchIndex(i.targetId), n.getParent(t) == i.targetParent && i.targetIndex > n.getBranchIndex(t) && (i.targetIndex -= 1), i;
      }, firstChildTarget: function(t, e, n) {
        var i = this.createDropTargetObject();
        return i.targetId = e, i.targetParent = i.targetId, i.targetIndex = 0, i.child = true, i;
      }, lastChildTarget: function(t, e, n) {
        var i = n.getChildren(e), a = this.createDropTargetObject();
        return a.targetId = i[i.length - 1], a.targetParent = e, a.targetIndex = i.length, a.nextSibling = true, a;
      } };
      function mn(t, e, n, i, a) {
        for (var r = e; i.exists(r); ) {
          var s = i.calculateItemLevel(i.getItem(r));
          if ((s === n || s === n - 1) && i.getBranchIndex(r) > -1) break;
          r = a ? i.getPrev(r) : i.getNext(r);
        }
        return i.exists(r) ? i.calculateItemLevel(i.getItem(r)) === n ? a ? K.nextSiblingTarget(t, r, i) : K.prevSiblingTarget(t, r, i) : K.firstChildTarget(t, r, i) : null;
      }
      function be(t, e, n, i) {
        return mn(t, e, n, i, true);
      }
      function vn(t, e, n, i) {
        return mn(t, e, n, i, false);
      }
      function kn(t, e, n, i, a, r) {
        var s;
        if (e !== a.$getRootId()) {
          var o = a.getItem(e), l = a.calculateItemLevel(o);
          if (l === r) {
            var d = a.getPrevSibling(e);
            n < 0.5 && !d ? s = K.prevSiblingTarget(t, e, a) : (n < 0.5 && (e = d), s = K.nextSiblingTarget(t, e, a));
          } else if (l > r) a.eachParent(function(f) {
            a.calculateItemLevel(f) === r && (e = f.id);
          }, o), s = be(t, e, r, a);
          else {
            var c = be(t, e, r, a), u = vn(t, e, r, a);
            s = n < 0.5 ? c : u;
          }
        } else {
          var h = a.$getRootId(), g = a.getChildren(h);
          s = K.createDropTargetObject(), s = g.length && i >= 0 ? be(t, function(f) {
            for (var y = f.getNext(); f.exists(y); ) {
              var v = f.getNext(y);
              if (!f.exists(v)) return y;
              y = v;
            }
            return null;
          }(a), r, a) : vn(t, h, r, a);
        }
        return s;
      }
      function yn(t, e) {
        var n = W(e.$grid_data);
        return t.x += n.x + e.$grid.scrollLeft, t.y += n.y - e.$grid_data.scrollTop, t;
      }
      function xe(t, e, n = 0) {
        const i = W(t.$root);
        return e > i.width && (e = i.width - n - 2), e;
      }
      const bn = { removeLineHighlight: function(t) {
        t.markerLine && t.markerLine.parentNode && t.markerLine.parentNode.removeChild(t.markerLine), t.markerLine = null;
      }, highlightPosition: function(t, e, n) {
        var i = function(r, s) {
          var o = W(s.$grid_data), l = et(r, s.$grid_data), d = o.x + s.$grid.scrollLeft, c = l.y - 10, u = s.getItemHeight(r.targetId);
          c < o.y && (c = o.y);
          var h = s.getTotalHeight();
          return c > o.y + h - u && (c = o.y + h - u), o.x = d, o.y = c, o.width = xe(s.$gantt, o.width, 9), o;
        }(t, n);
        e.marker.style.left = i.x + 9 + "px", e.marker.style.width = i.width + "px", e.marker.style.overflow = "hidden";
        var a = e.markerLine;
        a || ((a = document.createElement("div")).className = "gantt_drag_marker gantt_grid_dnd_marker", a.innerHTML = "<div class='gantt_grid_dnd_marker_line'></div>", a.style.pointerEvents = "none"), t.child ? function(r, s, o) {
          var l = r.targetParent, d = yn({ x: 0, y: o.getItemTop(l) }, o), c = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;
          let u = xe(o.$gantt, o.$grid_data.offsetWidth);
          s.innerHTML = "<div class='gantt_grid_dnd_marker_folder'></div>", s.style.width = u + "px", s.style.top = d.y + "px", s.style.left = d.x + "px", s.style.height = o.getItemHeight(l) + "px", d.y > c && (s.style.top = c + "px");
        }(t, a, n) : function(r, s, o) {
          var l = function(u, h) {
            var g = h.$config.rowStore, f = { x: 0, y: 0 }, y = h.$grid_data.querySelector(".gantt_tree_indent"), v = 15, b = 0;
            y && (v = y.offsetWidth);
            var _ = 40;
            if (u.targetId !== g.$getRootId()) {
              var m = h.getItemTop(u.targetId), p = h.getItemHeight(u.targetId);
              if (b = g.exists(u.targetId) ? g.calculateItemLevel(g.getItem(u.targetId)) : 0, u.prevSibling) f.y = m;
              else if (u.nextSibling) {
                var k = 0;
                g.eachItem(function($) {
                  g.getIndexById($.id) !== -1 && k++;
                }, u.targetId), f.y = m + p + k * p;
              } else f.y = m + p, b += 1;
            }
            return f.x = _ + b * v, f.width = xe(h.$gantt, Math.max(h.$grid_data.offsetWidth - f.x, 0), f.x), yn(f, h);
          }(r, o), d = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;
          s.innerHTML = "<div class='gantt_grid_dnd_marker_line'></div>", s.style.left = l.x + "px", s.style.height = "4px";
          var c = l.y - 2;
          s.style.top = c + "px", s.style.width = l.width + "px", c > d && (s.style.top = d + "px");
        }(t, a, n), e.markerLine || (document.body.appendChild(a), e.markerLine = a);
      } }, Pa = { init: function(t, e) {
        var n = t.$services.getService("dnd");
        if (e.$config.bind && t.getDatastore(e.$config.bind)) {
          var i = new n(e.$grid_data, { updates_per_second: 60 });
          t.defined(e.$getConfig().dnd_sensitivity) && (i.config.sensitivity = e.$getConfig().dnd_sensitivity), i.attachEvent("onBeforeDragStart", t.bind(function(o, l) {
            var d = a(l);
            if (!d || (t.hideQuickInfo && t.hideQuickInfo(), ot(l.target, ".gantt_grid_editor_placeholder"))) return false;
            var c = d.getAttribute(e.$config.item_attribute), u = e.$config.rowStore.getItem(c);
            return !t.isReadonly(u) && !r(c) && (i.config.initial_open_state = u.$open, !!t.callEvent("onRowDragStart", [c, l.target || l.srcElement, l]) && void 0);
          }, t)), i.attachEvent("onAfterDragStart", t.bind(function(o, l) {
            var d = a(l);
            i.config.marker.innerHTML = d.outerHTML;
            var c = i.config.marker.firstChild;
            c && (i.config.marker.style.opacity = 0.4, c.style.position = "static", c.style.pointerEvents = "none"), i.config.id = d.getAttribute(e.$config.item_attribute);
            var u = e.$config.rowStore, h = u.getItem(i.config.id);
            i.config.level = u.calculateItemLevel(h), i.config.drop_target = K.createDropTargetObject({ targetParent: u.getParent(h.id), targetIndex: u.getBranchIndex(h.id), targetId: h.id, nextSibling: true }), h.$open = false, h.$transparent = true, this.refreshData();
          }, t)), i.attachEvent("onDragMove", t.bind(function(o, l) {
            var d = s(l);
            return d && t.callEvent("onBeforeRowDragMove", [i.config.id, d.targetParent, d.targetIndex]) !== false || (d = K.createDropTargetObject(i.config.drop_target)), bn.highlightPosition(d, i.config, e), i.config.drop_target = d, t._waiAria.reorderMarkerAttr(i.config.marker), this.callEvent("onRowDragMove", [i.config.id, d.targetParent, d.targetIndex]), true;
          }, t)), i.attachEvent("onDragEnd", t.bind(function() {
            var o = e.$config.rowStore, l = o.getItem(i.config.id);
            bn.removeLineHighlight(i.config), l.$transparent = false, l.$open = i.config.initial_open_state;
            var d = i.config.drop_target;
            this.callEvent("onBeforeRowDragEnd", [i.config.id, d.targetParent, d.targetIndex]) === false ? l.$drop_target = null : (o.move(i.config.id, d.targetIndex, d.targetParent), t.render(), this.callEvent("onRowDragEnd", [i.config.id, d.targetParent, d.targetIndex])), o.refresh(l.id);
          }, t));
        }
        function a(o) {
          return Z(o, e.$config.item_attribute);
        }
        function r(o) {
          return Et(o, t, t.getDatastore(e.$config.bind));
        }
        function s(o) {
          var l, d = function(f) {
            var y = et(f, e.$grid_data).y, v = e.$config.rowStore;
            document.doctype || (y += window.scrollY), y = y || 0;
            var b = e.$state.scrollTop || 0, _ = t.$grid_data.getBoundingClientRect().height + b + window.scrollY, m = b, p = e.getItemIndexByTopPosition(e.$state.scrollTop);
            if (v.exists(p) || (p = v.countVisible() - 1), p < 0) return v.$getRootId();
            var k = v.getIdByIndex(p), $ = e.$state.scrollTop / e.getItemHeight(k), w = $ - Math.floor($);
            w > 0.1 && w < 0.9 && (_ -= e.getItemHeight(k) * w, m += e.getItemHeight(k) * (1 - w));
            const x = W(e.$grid_data), S = x.y + x.height, T = i.config.marker.offsetHeight;
            y + T + window.scrollY >= _ && (i.config.marker.style.top = S - T + "px"), y >= _ ? y = _ : y <= m && (y = m, i.config.marker.style.top = x.y + "px");
            var E = e.getItemIndexByTopPosition(y);
            if (E > v.countVisible() - 1 || E < 0) return v.$getRootId();
            var C = v.getIdByIndex(E);
            return r(C) ? v.getPrevSibling(C) : v.getIdByIndex(E);
          }(o), c = null, u = e.$config.rowStore, h = !e.$getConfig().order_branch_free, g = et(o, e.$grid_data).y;
          return document.doctype || (g += window.scrollY), d !== u.$getRootId() && (c = (g - e.getItemTop(d)) / e.getItemHeight(d)), h ? (l = kn(i.config.id, d, c, g, u, i.config.level)) && l.targetParent && r(l.targetParent) && (d = u.getPrevSibling(l.targetParent), l = kn(i.config.id, d, c, g, u, i.config.level)) : l = function(f, y, v, b, _) {
            var m;
            if (y !== _.$getRootId()) m = v < 0.25 ? K.prevSiblingTarget(f, y, _) : !(v > 0.6) || _.hasChild(y) && _.getItem(y).$open ? K.firstChildTarget(f, y, _) : K.nextSiblingTarget(f, y, _);
            else {
              var p = _.$getRootId();
              m = _.hasChild(p) && b >= 0 ? K.lastChildTarget(f, p, _) : K.firstChildTarget(f, p, _);
            }
            return m;
          }(i.config.id, d, c, g, u), l;
        }
      } };
      var Ra = function(t) {
        return { onCreated: function(e) {
          e.$config = N(e.$config, { bind: "task" }), e.$config.id == "grid" && (this.extendGantt(e), t.ext.inlineEditors = t.ext._inlineEditors.createEditors(e), t.ext.inlineEditors.init()), this._mouseDelegates = me(t);
        }, onInitialized: function(e) {
          var n = e.$getConfig();
          n.order_branch && (n.order_branch == "marker" ? Pa.init(e.$gantt, e) : La.init(e.$gantt, e)), this.initEvents(e, t), e.$config.id == "grid" && this.extendDom(e);
        }, onDestroyed: function(e) {
          e.$config.id == "grid" && t.ext.inlineEditors.detachStore(), this.clearEvents(e, t);
        }, initEvents: function(e, n) {
          this._mouseDelegates.delegate("click", "gantt_row", n.bind(function(i, a, r) {
            var s = e.$getConfig();
            if (a !== null) {
              var o = this.getTask(a);
              s.scroll_on_click && !n._is_icon_open_click(i) && this.showDate(o.start_date), n.callEvent("onTaskRowClick", [a, r]);
            }
          }, n), e.$grid), this._mouseDelegates.delegate("click", "gantt_grid_head_cell", n.bind(function(i, a, r) {
            var s = r.getAttribute("data-column-id");
            if (n.callEvent("onGridHeaderClick", [s, i])) {
              var o = e.$getConfig();
              if (s != "add") {
                if (o.sort && s) {
                  for (var l, d = s, c = 0; c < o.columns.length; c++) if (o.columns[c].name == s) {
                    l = o.columns[c];
                    break;
                  }
                  if (l && l.sort !== void 0 && l.sort !== true && !(d = l.sort)) return;
                  var u = this._sort && this._sort.direction && this._sort.name == s ? this._sort.direction : "desc";
                  u = u == "desc" ? "asc" : "desc", this._sort = { name: s, direction: u }, this.sort(d, u == "desc");
                }
              } else n.$services.getService("mouseEvents").callHandler("click", "gantt_add", e.$grid, [i, o.root_id]);
            }
          }, n), e.$grid), this._mouseDelegates.delegate("click", "gantt_add", n.bind(function(i, a, r) {
            if (!e.$getConfig().readonly) return this.createTask({}, a || n.config.root_id), false;
          }, n), e.$grid);
        }, clearEvents: function(e, n) {
          this._mouseDelegates.destructor(), this._mouseDelegates = null;
        }, extendDom: function(e) {
          t.$grid = e.$grid, t.$grid_scale = e.$grid_scale, t.$grid_data = e.$grid_data;
        }, extendGantt: function(e) {
          t.getGridColumns = t.bind(e.getGridColumns, e), e.attachEvent("onColumnResizeStart", function() {
            return t.callEvent("onColumnResizeStart", arguments);
          }), e.attachEvent("onColumnResize", function() {
            return t.callEvent("onColumnResize", arguments);
          }), e.attachEvent("onColumnResizeEnd", function() {
            return t.callEvent("onColumnResizeEnd", arguments);
          }), e.attachEvent("onColumnResizeComplete", function(n, i) {
            t.config.grid_width = i;
          }), e.attachEvent("onBeforeRowResize", function() {
            return t.callEvent("onBeforeRowResize", arguments);
          }), e.attachEvent("onRowResize", function() {
            return t.callEvent("onRowResize", arguments);
          }), e.attachEvent("onBeforeRowResizeEnd", function() {
            return t.callEvent("onBeforeRowResizeEnd", arguments);
          }), e.attachEvent("onAfterRowResize", function() {
            return t.callEvent("onAfterRowResize", arguments);
          });
        } };
      };
      const Ha = { createTaskDND: function() {
        var t;
        return { extend: function(e) {
          e.roundTaskDates = function(n) {
            t.round_task_dates(n);
          };
        }, init: function(e, n) {
          return t = function(i, a) {
            var r = a.$services;
            return { drag: null, dragMultiple: {}, _events: { before_start: {}, before_finish: {}, after_finish: {} }, _handlers: {}, init: function() {
              this._domEvents = a._createDomEventScope(), this.clear_drag_state();
              var s = a.config.drag_mode;
              this.set_actions(), r.getService("state").registerProvider("tasksDnd", R(function() {
                return { drag_id: this.drag ? this.drag.id : void 0, drag_mode: this.drag ? this.drag.mode : void 0, drag_from_start: this.drag ? this.drag.left : void 0 };
              }, this));
              var o = { before_start: "onBeforeTaskDrag", before_finish: "onBeforeTaskChanged", after_finish: "onAfterTaskDrag" };
              for (var l in this._events) for (var d in s) this._events[l][d] = o[l];
              this._handlers[s.move] = this._move, this._handlers[s.resize] = this._resize, this._handlers[s.progress] = this._resize_progress;
            }, set_actions: function() {
              var s = i.$task_data;
              this._domEvents.attach(s, "mousemove", a.bind(function(o) {
                this.on_mouse_move(o);
              }, this)), this._domEvents.attach(s, "mousedown", a.bind(function(o) {
                this.on_mouse_down(o);
              }, this)), this._domEvents.attach(document.body, "mouseup", a.bind(function(o) {
                this.on_mouse_up(o);
              }, this));
            }, clear_drag_state: function() {
              this.drag = { id: null, mode: null, pos: null, start_x: null, start_y: null, obj: null, left: null }, this.dragMultiple = {};
            }, _resize: function(s, o, l) {
              var d = i.$getConfig(), c = this._drag_task_coords(s, l);
              l.left ? (s.start_date = a.dateFromPos(c.start + o), s.start_date || (s.start_date = new Date(a.getState().min_date))) : (s.end_date = a.dateFromPos(c.end + o), s.end_date || (s.end_date = new Date(a.getState().max_date)));
              var u = this._calculateMinDuration(d.min_duration, d.duration_unit);
              s.end_date - s.start_date < d.min_duration && (l.left ? s.start_date = a.calculateEndDate(s.end_date, -u, d.duration_unit, s) : s.end_date = a.calculateEndDate(s.start_date, u, d.duration_unit, s)), a._init_task_timing(s);
            }, _calculateMinDuration: function(s, o) {
              return Math.ceil(s / { minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 31356e6 }[o]);
            }, _resize_progress: function(s, o, l) {
              var d = this._drag_task_coords(s, l), c = i.$getConfig().rtl ? d.start - l.pos.x : l.pos.x - d.start, u = Math.max(0, c);
              s.progress = Math.min(1, u / Math.abs(d.end - d.start));
            }, _find_max_shift: function(s, o) {
              var l;
              for (var d in s) {
                var c = s[d], u = a.getTask(c.id), h = this._drag_task_coords(u, c), g = a.posFromDate(new Date(a.getState().min_date)), f = a.posFromDate(new Date(a.getState().max_date));
                if (h.end + o > f) {
                  var y = f - h.end;
                  (y < l || l === void 0) && (l = y);
                } else if (h.start + o < g) {
                  var v = g - h.start;
                  (v > l || l === void 0) && (l = v);
                }
              }
              return l;
            }, _move: function(s, o, l, d) {
              var c = this._drag_task_coords(s, l), u = null, h = null;
              d ? (u = new Date(+l.obj.start_date + d), h = new Date(+l.obj.end_date + d)) : (u = a.dateFromPos(c.start + o), h = a.dateFromPos(c.end + o)), u ? h ? (s.start_date = u, s.end_date = h) : (s.end_date = new Date(a.getState().max_date), s.start_date = a.dateFromPos(a.posFromDate(s.end_date) - (c.end - c.start))) : (s.start_date = new Date(a.getState().min_date), s.end_date = a.dateFromPos(a.posFromDate(s.start_date) + (c.end - c.start)));
            }, _drag_task_coords: function(s, o) {
              return { start: o.obj_s_x = o.obj_s_x || a.posFromDate(s.start_date), end: o.obj_e_x = o.obj_e_x || a.posFromDate(s.end_date) };
            }, _mouse_position_change: function(s, o) {
              var l = s.x - o.x, d = s.y - o.y;
              return Math.sqrt(l * l + d * d);
            }, _is_number: function(s) {
              return !isNaN(parseFloat(s)) && isFinite(s);
            }, on_mouse_move: function(s) {
              if (this.drag.start_drag) {
                var o = et(s, a.$task_data), l = this.drag.start_drag.start_x, d = this.drag.start_drag.start_y;
                (Date.now() - this.drag.timestamp > 50 || this._is_number(l) && this._is_number(d) && this._mouse_position_change({ x: l, y: d }, o) > 20) && this._start_dnd(s);
              }
              if (this.drag.mode) {
                if (!Ue(this, 40)) return;
                this._update_on_move(s);
              }
            }, _update_item_on_move: function(s, o, l, d, c, u) {
              var h = a.getTask(o), g = a.mixin({}, h), f = a.mixin({}, h);
              this._handlers[l].apply(this, [f, s, d, u]), a.mixin(h, f, true), a.callEvent("onTaskDrag", [h.id, l, f, g, c]), a.mixin(h, f, true), a.refreshTask(o);
            }, _update_on_move: function(s) {
              var o = this.drag, l = i.$getConfig();
              if (o.mode) {
                var d = et(s, i.$task_data);
                if (o.pos && o.pos.x == d.x) return;
                o.pos = d;
                var c = a.dateFromPos(d.x);
                if (!c || isNaN(c.getTime())) return;
                var u = d.x - o.start_x, h = a.getTask(o.id);
                if (this._handlers[o.mode]) {
                  if (o.mode === l.drag_mode.move) {
                    var g = {};
                    this._isMultiselect() && a.getSelectedTasks().indexOf(o.id) >= 0 && (g = this.dragMultiple);
                    var f = false;
                    if (a.isSummaryTask(h) && a.config.drag_project) {
                      var y = {};
                      y[o.id] = V(o), f = true, g = N(y, this.dragMultiple);
                    }
                    var v = this._find_max_shift(g, u);
                    for (var b in v !== void 0 && (u = v), this._update_item_on_move(u, o.id, o.mode, o, s), g) {
                      var _ = g[b];
                      if (f && _.id != o.id && (a._bulk_dnd = true), v === void 0 && (f || Object.keys(g).length > 1)) var m = c - a.dateFromPos(o.start_x);
                      this._update_item_on_move(u, _.id, _.mode, _, s, m);
                    }
                    a._bulk_dnd = false;
                  } else this._update_item_on_move(u, o.id, o.mode, o, s);
                  a._update_parents(o.id);
                }
              }
            }, on_mouse_down: function(s, o) {
              if (s.button != 2 || s.button === void 0) {
                var l = i.$getConfig(), d = a.locate(s), c = null;
                if (a.isTaskExists(d) && (c = a.getTask(d)), !a.isReadonly(c) && !this.drag.mode) {
                  this.clear_drag_state();
                  var u = Y(o = o || s.target || s.srcElement), h = this._get_drag_mode(u, o);
                  if (!u || !h) return o.parentNode ? this.on_mouse_down(s, o.parentNode) : void 0;
                  if (h) if (h.mode && h.mode != l.drag_mode.ignore && l["drag_" + h.mode]) {
                    if (d = a.locate(o), c = a.copy(a.getTask(d) || {}), a.isReadonly(c)) return this.clear_drag_state(), false;
                    if (a.isSummaryTask(c) && c.auto_scheduling !== false && !l.drag_project && h.mode != l.drag_mode.progress) return void this.clear_drag_state();
                    h.id = d;
                    var g = et(s, a.$task_data);
                    h.start_x = g.x, h.start_y = g.y, h.obj = c, this.drag.start_drag = h, this.drag.timestamp = Date.now();
                  } else this.clear_drag_state();
                  else if (a.checkEvent("onMouseDown") && a.callEvent("onMouseDown", [u.split(" ")[0]]) && o.parentNode) return this.on_mouse_down(s, o.parentNode);
                }
              }
            }, _fix_dnd_scale_time: function(s, o) {
              var l = i.$getConfig(), d = a.getScale().unit, c = a.getScale().step;
              function u(h) {
                if (a.config.correct_work_time) {
                  var g = i.$getConfig();
                  a.isWorkTime(h.start_date, void 0, h) || (h.start_date = a.calculateEndDate({ start_date: h.start_date, duration: -1, unit: g.duration_unit, task: h }));
                }
              }
              l.round_dnd_dates || (d = "minute", c = l.time_step), o.mode == l.drag_mode.resize ? o.left ? (s.start_date = a.roundDate({ date: s.start_date, unit: d, step: c }), u(s)) : (s.end_date = a.roundDate({ date: s.end_date, unit: d, step: c }), function(h) {
                if (a.config.correct_work_time) {
                  var g = i.$getConfig();
                  a.isWorkTime(new Date(h.end_date - 1), void 0, h) || (h.end_date = a.calculateEndDate({ start_date: h.end_date, duration: 1, unit: g.duration_unit, task: h }));
                }
              }(s)) : o.mode == l.drag_mode.move && (s.start_date = a.roundDate({ date: s.start_date, unit: d, step: c }), u(s), s.end_date = a.calculateEndDate(s));
            }, _fix_working_times: function(s, o) {
              var l = i.$getConfig();
              (o = o || { mode: l.drag_mode.move }).mode == l.drag_mode.resize ? o.left ? s.start_date = a.getClosestWorkTime({ date: s.start_date, dir: "future", task: s }) : s.end_date = a.getClosestWorkTime({ date: s.end_date, dir: "past", task: s }) : o.mode == l.drag_mode.move && a.correctTaskWorkTime(s);
            }, _finalize_mouse_up: function(s, o, l, d) {
              var c = a.getTask(s);
              if (o.work_time && o.correct_work_time && this._fix_working_times(c, l), this._fix_dnd_scale_time(c, l), this._fireEvent("before_finish", l.mode, [s, l.mode, a.copy(l.obj), d])) {
                var u = s;
                a._init_task_timing(c), this.clear_drag_state(), a.updateTask(c.id), this._fireEvent("after_finish", l.mode, [u, l.mode, d]);
              } else this.clear_drag_state(), s == l.id && (l.obj._dhx_changed = false, a.mixin(c, l.obj, true)), a.refreshTask(c.id);
            }, on_mouse_up: function(s) {
              var o = this.drag;
              if (o.mode && o.id) {
                var l = i.$getConfig(), d = a.getTask(o.id), c = this.dragMultiple, u = false, h = 0;
                o.mode === l.drag_mode.move && (a.isSummaryTask(d) && l.drag_project || this._isMultiselect()) && (u = true, h = Object.keys(c).length);
                var g = function() {
                  if (u) for (var f in c) c[f].id != o.id && this._finalize_mouse_up(c[f].id, l, c[f], s);
                  this._finalize_mouse_up(o.id, l, o, s);
                };
                u && h > 10 ? a.batchUpdate(function() {
                  g.call(this);
                }.bind(this)) : g.call(this);
              }
              this.clear_drag_state();
            }, _get_drag_mode: function(s, o) {
              var l = i.$getConfig().drag_mode, d = { mode: null, left: null };
              switch ((s || "").split(" ")[0]) {
                case "gantt_task_line":
                case "gantt_task_content":
                  d.mode = l.move;
                  break;
                case "gantt_task_drag":
                  d.mode = l.resize;
                  var c = o.getAttribute("data-bind-property");
                  d.left = c == "start_date";
                  break;
                case "gantt_task_progress_drag":
                  d.mode = l.progress;
                  break;
                case "gantt_link_control":
                case "gantt_link_point":
                  d.mode = l.ignore;
                  break;
                default:
                  d = null;
              }
              return d;
            }, _start_dnd: function(s) {
              var o = this.drag = this.drag.start_drag;
              delete o.start_drag;
              var l = i.$getConfig(), d = o.id;
              if (l["drag_" + o.mode] && a.callEvent("onBeforeDrag", [d, o.mode, s]) && this._fireEvent("before_start", o.mode, [d, o.mode, s])) {
                delete o.start_drag;
                var c = a.getTask(d);
                if (a.isReadonly(c)) return void this.clear_drag_state();
                if (this._isMultiselect()) {
                  var u = a.getSelectedTasks();
                  u.indexOf(o.id) >= 0 && kt(u, a.bind(function(h) {
                    var g = a.getTask(h);
                    a.isSummaryTask(g) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(g.id), this.dragMultiple[h] = a.mixin({ id: g.id, obj: a.copy(g) }, this.drag);
                  }, this));
                }
                a.isSummaryTask(c) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(c.id), a.callEvent("onTaskDragStart", []);
              } else this.clear_drag_state();
            }, _fireEvent: function(s, o, l) {
              a.assert(this._events[s], "Invalid stage:{" + s + "}");
              var d = this._events[s][o];
              return a.assert(d, "Unknown after drop mode:{" + o + "}"), a.assert(l, "Invalid event arguments"), !a.checkEvent(d) || a.callEvent(d, l);
            }, round_task_dates: function(s) {
              var o = this.drag, l = i.$getConfig();
              o || (o = { mode: l.drag_mode.move }), this._fix_dnd_scale_time(s, o);
            }, destructor: function() {
              this._domEvents.detachAll();
            }, _isMultiselect: function() {
              return a.config.drag_multiple && !!(a.getSelectedTasks && a.getSelectedTasks().length > 0);
            }, _addSubtasksToDragMultiple: function(s) {
              a.eachTask(function(o) {
                this.dragMultiple[o.id] = a.mixin({ id: o.id, obj: a.copy(o) }, this.drag);
              }, s, this);
            } };
          }(e, n), e._tasks_dnd = t, t.init(n);
        }, destructor: function() {
          t && (t.destructor(), t = null);
        } };
      } };
      var Oa = function(t, e) {
        var n, i, a, r, s;
        function o() {
          return { link_source_id: r, link_target_id: i, link_from_start: s, link_to_start: a, link_landing_area: n };
        }
        var l = e.$services, d = l.getService("state"), c = l.getService("dnd");
        d.registerProvider("linksDnD", o);
        var u = "gantt_link_point", h = "gantt_link_control", g = new c(t.$task_bars, { sensitivity: 0, updates_per_second: 60, mousemoveContainer: e.$root, selector: "." + u, preventDefault: true });
        function f(m, p) {
          var k, $ = g.getPosition(m), w = function(A) {
            var I = 0, M = 0;
            return A && (I = A.offsetWidth || 0, M = A.offsetHeight || 0), { width: I, height: M };
          }(p), x = { right: (k = e.$root).offsetWidth, bottom: k.offsetHeight }, S = e.config.tooltip_offset_x || 10, T = e.config.tooltip_offset_y || 10, E = e.config.scroll_size || 18, C = e.$container.getBoundingClientRect().y + window.scrollY, D = { y: $.y + T, x: $.x + S, bottom: $.y + w.height + T + E, right: $.x + w.width + S + E };
          return D.bottom > x.bottom + C && (D.y = x.bottom + C - w.height - T), D.right > x.right && (D.x = x.right - w.width - S), D;
        }
        function y(m) {
          var p = o();
          p.link_source_id && p.link_target_id && e.isLinkAllowed(p.link_source_id, p.link_target_id, p.link_from_start, p.link_to_start);
          var k = "<div class='" + e.templates.drag_link_class(p.link_source_id, p.link_from_start, p.link_target_id, p.link_to_start) + "'>" + e.templates.drag_link(p.link_source_id, p.link_from_start, p.link_target_id, p.link_to_start) + "</div>";
          m.innerHTML = k;
        }
        function v() {
          r = s = i = null, a = true;
        }
        function b(m, p, k, $) {
          var w = function() {
            return g._direction && g._direction.parentNode || (g._direction = document.createElement("div"), t.$task_links.appendChild(g._direction)), g._direction;
          }(), x = o(), S = ["gantt_link_direction"];
          e.templates.link_direction_class && S.push(e.templates.link_direction_class(x.link_source_id, x.link_from_start, x.link_target_id, x.link_to_start));
          var T = Math.sqrt(Math.pow(k - m, 2) + Math.pow($ - p, 2));
          if (T = Math.max(0, T - 3)) {
            w.className = S.join(" ");
            var E = ($ - p) / (k - m), C = Math.atan(E);
            _(m, k, p, $) == 2 ? C += Math.PI : _(m, k, p, $) == 3 && (C -= Math.PI);
            var D = Math.sin(C), A = Math.cos(C), I = Math.round(p), M = Math.round(m), L = ["-webkit-transform: rotate(" + C + "rad)", "-moz-transform: rotate(" + C + "rad)", "-ms-transform: rotate(" + C + "rad)", "-o-transform: rotate(" + C + "rad)", "transform: rotate(" + C + "rad)", "width:" + Math.round(T) + "px"];
            if (window.navigator.userAgent.indexOf("MSIE 8.0") != -1) {
              L.push('-ms-filter: "' + function(U, gt) {
                return "progid:DXImageTransform.Microsoft.Matrix(M11 = " + gt + ",M12 = -" + U + ",M21 = " + U + ",M22 = " + gt + ",SizingMethod = 'auto expand')";
              }(D, A) + '"');
              var P = Math.abs(Math.round(m - k)), H = Math.abs(Math.round($ - p));
              switch (_(m, k, p, $)) {
                case 1:
                  I -= H;
                  break;
                case 2:
                  M -= P, I -= H;
                  break;
                case 3:
                  M -= P;
              }
            }
            L.push("top:" + I + "px"), L.push("left:" + M + "px"), w.style.cssText = L.join(";");
          }
        }
        function _(m, p, k, $) {
          return p >= m ? $ <= k ? 1 : 4 : $ <= k ? 2 : 3;
        }
        g.attachEvent("onBeforeDragStart", e.bind(function(m, p) {
          var k = p.target || p.srcElement;
          if (v(), e.getState("tasksDnd").drag_id) return false;
          if (ut(k, u)) {
            ut(k, "task_start_date") && (s = true);
            var $ = e.locate(p);
            r = $;
            var w = e.getTask($);
            return e.isReadonly(w) ? (v(), false) : (this._dir_start = { x: g.config.original_element_sizes.x + g.config.original_element_sizes.width / 2, y: g.config.original_element_sizes.y + g.config.original_element_sizes.height / 2 }, true);
          }
          return false;
        }, this)), g.attachEvent("onAfterDragStart", e.bind(function(m, p) {
          e.config.touch && e.refreshData(), y(g.config.marker);
        }, this)), g.attachEvent("onDragMove", e.bind(function(m, p) {
          var k = g.config, $ = f(p, k.marker);
          (function(A, I) {
            A.style.left = I.x + "px", A.style.top = I.y + "px";
          })(k.marker, $);
          var w = !!ut(p, h), x = i, S = n, T = a, E = e.locate(p), C = true;
          if (G(mt(p), e.$root) || (w = false, E = null), w && (C = !ut(p, "task_end_date"), w = !!E), i = E, n = w, a = C, w) {
            const A = ut(p, h).querySelector(`.${u}`);
            if (A) {
              const I = Ae(A, t.$task_bg);
              this._dir_end = { x: I.x + A.offsetWidth / 2, y: I.y + A.offsetHeight / 2 };
            }
          } else this._dir_end = et(p, t.$task_data), e.env.isEdge && (this._dir_end.y += window.scrollY);
          var D = !(S == w && x == E && T == C);
          return D && (x && e.refreshTask(x, false), E && e.refreshTask(E, false)), D && y(k.marker), b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y), true;
        }, this)), g.attachEvent("onDragEnd", e.bind(function() {
          var m = o();
          if (m.link_source_id && m.link_target_id && m.link_source_id != m.link_target_id) {
            var p = e._get_link_type(m.link_from_start, m.link_to_start), k = { source: m.link_source_id, target: m.link_target_id, type: p };
            k.type && e.isLinkAllowed(k) && e.callEvent("onLinkCreated", [k]) && e.addLink(k);
          }
          v(), e.config.touch ? e.refreshData() : (m.link_source_id && e.refreshTask(m.link_source_id, false), m.link_target_id && e.refreshTask(m.link_target_id, false)), g._direction && (g._direction.parentNode && g._direction.parentNode.removeChild(g._direction), g._direction = null);
        }, this)), e.attachEvent("onGanttRender", e.bind(function() {
          g._direction && b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y);
        }, this));
      };
      const Ba = function() {
        return { init: Oa };
      };
      var za = function(t) {
        var e = t.$services;
        return { onCreated: function(n) {
          var i = n.$config;
          i.bind = j(i.bind) ? i.bind : "task", i.bindLinks = j(i.bindLinks) ? i.bindLinks : "link", n._linksDnD = Ba(), n._tasksDnD = Ha.createTaskDND(), n._tasksDnD.extend(n), this._mouseDelegates = me(t);
        }, onInitialized: function(n) {
          this._attachDomEvents(t), this._attachStateProvider(t, n), n._tasksDnD.init(n, t), n._linksDnD.init(n, t), n.$config.id == "timeline" && this.extendDom(n);
        }, onDestroyed: function(n) {
          this._clearDomEvents(t), this._clearStateProvider(t), n._tasksDnD && n._tasksDnD.destructor();
        }, extendDom: function(n) {
          t.$task = n.$task, t.$task_scale = n.$task_scale, t.$task_data = n.$task_data, t.$task_bg = n.$task_bg, t.$task_links = n.$task_links, t.$task_bars = n.$task_bars;
        }, _clearDomEvents: function() {
          this._mouseDelegates.destructor(), this._mouseDelegates = null;
        }, _attachDomEvents: function(n) {
          function i(a, r) {
            if (a && this.callEvent("onLinkDblClick", [a, r])) {
              var s = this.getLink(a);
              if (this.isReadonly(s)) return;
              var o = this.locale.labels.link + " " + this.templates.link_description(this.getLink(a)) + " " + this.locale.labels.confirm_link_deleting;
              window.setTimeout(function() {
                n._simple_confirm(o, "", function() {
                  n.deleteLink(a);
                });
              }, this.config.touch ? 300 : 1);
            }
          }
          this._mouseDelegates.delegate("click", "gantt_task_link", n.bind(function(a, r) {
            var s = this.locate(a, this.config.link_attribute);
            s && this.callEvent("onLinkClick", [s, a]);
          }, n), this.$task), this._mouseDelegates.delegate("click", "gantt_scale_cell", n.bind(function(a, r) {
            var s = et(a, n.$task_data), o = n.dateFromPos(s.x), l = Math.floor(n.columnIndexByDate(o)), d = n.getScale().trace_x[l];
            n.callEvent("onScaleClick", [a, d]);
          }, n), this.$task), this._mouseDelegates.delegate("doubleclick", "gantt_task_link", n.bind(function(a, r, s) {
            r = this.locate(a, n.config.link_attribute), i.call(this, r, a);
          }, n), this.$task), this._mouseDelegates.delegate("doubleclick", "gantt_link_point", n.bind(function(a, r, s) {
            r = this.locate(a);
            var o = this.getTask(r), l = null;
            return s.parentNode && Y(s.parentNode) && (l = Y(s.parentNode).indexOf("_left") > -1 ? o.$target[0] : o.$source[0]), l && i.call(this, l, a), false;
          }, n), this.$task);
        }, _attachStateProvider: function(n, i) {
          var a = i;
          e.getService("state").registerProvider("tasksTimeline", function() {
            return { scale_unit: a._tasks ? a._tasks.unit : void 0, scale_step: a._tasks ? a._tasks.step : void 0 };
          });
        }, _clearStateProvider: function() {
          e.getService("state").unregisterProvider("tasksTimeline");
        } };
      }, Wa = function(t) {
        return { getVerticalScrollbar: function() {
          return t.$ui.getView("scrollVer");
        }, getHorizontalScrollbar: function() {
          return t.$ui.getView("scrollHor");
        }, _legacyGridResizerClass: function(e) {
          for (var n = e.getCellsByType("resizer"), i = 0; i < n.length; i++) {
            var a = n[i], r = false, s = a.$parent.getPrevSibling(a.$id);
            if (s && s.$config && s.$config.id === "grid") r = true;
            else {
              var o = a.$parent.getNextSibling(a.$id);
              o && o.$config && o.$config.id === "grid" && (r = true);
            }
            r && (a.$config.css = (a.$config.css ? a.$config.css + " " : "") + "gantt_grid_resize_wrap");
          }
        }, onCreated: function(e) {
          var n = true;
          this._legacyGridResizerClass(e), e.attachEvent("onBeforeResize", function() {
            var i = t.$ui.getView("timeline");
            i && (i.$config.hidden = i.$parent.$config.hidden = !t.config.show_chart);
            var a = t.$ui.getView("grid");
            if (a) {
              var r = a._getColsTotalWidth(), s = !t.config.show_grid || !t.config.grid_width || r === 0;
              if (n && !s && r !== false && (t.config.grid_width = r), a.$config.hidden = a.$parent.$config.hidden = s, !a.$config.hidden) {
                var o = a._getGridWidthLimits();
                if (o[0] && t.config.grid_width < o[0] && (t.config.grid_width = o[0]), o[1] && t.config.grid_width > o[1] && (t.config.grid_width = o[1]), i && t.config.show_chart) {
                  if (a.$config.width = t.config.grid_width - 1, !a.$config.scrollable && a.$config.scrollY && t.$root.offsetWidth) {
                    var l = a.$gantt.$layout.$container.offsetWidth, d = t.$ui.getView(a.$config.scrollY).$config.width, c = l - (a.$config.width + d) - 4;
                    c < 0 && (a.$config.width += c, t.config.grid_width += c);
                  }
                  if (n) a.$parent.$config.width = t.config.grid_width, a.$parent.$config.group && t.$layout._syncCellSizes(a.$parent.$config.group, { value: a.$parent.$config.width, isGravity: false });
                  else if (i && !G(i.$task, e.$view)) {
                    if (!a.$config.original_grid_width) {
                      var u = t.skins[t.skin];
                      u && u.config && u.config.grid_width ? a.$config.original_grid_width = u.config.grid_width : a.$config.original_grid_width = 0;
                    }
                    t.config.grid_width = a.$config.original_grid_width, a.$parent.$config.width = t.config.grid_width;
                  } else a.$parent._setContentSize(a.$config.width, null), t.$layout._syncCellSizes(a.$parent.$config.group, { value: t.config.grid_width, isGravity: false });
                } else i && G(i.$task, e.$view) && (a.$config.original_grid_width = t.config.grid_width), n || (a.$parent.$config.width = 0);
              }
              n = false;
            }
          }), this._initScrollStateEvents(e);
        }, _initScrollStateEvents: function(e) {
          t._getVerticalScrollbar = this.getVerticalScrollbar, t._getHorizontalScrollbar = this.getHorizontalScrollbar;
          var n = this.getVerticalScrollbar(), i = this.getHorizontalScrollbar();
          n && n.attachEvent("onScroll", function(a, r, s) {
            var o = t.getScrollState();
            t.callEvent("onGanttScroll", [o.x, a, o.x, r]);
          }), i && i.attachEvent("onScroll", function(a, r, s) {
            var o = t.getScrollState();
            t.callEvent("onGanttScroll", [a, o.y, r, o.y]);
            var l = t.$ui.getView("grid");
            l && l.$grid_data && !l.$config.scrollable && (l.$grid_data.style.left = l.$grid.scrollLeft + "px", l.$grid_data.scrollLeft = l.$grid.scrollLeft);
          }), e.attachEvent("onResize", function() {
            n && !t.$scroll_ver && (t.$scroll_ver = n.$scroll_ver), i && !t.$scroll_hor && (t.$scroll_hor = i.$scroll_hor);
          });
        }, _findGridResizer: function(e, n) {
          for (var i, a = e.getCellsByType("resizer"), r = true, s = 0; s < a.length; s++) {
            var o = a[s];
            o._getSiblings();
            var l = o._behind, d = o._front;
            if (l && l.$content === n || l.isChild && l.isChild(n)) {
              i = o, r = true;
              break;
            }
            if (d && d.$content === n || d.isChild && d.isChild(n)) {
              i = o, r = false;
              break;
            }
          }
          return { resizer: i, gridFirst: r };
        }, onInitialized: function(e) {
          var n = t.$ui.getView("grid"), i = this._findGridResizer(e, n);
          if (i.resizer) {
            var a, r = i.gridFirst, s = i.resizer;
            if (s.$config.mode !== "x") return;
            s.attachEvent("onResizeStart", function(o, l) {
              var d = t.$ui.getView("grid"), c = d ? d.$parent : null;
              if (c) {
                var u = d._getGridWidthLimits();
                d.$config.scrollable || (c.$config.minWidth = u[0]), c.$config.maxWidth = u[1];
              }
              return a = r ? o : l, t.callEvent("onGridResizeStart", [a]);
            }), s.attachEvent("onResize", function(o, l) {
              var d = r ? o : l;
              return t.callEvent("onGridResize", [a, d]);
            }), s.attachEvent("onResizeEnd", function(o, l, d, c) {
              var u = r ? o : l, h = r ? d : c, g = t.$ui.getView("grid"), f = g ? g.$parent : null;
              f && (f.$config.minWidth = void 0);
              var y = t.callEvent("onGridResizeEnd", [u, h]);
              return y && h !== 0 && (t.config.grid_width = h), y;
            });
          }
        }, onDestroyed: function(e) {
        } };
      };
      const ja = { init: function(t) {
        function e(r, s) {
          var o = s(t);
          o.onCreated && o.onCreated(r), r.attachEvent("onReady", function() {
            o.onInitialized && o.onInitialized(r);
          }), r.attachEvent("onDestroy", function() {
            o.onDestroyed && o.onDestroyed(r);
          });
        }
        var n = la(t);
        n.registerView("cell", It), n.registerView("resizer", null), n.registerView("scrollbar", fa), n.registerView("layout", un, function(r) {
          (r.$config ? r.$config.id : null) === "main" && e(r, Wa);
        }), n.registerView("viewcell", ga), n.registerView("multiview", _a), n.registerView("timeline", Vt, function(r) {
          (r.$config ? r.$config.id : null) !== "timeline" && r.$config.bind != "task" || e(r, za);
        }), n.registerView("grid", ve, function(r) {
          (r.$config ? r.$config.id : null) !== "grid" && r.$config.bind != "task" || e(r, Ra);
        }), n.registerView("resourceGrid", ve), n.registerView("resourceTimeline", Vt), n.registerView("resourceHistogram", Vt);
        var i = function(r) {
          var s = ua(r);
          return { getDataRender: function(o) {
            return r.$services.getService("layer:" + o) || null;
          }, createDataRender: function(o) {
            var l = o.name, d = o.defaultContainer, c = o.defaultContainerSibling, u = s.createGroup(d, c, function(h, g) {
              if (!u.filters) return true;
              for (var f = 0; f < u.filters.length; f++) if (u.filters[f](h, g) === false) return false;
            }, ha);
            return r.$services.setService("layer:" + l, function() {
              return u;
            }), r.attachEvent("onGanttReady", function() {
              u.addLayer();
            }), u;
          }, init: function() {
            var o = this.createDataRender({ name: "task", defaultContainer: function() {
              return r.$task_data ? r.$task_data : r.$ui.getView("timeline") ? r.$ui.getView("timeline").$task_data : void 0;
            }, defaultContainerSibling: function() {
              return r.$task_links ? r.$task_links : r.$ui.getView("timeline") ? r.$ui.getView("timeline").$task_links : void 0;
            }, filter: function(d) {
            } }, r), l = this.createDataRender({ name: "link", defaultContainer: function() {
              return r.$task_data ? r.$task_data : r.$ui.getView("timeline") ? r.$ui.getView("timeline").$task_data : void 0;
            } }, r);
            return { addTaskLayer: function(d) {
              const c = _t;
              return typeof d == "function" ? d = { renderer: { render: d, getVisibleRange: c } } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c), d.view = "timeline", o.addLayer(d);
            }, _getTaskLayers: function() {
              return o.getLayers();
            }, removeTaskLayer: function(d) {
              o.removeLayer(d);
            }, _clearTaskLayers: function() {
              o.clear();
            }, addLinkLayer: function(d) {
              const c = dn();
              return typeof d == "function" ? d = { renderer: { render: d, getVisibleRange: c } } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c), d.view = "timeline", d && d.renderer && (d.renderer.getRectangle || d.renderer.isInViewPort || (d.renderer.isInViewPort = cn)), l.addLayer(d);
            }, _getLinkLayers: function() {
              return l.getLayers();
            }, removeLinkLayer: function(d) {
              l.removeLayer(d);
            }, _clearLinkLayers: function() {
              l.clear();
            } };
          } };
        }(t), a = Da(t);
        return t.ext.inlineEditors = a, t.ext._inlineEditors = a, a.init(t), { factory: n, mouseEvents: ca.init(t), layersApi: i.init(), render: { gridLine: function() {
          return /* @__PURE__ */ function(r) {
            return { render: function(s, o, l, d) {
              for (var c = o.getGridColumns(), u = o.$getTemplates(), h = o.$config.rowStore, g = [], f = 0; f < c.length; f++) {
                var y, v, b, _ = f == c.length - 1, m = c[f];
                m.name == "add" ? (v = "<div " + (S = r._waiAria.gridAddButtonAttrString(m)) + " class='gantt_add'></div>", b = "") : (J(v = m.template ? m.template(s) : s[m.name]) && (v = u.date_grid(v, s, m.name)), v == null && (v = ""), b = v, v = "<div class='gantt_tree_content'>" + v + "</div>");
                var p = "gantt_cell" + (_ ? " gantt_last_cell" : ""), k = [];
                if (m.tree) {
                  p += " gantt_cell_tree";
                  for (var $ = 0; $ < s.$level; $++) k.push(u.grid_indent(s));
                  !h.hasChild(s.id) || r.isSplitTask(s) && !r.config.open_split_tasks ? (k.push(u.grid_blank(s)), k.push(u.grid_file(s))) : (k.push(u.grid_open(s)), k.push(u.grid_folder(s)));
                }
                var w = "width:" + (m.width - (_ ? 1 : 0)) + "px;";
                if (this.defined(m.align)) {
                  var x = { right: "flex-end", left: "flex-start", center: "center" }[m.align];
                  w += "text-align:" + m.align + ";justify-content:" + x + ";";
                }
                var S = r._waiAria.gridCellAttrString(m, b, s);
                k.push(v), y = "<div class='" + p + "' data-column-index='" + f + "' data-column-name='" + m.name + "' style='" + w + "' " + S + ">" + k.join("") + "</div>", g.push(y);
              }
              switch (p = "", h.$config.name) {
                case "task":
                  p = r.getGlobalTaskIndex(s.id) % 2 == 0 ? "" : " odd";
                  break;
                case "resource":
                  p = h.visibleOrder.indexOf(s.id) % 2 == 0 ? "" : " odd";
              }
              if (p += s.$transparent ? " gantt_transparent" : "", p += s.$dataprocessor_class ? " " + s.$dataprocessor_class : "", u.grid_row_class) {
                var T = u.grid_row_class.call(r, s.start_date, s.end_date, s);
                T && (p += " " + T);
              }
              h.isSelected(s.id) && (p += " gantt_selected");
              var E = document.createElement("div");
              E.className = "gantt_row" + p + " gantt_row_" + r.getTaskType(s.type);
              var C = o.getItemHeight(s.id);
              return E.style.height = C + "px", E.style.lineHeight = C + "px", l.smart_rendering && (E.style.position = "absolute", E.style.left = "0px", E.style.top = o.getItemTop(s.id) + "px"), o.$config.item_attribute && (E.setAttribute(o.$config.item_attribute, s.id), E.setAttribute(o.$config.bind + "_id", s.id)), r._waiAria.taskRowAttr(s, E), E.innerHTML = g.join(""), E;
            }, update: null, getRectangle: Ft, isInViewPort: Ma, getVisibleRange: _t, onrender: function(s, o, l) {
              for (var d = l.getGridColumns(), c = 0; c < d.length; c++) {
                var u = d[c];
                if (u.onrender) {
                  var h = o.querySelector("[data-column-name=" + u.name + "]");
                  if (h) {
                    var g = u.onrender(s, h);
                    if (g && typeof g == "string") h.innerHTML = g;
                    else if (g && typeof g == "object" && r.config.external_render) {
                      var f = r.config.external_render;
                      f.isElement(g) && f.renderElement(g, h);
                    }
                  }
                }
              }
            } };
          }(t);
        }, taskBg: function() {
          return /* @__PURE__ */ function(r) {
            var s = {}, o = {};
            function l(g, f) {
              return !(!s[g.id][f] || !s[g.id][f].parentNode);
            }
            function d(g, f) {
              s[g] && s[g][f] && s[g][f].parentNode && s[g][f].parentNode.removeChild(s[g][f]);
            }
            function c(g) {
              var f, y = g.$getTemplates();
              return y.task_cell_class !== void 0 ? (f = y.task_cell_class, (console.warn || console.log)("gantt.templates.task_cell_class template is deprecated and will be removed soon. Please use gantt.templates.timeline_cell_class instead.")) : f = y.timeline_cell_class, f;
            }
            function u(g) {
              return g.$getTemplates().timeline_cell_content;
            }
            function h(g, f, y, v, b, _, m, p) {
              var k = g.width[f], $ = "";
              if (ye(f, g, v, r)) {
                var w = _(y, g.trace_x[f]), x = "";
                if (m && (x = m(y, g.trace_x[f])), p.static_background) {
                  var S = !(!w && !x);
                  if (!p.static_background_cells || !S) return null;
                }
                if (s[y.id][f]) return o[y.id][f] = f, s[y.id][f];
                var T = document.createElement("div");
                return T.style.width = k + "px", $ = "gantt_task_cell" + (f == b - 1 ? " gantt_last_cell" : ""), w && ($ += " " + w), T.className = $, x && (T.innerHTML = x), T.style.position = "absolute", T.style.left = g.left[f] + "px", s[y.id][f] = T, o[y.id][f] = f, T;
              }
              return null;
            }
            return { render: function(g, f, y, v) {
              var b = f.$getTemplates(), _ = f.getScale(), m = _.count;
              if (y.static_background && !y.static_background_cells) return null;
              var p, k = document.createElement("div"), $ = c(f), w = u(f);
              if (p = v && y.smart_rendering && !At(r) ? Ut(_, v.x) : { start: 0, end: m - 1 }, y.show_task_cells) {
                s[g.id] = {}, o[g.id] = {};
                for (var x = p.start; x <= p.end; x++) {
                  var S = h(_, x, g, v, m, $, w, y);
                  S && k.appendChild(S);
                }
              }
              const T = f.$config.rowStore, E = T.getIndexById(g.id) % 2 != 0;
              var C = b.task_row_class(g.start_date, g.end_date, g), D = "gantt_task_row" + (E ? " odd" : "") + (C ? " " + C : "");
              if (T.isSelected(g.id) && (D += " gantt_selected"), k.className = D, y.smart_rendering ? (k.style.position = "absolute", k.style.top = f.getItemTop(g.id) + "px", k.style.width = "100%") : k.style.position = "relative", k.style.height = f.getItemHeight(g.id) + "px", g.id == "timeline_placeholder_task") {
                var A = 0;
                g.lastTaskId && (A = f.getItemTop(g.lastTaskId) + f.getItemHeight(g.lastTaskId));
                var I = (g.row_height || f.$task_data.offsetHeight) - A;
                I < 0 && (I = 0), y.smart_rendering && (k.style.top = A + "px"), k.style.height = I + "px";
              }
              return f.$config.item_attribute && (k.setAttribute(f.$config.item_attribute, g.id), k.setAttribute(f.$config.bind + "_id", g.id)), k;
            }, update: function(g, f, y, v, b) {
              var _ = y.getScale(), m = _.count, p = c(y), k = u(y);
              if (v.show_task_cells) {
                s[g.id] || (s[g.id] = {}), o[g.id] || (o[g.id] = {});
                var $ = Ut(_, b);
                for (var w in o[g.id]) {
                  var x = o[g.id][w];
                  (Number(x) < $.start || Number(x) > $.end) && d(g.id, x);
                }
                o[g.id] = {};
                for (var S = $.start; S <= $.end; S++) {
                  var T = h(_, S, g, b, m, p, k, v);
                  !T && l(g, S) ? d(g.id, S) : T && !T.parentNode && f.appendChild(T);
                }
              }
            }, getRectangle: pn, getVisibleRange: _t, prepareData: Aa };
          }(t);
        }, taskBar: function() {
          return fn2(t);
        }, timedProjectBar: function() {
          return fn2(t);
        }, taskRollupBar: function() {
          return function(r) {
            const s = gn(r), o = {};
            function l(u, h, g, f, y) {
              let v = true;
              return f.smart_rendering && (v = ke(u, h, g)), v;
            }
            function d(u, h, g, f) {
              const y = r.copy(r.getTask(h.id));
              if (y.$rendered_at = u.id, r.callEvent("onBeforeRollupTaskDisplay", [y.id, y, u.id]) === false) return;
              const v = s(y, g);
              if (!v) return;
              const b = g.getBarHeight(u.id, h.type == r.config.types.milestone), _ = Math.floor((g.getItemHeight(u.id) - b) / 2);
              return v.style.top = f.top + _ + "px", v.classList.add("gantt_rollup_child"), v.setAttribute("data-rollup-parent-id", u.id), v;
            }
            function c(u, h) {
              return u + "_" + h;
            }
            return { render: function(u, h, g, f) {
              if (u.rollup !== false && u.$rollup && u.$rollup.length) {
                const y = document.createElement("div"), v = r.getTaskPosition(u);
                return f && (f.y = 0, f.y_end = r.$task_bg.scrollHeight), u.$rollup.forEach(function(b) {
                  if (!r.isTaskExists(b)) return;
                  const _ = r.getTask(b);
                  if (!l(_, f, h, g)) return;
                  const m = d(u, _, h, v);
                  m ? (o[c(_.id, u.id)] = m, y.appendChild(m)) : o[c(_.id, u.id)] = false;
                }), y;
              }
              return false;
            }, update: function(u, h, g, f, y) {
              const v = document.createElement("div"), b = r.getTaskPosition(u);
              y.y = 0, y.y_end = r.$task_bg.scrollHeight, u.$rollup.forEach(function(_) {
                const m = r.getTask(_), p = c(m.id, u.id);
                let k = l(m, y, g, f);
                if (k !== !!o[p]) if (k) {
                  const $ = d(u, m, g, b);
                  o[p] = $ || false;
                } else o[p] = false;
                o[p] && v.appendChild(o[p]), h.innerHTML = "", h.appendChild(v);
              });
            }, isInViewPort: ke, getVisibleRange: _t };
          }(t);
        }, taskSplitBar: function() {
          return Mt();
        }, taskConstraints: function() {
          return Mt();
        }, taskDeadline: function() {
          return Mt();
        }, taskBaselines: function() {
          return Mt();
        }, link: function() {
          return Ia(t);
        }, resourceRow: function() {
          return function(r) {
            var s = Na(r), o = {};
            function l(c, u, h, g, f) {
              var y = h.resource_cell_class(u.start_date, u.end_date, c, u.tasks, u.assignments), v = h.resource_cell_value(u.start_date, u.end_date, c, u.tasks, u.assignments), b = f.getItemHeight(c.id) - 1;
              if (y || v) {
                var _ = f.getItemPosition(c, u.start_date, u.end_date), m = document.createElement("div");
                return m.setAttribute(f.$config.item_attribute, c.id), m.className = ["gantt_resource_marker", y].join(" "), m.style.cssText = ["left:" + _.left + "px", "width:" + _.width + "px", "height:" + b + "px", "line-height:" + b + "px", "top:" + _.top + "px"].join(";"), v && (m.innerHTML = v), m;
              }
              return null;
            }
            function d(c, u) {
              o[c] && o[c][u] && o[c][u].parentNode && o[c][u].parentNode.removeChild(o[c][u]);
            }
            return { render: function(c, u, h, g) {
              var f = u.$getTemplates(), y = u.getScale(), v = s(c, h.resource_property, u.getScale(), u), b = !!g, _ = [];
              o[c.id] = {};
              for (var m = Ut(y, g), p = m.start; p <= m.end; p++) {
                var k = v[p];
                if (k && (!b || ye(p, y, g, r))) {
                  var $ = l(c, k, f, 0, u);
                  $ && (_.push($), o[c.id][p] = $);
                }
              }
              var w = null;
              if (_.length) {
                w = document.createElement("div");
                for (var x = 0; x < _.length; x++) w.appendChild(_[x]);
              }
              return w;
            }, update: function(c, u, h, g, f) {
              var y = h.$getTemplates(), v = h.getScale(), b = s(c, g.resource_property, h.getScale(), h), _ = Ut(v, f), m = {};
              if (o && o[c.id]) for (var p in o[c.id]) m[p] = p;
              for (var k = _.start; k <= _.end; k++) {
                var $ = b[k];
                if (m[k] = false, $) if (ye(k, v, f, r)) if (o[c.id] && o[c.id][k]) o[c.id] && o[c.id][k] && !o[c.id][k].parentNode && u.appendChild(o[c.id][k]);
                else {
                  var w = l(c, $, y, 0, h);
                  w && (u.appendChild(w), o[c.id][k] = w);
                }
                else d(c.id, k);
              }
              for (var p in m) m[p] !== false && d(c.id, p);
            }, getRectangle: pn, getVisibleRange: _t };
          }(t);
        }, resourceHistogram: function() {
          return Mt();
        }, gridTaskRowResizer: function() {
          return /* @__PURE__ */ function(r) {
            return { render: function(s, o, l) {
              var d = o.$getConfig(), c = document.createElement("div");
              return c.className = "gantt_task_grid_row_resize_wrap", c.style.top = o.getItemTop(s.id) + o.getItemHeight(s.id) + "px", c.innerHTML = "<div class='gantt_task_grid_row_resize' role='cell'></div>", c.setAttribute(d.task_grid_row_resizer_attribute, s.id), r._waiAria.rowResizerAttr(c), c;
            }, update: null, getRectangle: Ft, getVisibleRange: _t };
          }(t);
        } }, layersService: { getDataRender: function(r) {
          return i.getDataRender(r, t);
        }, createDataRender: function(r) {
          return i.createDataRender(r, t);
        } } };
      } };
      function $e(t, e) {
        const n = getComputedStyle(e.$root).getPropertyValue("--dhx-gantt-theme");
        let i, a = !!n;
        if (a) i = n;
        else {
          var r = e.skin;
          if (i = r, !r || t) for (var s = document.getElementsByTagName("link"), o = 0; o < s.length; o++) {
            var l = s[o].href.match("dhtmlxgantt_([a-z_]+).css");
            if (l && (e.skins[l[1]] || !r)) {
              i = l[1];
              break;
            }
          }
        }
        e._theme_info = { theme: i, cssVarTheme: a }, e.skin = i || "terrace";
        var d = e.skins[e.skin] || e.skins.terrace;
        (function(h, g, f) {
          for (var y in g) (h[y] === void 0 || f) && (h[y] = g[y]);
        })(e.config, d.config, t), a || (e.config.link_radius = 1);
        var c = e.getGridColumns();
        for (c[1] && !e.defined(c[1].width) && (c[1].width = d._second_column_width), c[2] && !e.defined(c[2].width) && (c[2].width = d._third_column_width), o = 0; o < c.length; o++) {
          var u = c[o];
          u.name == "add" && (u.width || (u.width = 44), e.defined(u.min_width) && e.defined(u.max_width) || (u.min_width = u.min_width || u.width, u.max_width = u.max_width || u.width), u.min_width && (u.min_width = +u.min_width), u.max_width && (u.max_width = +u.max_width), u.width && (u.width = +u.width, u.width = u.min_width && u.min_width > u.width ? u.min_width : u.width, u.width = u.max_width && u.max_width < u.width ? u.max_width : u.width));
        }
        d.config.task_height && (e.config.task_height = d.config.task_height || "full"), d.config.bar_height && (e.config.bar_height = d.config.bar_height || "full"), d._lightbox_template && (e._lightbox_template = d._lightbox_template), d._redefine_lightbox_buttons && (e.config.buttons_right = d._redefine_lightbox_buttons.buttons_right, e.config.buttons_left = d._redefine_lightbox_buttons.buttons_left), e.resetLightbox();
      }
      function Fa(t) {
        var e = 50, n = 30, i = 10, a = 50, r = null, s = false, o = null, l = { started: false }, d = {};
        function c(b) {
          return b && G(b, t.$root) && b.offsetHeight;
        }
        function u() {
          var b = !!document.querySelector(".gantt_drag_marker"), _ = !!document.querySelector(".gantt_drag_marker.gantt_grid_resize_area") || !!document.querySelector(".gantt_drag_marker.gantt_row_grid_resize_area"), m = !!document.querySelector(".gantt_link_direction"), p = t.getState(), k = p.autoscroll;
          return s = b && !_ && !m, !(!p.drag_mode && !b || _) || k;
        }
        function h(b) {
          if (o && (clearTimeout(o), o = null), b) {
            var _ = t.config.autoscroll_speed;
            _ && _ < 10 && (_ = 10), o = setTimeout(function() {
              r = setInterval(y, _ || a);
            }, t.config.autoscroll_delay || i);
          }
        }
        function g(b) {
          b ? (h(true), l.started || (l.x = d.x, l.y = d.y, l.started = true)) : (r && (clearInterval(r), r = null), h(false), l.started = false);
        }
        function f(b) {
          var _ = u();
          if (!r && !o || _ || g(false), !t.config.autoscroll || !_) return false;
          d = { x: b.clientX, y: b.clientY }, b.type == "touchmove" && (d.x = b.targetTouches[0].clientX, d.y = b.targetTouches[0].clientY), !r && _ && g(true);
        }
        function y() {
          if (!u()) return g(false), false;
          var b = c(t.$task) ? t.$task : c(t.$grid) ? t.$grid : t.$root;
          if (b) {
            var _ = false;
            [".gantt_drag_marker.gantt_grid_resize_area", ".gantt_drag_marker .gantt_row.gantt_row_task", ".gantt_drag_marker.gantt_grid_dnd_marker"].forEach(function(M) {
              _ = _ || !!document.querySelector(M);
            }), _ && (b = t.$grid);
            var m = W(b), p = d.x - m.x, k = d.y - m.y + window.scrollY, $ = s ? 0 : v(p, m.width, l.x - m.x), w = v(k, m.height, l.y - m.y + window.scrollY), x = t.getScrollState(), S = x.y, T = x.inner_height, E = x.height, C = x.x, D = x.inner_width, A = x.width;
            (w && !T || w < 0 && !S || w > 0 && S + T >= E + 2) && (w = 0), ($ && !D || $ < 0 && !C || $ > 0 && C + D >= A) && ($ = 0);
            var I = t.config.autoscroll_step;
            I && I < 2 && (I = 2), w *= I || n, (($ *= I || n) || w) && function(M, L) {
              var P = t.getScrollState(), H = null, U = null;
              M && (H = P.x + M, H = Math.min(P.width, H), H = Math.max(0, H)), L && (U = P.y + L, U = Math.min(P.height, U), U = Math.max(0, U)), t.scrollTo(H, U);
            }($, w);
          }
        }
        function v(b, _, m) {
          return b - e < 0 && b < m ? -1 : b > _ - e && b > m ? 1 : 0;
        }
        t.attachEvent("onGanttReady", function() {
          if (!F(t)) {
            var b = vt(t.$root) || document.body;
            t.eventRemove(b, "mousemove", f), t.event(b, "mousemove", f), t.eventRemove(b, "touchmove", f), t.event(b, "touchmove", f), t.eventRemove(b, "pointermove", f), t.event(b, "pointermove", f);
          }
        }), t.attachEvent("onDestroy", function() {
          g(false);
        });
      }
      var we, Se;
      window.jQuery && (we = window.jQuery, Se = [], we.fn.dhx_gantt = function(t) {
        if (typeof (t = t || {}) != "string") {
          var e = [];
          return this.each(function() {
            if (this && this.getAttribute) if (this.gantt || window.gantt.$root == this) e.push(typeof this.gantt == "object" ? this.gantt : window.gantt);
            else {
              var n = window.gantt.$container && window.Gantt ? window.Gantt.getGanttInstance() : window.gantt;
              for (var i in t) i != "data" && (n.config[i] = t[i]);
              n.init(this), t.data && n.parse(t.data), e.push(n);
            }
          }), e.length === 1 ? e[0] : e;
        }
        if (Se[t]) return Se[t].apply(this, []);
        we.error("Method " + t + " does not exist on jQuery.dhx_gantt");
      });
      const Va = null;
      window.dhtmlx && (window.dhtmlx.attaches || (window.dhtmlx.attaches = {}), window.dhtmlx.attaches.attachGantt = function(t, e, n) {
        var i = document.createElement("DIV");
        n = n || window.gantt, i.id = "gantt_" + n.uid(), i.style.width = "100%", i.style.height = "100%", i.cmp = "grid", document.body.appendChild(i), this.attachObject(i.id), this.dataType = "gantt", this.dataObj = n;
        var a = this.vs[this.av];
        return a.grid = n, n.init(i.id, t, e), i.firstChild.style.border = "none", a.gridId = i.id, a.gridObj = i, this.vs[this._viewRestore()].grid;
      }), window.dhtmlXCellObject !== void 0 && (window.dhtmlXCellObject.prototype.attachGantt = function(t, e, n) {
        n = n || window.gantt;
        var i = document.createElement("DIV");
        return i.id = "gantt_" + n.uid(), i.style.width = "100%", i.style.height = "100%", i.cmp = "grid", document.body.appendChild(i), this.attachObject(i.id), this.dataType = "gantt", this.dataObj = n, n.init(i.id, t, e), i.firstChild.style.border = "none", i = null, this.callEvent("_onContentAttach", []), this.dataObj;
      });
      const Ua = null, qa = ["ctrlKey", "altKey", "shiftKey", "metaKey"], Ga = [[{ unit: "month", date: "%M", step: 1 }, { unit: "day", date: "%d", step: 1 }], [{ unit: "day", date: "%d %M", step: 1 }], [{ unit: "day", date: "%d %M", step: 1 }, { unit: "hour", date: "%H:00", step: 8 }], [{ unit: "day", date: "%d %M", step: 1 }, { unit: "hour", date: "%H:00", step: 1 }]];
      class Ya {
        constructor(e) {
          this.zoomIn = () => {
            const n = this.getCurrentLevel() - 1;
            n < 0 || this.setLevel(n);
          }, this.zoomOut = () => {
            const n = this.getCurrentLevel() + 1;
            n > this._levels.length - 1 || this.setLevel(n);
          }, this.getCurrentLevel = () => this._activeLevelIndex, this.getLevels = () => this._levels, this.setLevel = (n) => {
            const i = this._getZoomIndexByName(n);
            i === -1 && this.$gantt.assert(i !== -1, "Invalid zoom level for gantt.ext.zoom.setLevel. " + n + " is not an expected value."), this._setLevel(i, 0);
          }, this._getZoomIndexByName = (n) => {
            let i = -1;
            if (typeof n == "string") {
              if (!isNaN(Number(n)) && this._levels[Number(n)]) i = Number(n);
              else for (let a = 0; a < this._levels.length; a++) if (this._levels[a].name === n) {
                i = a;
                break;
              }
            } else i = n;
            return i;
          }, this._getVisibleDate = () => {
            if (!this.$gantt.$task) return null;
            const n = this.$gantt.getScrollState().x, i = this.$gantt.$task.offsetWidth;
            this._visibleDate = this.$gantt.dateFromPos(n + i / 2);
          }, this._setLevel = (n, i) => {
            this._activeLevelIndex = n;
            const a = this.$gantt, r = a.copy(this._levels[this._activeLevelIndex]), s = a.copy(r);
            if (delete s.name, a.mixin(a.config, s, true), ["resourceTimeline", "resourceHistogram"].forEach(function(o) {
              const l = a.$ui.getView(o);
              if (l) {
                const d = l.$getConfig();
                d.fixed_scales || a.mixin(d, s, true);
              }
            }), a.$root && a.$task) {
              if (i) {
                const o = this.$gantt.dateFromPos(i + this.$gantt.getScrollState().x);
                this.$gantt.render();
                const l = this.$gantt.posFromDate(o);
                this.$gantt.scrollTo(l - i);
              } else {
                const o = this.$gantt.$task.offsetWidth;
                this._visibleDate || this._getVisibleDate();
                const l = this._visibleDate;
                this.$gantt.render();
                const d = this.$gantt.posFromDate(l);
                this.$gantt.scrollTo(d - o / 2);
              }
              this.callEvent("onAfterZoom", [this._activeLevelIndex, r]);
            }
          }, this._attachWheelEvent = (n) => {
            const i = ht.isFF ? "wheel" : "mousewheel";
            let a;
            a = typeof n.element == "function" ? n.element() : n.element, a && this._domEvents.attach(a, i, this.$gantt.bind(function(r) {
              if (this._useKey && (qa.indexOf(this._useKey) < 0 || !r[this._useKey])) return false;
              if (typeof this._handler == "function") return this._handler.apply(this, [r]), true;
            }, this), { passive: false });
          }, this._defaultHandler = (n) => {
            const i = this.$gantt.$task.getBoundingClientRect().x, a = n.clientX - i;
            let r = false;
            (this.$gantt.env.isFF ? -40 * n.deltaY : n.wheelDelta) > 0 && (r = true), n.preventDefault(), n.stopPropagation(), this._setScaleSettings(r, a);
          }, this._setScaleDates = () => {
            this._initialStartDate && this._initialEndDate && (this.$gantt.config.start_date = this._initialStartDate, this.$gantt.config.end_date = this._initialEndDate);
          }, this.$gantt = e, this._domEvents = this.$gantt._createDomEventScope();
        }
        init(e) {
          this.$gantt.env.isNode || (this._initialStartDate = e.startDate, this._initialEndDate = e.endDate, this._activeLevelIndex = e.activeLevelIndex ? e.activeLevelIndex : 0, this._levels = this._mapScales(e.levels || Ga), this._handler = e.handler || this._defaultHandler, this._minColumnWidth = e.minColumnWidth || 60, this._maxColumnWidth = e.maxColumnWidth || 240, this._widthStep = e.widthStep || 3 / 8 * e.minColumnWidth, this._useKey = e.useKey, this._initialized || (nt(this), this.$gantt.attachEvent("onGanttScroll", () => {
            this._getVisibleDate();
          })), this._domEvents.detachAll(), e.trigger === "wheel" && (this.$gantt.$root ? this._attachWheelEvent(e) : this.$gantt.attachEvent("onGanttReady", () => {
            this._attachWheelEvent(e);
          })), this._initialized = true, this.setLevel(this._activeLevelIndex));
        }
        _mapScales(e) {
          return e.map((n) => Array.isArray(n) ? { scales: n } : n);
        }
        _setScaleSettings(e, n) {
          e ? this._stepUp(n) : this._stepDown(n);
        }
        _stepUp(e) {
          if (this._activeLevelIndex >= this._levels.length - 1) return;
          let n = this._activeLevelIndex;
          if (this._setScaleDates(), this._widthStep) {
            let i = this.$gantt.config.min_column_width + this._widthStep;
            i > this._maxColumnWidth && (i = this._minColumnWidth, n++), this.$gantt.config.min_column_width = i;
          } else n++;
          this._setLevel(n, e);
        }
        _stepDown(e) {
          if (this._activeLevelIndex < 1) return;
          let n = this._activeLevelIndex;
          if (this._setScaleDates(), this._widthStep) {
            let i = this.$gantt.config.min_column_width - this._widthStep;
            i < this._minColumnWidth && (i = this._maxColumnWidth, n--), this.$gantt.config.min_column_width = i;
          } else n--;
          this._setLevel(n, e);
        }
      }
      function Ja(t) {
        function e() {
          if (t.config.touch != "force" && (t.config.touch = t.config.touch && (navigator.userAgent.indexOf("Mobile") != -1 || navigator.userAgent.indexOf("iPad") != -1 || navigator.userAgent.indexOf("Android") != -1 || navigator.userAgent.indexOf("Touch") != -1) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), t.config.touch) {
            var r = true;
            try {
              document.createEvent("TouchEvent");
            } catch {
              r = false;
            }
            r ? t._touch_events(["touchmove", "touchstart", "touchend"], function(s) {
              return s.touches && s.touches.length > 1 ? null : s.touches[0] ? { target: s.target, pageX: s.touches[0].pageX, pageY: s.touches[0].pageY, clientX: s.touches[0].clientX, clientY: s.touches[0].clientY } : s;
            }, function() {
              return false;
            }) : window.navigator.pointerEnabled ? t._touch_events(["pointermove", "pointerdown", "pointerup"], function(s) {
              return s.pointerType == "mouse" ? null : s;
            }, function(s) {
              return !s || s.pointerType == "mouse";
            }) : window.navigator.msPointerEnabled && t._touch_events(["MSPointerMove", "MSPointerDown", "MSPointerUp"], function(s) {
              return s.pointerType == s.MSPOINTER_TYPE_MOUSE ? null : s;
            }, function(s) {
              return !s || s.pointerType == s.MSPOINTER_TYPE_MOUSE;
            });
          }
        }
        function n(r) {
          var s = r.$config.scrollX ? t.$ui.getView(r.$config.scrollX) : null, o = r.$config.scrollY ? t.$ui.getView(r.$config.scrollY) : null, l = { x: null, y: null };
          return s && s.getScrollState().visible && (l.x = s.$view.scrollLeft), o && o.getScrollState().visible && (l.y = o.$view.scrollTop), l;
        }
        function i() {
          var r;
          return t.$ui.getView("timeline") && (r = t.$ui.getView("timeline")._tasks_dnd), r;
        }
        t.config.touch_drag = 75, t.config.touch = true, t.config.touch_feedback = true, t.config.touch_feedback_duration = 1, t._prevent_touch_scroll = false, t._touch_feedback = function() {
          t.config.touch_feedback && navigator.vibrate && navigator.vibrate(t.config.touch_feedback_duration);
        }, t.attachEvent("onGanttReady", function() {
          t.$container && e();
        }), t.attachEvent("onGanttLayoutReady", function() {
          t.$container && t.attachEvent("onGanttRender", e, { once: true });
        });
        var a = [];
        t._touch_events = function(r, s, o) {
          var l, d = 0, c = false, u = false, h = null, g = null, f = null, y = [], v = null;
          let b = {};
          for (var _ = 0; _ < a.length; _++) t.eventRemove(a[_][0], a[_][1], a[_][2]);
          (a = []).push([t.$container, r[0], function(p) {
            var k = i();
            if (!o(p) && c) {
              g && clearTimeout(g);
              var $ = s(p);
              if (k && (k.drag.id || k.drag.start_drag)) return k.on_mouse_move($), p.preventDefault && p.preventDefault(), p.cancelBubble = true, false;
              if (!t._prevent_touch_scroll) {
                if ($ && h) {
                  var w = h.pageX - $.pageX, x = h.pageY - $.pageY;
                  if (!u && (Math.abs(w) > 5 || Math.abs(x) > 5) && (u = true, d = 0, l = v ? n(v) : t.getScrollState()), u) {
                    var S, T = l.x + w, E = l.y + x;
                    if (v ? (function(C, D, A) {
                      var I = C.$config.scrollX ? t.$ui.getView(C.$config.scrollX) : null, M = C.$config.scrollY ? t.$ui.getView(C.$config.scrollY) : null;
                      I && I.scrollTo(D, null), M && M.scrollTo(null, A);
                    }(v, T, E), S = n(v)) : (t.scrollTo(T, E), S = t.getScrollState()), l.x != S.x && x > 2 * w || l.y != S.y && w > 2 * x) return m(p);
                  }
                }
                return m(p);
              }
              return true;
            }
          }]);
          try {
            document.addEventListener("touchmove", function(p) {
              t._touch_drag && m(p);
            }, { passive: false });
          } catch {
            console.warn("Cannot prevent touch event for the page drag");
          }
          for (a.push([this.$container, "contextmenu", function(p) {
            if (c) return m(p);
          }]), a.push([this.$container, r[1], function(p) {
            if (b = p.touches.length, document && document.body && document.body.classList.add("gantt_touch_active"), !o(p)) if (p.touches && p.touches.length > 1) c = false;
            else {
              h = s(p), v = function($) {
                for (var w = t.$layout.getCellsByType("viewCell"), x = 0; x < w.length; x++) {
                  var S = w[x].$view.getBoundingClientRect();
                  if ($.clientX >= S.left && $.clientX <= S.right && $.clientY <= S.bottom && $.clientY >= S.top) return w[x];
                }
              }(h), t._locate_css(h, "gantt_hor_scroll") || t._locate_css(h, "gantt_ver_scroll") || (c = true);
              var k = i();
              g = setTimeout(function() {
                var $ = t.locate(h);
                k && $ && !t._locate_css(h, "gantt_link_control") && !t._locate_css(h, "gantt_grid_data") && (k.on_mouse_down(h), k.drag && k.drag.start_drag && (function(w) {
                  const x = t._getTaskLayers();
                  let S = t.getTask(w);
                  if (S) {
                    let T = t.isTaskVisible(w);
                    if (T) {
                      f = w;
                      for (let E = 0; E < x.length; E++) if (S = x[E].rendered[w], S && S.getAttribute(t.config.task_attribute) && S.getAttribute(t.config.task_attribute) == w) {
                        const C = S.cloneNode(true);
                        y.push(S), x[E].rendered[w] = C, S.style.display = "none", C.className += " gantt_drag_move ", S.parentNode.appendChild(C);
                      }
                    } else if (S.$split_subtask) {
                      let E = S.$rendered_parent;
                      if (T = t.isTaskVisible(E), !T) return;
                      f = w;
                      for (let C = 0; C < x.length; C++) {
                        const D = x[C].rendered[E];
                        let A;
                        if (D && D.childNodes && (A = D.querySelector(`[${t.config.task_attribute}="${S.id}"]`)), A) {
                          const I = A.cloneNode(true);
                          A.parentNode.appendChild(I), t.$task_bars.appendChild(A), A.style.display = "none", y.push(A), A = null;
                        }
                      }
                    }
                  }
                }($), k._start_dnd(h), t._touch_drag = true, t.refreshTask($), t._touch_feedback())), g = null;
              }, t.config.touch_drag);
            }
          }]), a.push([this.$container, r[2], function(p) {
            if (document && document.body && document.body.classList.remove("gantt_touch_active"), !o(p)) {
              g && clearTimeout(g), t._touch_drag = false, c = false;
              var k = s(p), $ = i();
              if ($ && $.on_mouse_up(k), f && t.isTaskExists(f) && (t.refreshTask(f), y.length && (y.forEach(function(x) {
                x.parentNode && x.parentNode.removeChild(x);
              }), t._touch_feedback())), c = u = false, y = [], f = null, h && d) {
                var w = /* @__PURE__ */ new Date();
                w - d < 500 && b <= 1 ? (t.$services.getService("mouseEvents").onDoubleClick(h), m(p)) : d = w;
              } else d = /* @__PURE__ */ new Date();
            }
          }]), _ = 0; _ < a.length; _++) t.event(a[_][0], a[_][1], a[_][2]);
          function m(p) {
            return p && p.preventDefault && p.cancelable && p.preventDefault(), p.cancelBubble = true, false;
          }
        };
      }
      function qt() {
        console.log("Method is not implemented.");
      }
      function Nt() {
      }
      function dt(t) {
        return Nt;
      }
      Nt.prototype.render = qt, Nt.prototype.set_value = qt, Nt.prototype.get_value = qt, Nt.prototype.focus = qt;
      var xn = { getHtmlSelect: function(t, e, n) {
        var i = "", a = this;
        return kt(t = t || [], function(r) {
          var s = [{ key: "value", value: r.key }];
          n == r.key && (s[s.length] = { key: "selected", value: "selected" }), r.attributes && (s = s.concat(r.attributes)), i += a.getHtmlOption({ innerHTML: r.label }, s);
        }), Lt("select", { innerHTML: i }, e);
      }, getHtmlOption: function(t, e) {
        return Lt("option", t, e);
      }, getHtmlButton: function(t, e) {
        return Lt("button", t, e);
      }, getHtmlDiv: function(t, e) {
        return Lt("div", t, e);
      }, getHtmlLabel: function(t, e) {
        return Lt("label", t, e);
      }, getHtmlInput: function(t) {
        return "<input" + $n(t || []) + ">";
      } };
      function Lt(t, e, n) {
        return e = e || [], "<" + t + $n(n || []) + ">" + (e.innerHTML || "") + "</" + t + ">";
      }
      function $n(t) {
        var e = "";
        return kt(t, function(n) {
          e += " " + n.key + "='" + n.value + "'";
        }), e;
      }
      function Gt(t) {
        const e = dt();
        function n() {
          return e.apply(this, arguments) || this;
        }
        return z(n, e), n.prototype.render = function(i) {
          const a = i.height ? `height:${i.height}px;` : "";
          let r = `<div class='gantt_cal_ltext gantt_section_${i.name}' ${a ? `style='${a}'` : ""}>`;
          return r += xn.getHtmlSelect(i.options, [{ key: "style", value: "width:100%;" }, { key: "title", value: i.name }]), r += "</div>", r;
        }, n.prototype.set_value = function(i, a, r, s) {
          var o = i.firstChild;
          !o._dhx_onchange && s.onchange && (o.onchange = s.onchange, o._dhx_onchange = true), a === void 0 && (a = (o.options[0] || {}).value), o.value = a || "";
        }, n.prototype.get_value = function(i) {
          return i.firstChild.value;
        }, n.prototype.focus = function(i) {
          var a = i.firstChild;
          t._focus(a, true);
        }, n;
      }
      function Ka(t) {
        var e = Gt(t);
        function n() {
          return e.apply(this, arguments) || this;
        }
        function i(a, r) {
          var s = [], o = [];
          r && (s = t.getTaskByTime(), a.allow_root && s.unshift({ id: t.config.root_id, text: a.root_label || "" }), s = function(u, h, g) {
            var f = h.filter || function() {
              return true;
            };
            u = u.slice(0);
            for (var y = 0; y < u.length; y++) {
              var v = u[y];
              (v.id == g || t.isChildOf(v.id, g) || f(v.id, v) === false) && (u.splice(y, 1), y--);
            }
            return u;
          }(s, a, r), a.sort && s.sort(a.sort));
          for (var l = a.template || t.templates.task_text, d = 0; d < s.length; d++) {
            var c = l.apply(t, [s[d].start_date, s[d].end_date, s[d]]);
            c === void 0 && (c = ""), o.push({ key: s[d].id, label: c });
          }
          return a.options = o, a.map_to = a.map_to || "parent", t.form_blocks.select.render.apply(this, arguments);
        }
        return z(n, e), n.prototype.render = function(a) {
          return i(a, false);
        }, n.prototype.set_value = function(a, r, s, o) {
          r === 0 && (r = "0");
          var l = document.createElement("div");
          l.innerHTML = i(o, s.id);
          var d = l.removeChild(l.firstChild);
          return a.onselect = null, a.parentNode.replaceChild(d, a), t.form_blocks.select.set_value.apply(t, [d, r, s, o]);
        }, n;
      }
      function Xa(t) {
        var e = function() {
          const _ = dt();
          function m() {
            return _.apply(this, arguments) || this;
          }
          return z(m, _), m.prototype.render = function(p) {
            let k = p.height ? `${p.height}px` : "";
            return `<div class='gantt_cal_ltext gantt_cal_template gantt_section_${p.name}' ${k ? `style='height:${k};'` : ""}></div>`;
          }, m.prototype.set_value = function(p, k) {
            p.innerHTML = k || "";
          }, m.prototype.get_value = function(p) {
            return p.innerHTML || "";
          }, m.prototype.focus = function() {
          }, m;
        }(), n = function(_) {
          const m = dt();
          function p() {
            return m.apply(this, arguments) || this;
          }
          return z(p, m), p.prototype.render = function(k) {
            const $ = (k.height || "130") + "px", w = k.placeholder ? `placeholder='${k.placeholder}'` : "";
            return `<div class='gantt_cal_ltext gantt_section_${k.name}' style='height:${$};' ${w}><textarea></textarea></div>`;
          }, p.prototype.set_value = function(k, $) {
            _.form_blocks.textarea._get_input(k).value = $ || "";
          }, p.prototype.get_value = function(k) {
            return _.form_blocks.textarea._get_input(k).value;
          }, p.prototype.focus = function(k) {
            var $ = _.form_blocks.textarea._get_input(k);
            _._focus($, true);
          }, p.prototype._get_input = function(k) {
            return k.querySelector("textarea");
          }, p;
        }(t), i = function(_) {
          const m = dt();
          function p() {
            return m.apply(this, arguments) || this;
          }
          return z(p, m), p.prototype.render = function(k) {
            var $ = _.form_blocks.getTimePicker.call(this, k);
            let w = "gantt_section_time";
            k.name !== "time" && (w += " gantt_section_" + k.name);
            var x = "<div style='padding-top:0px;font-size:inherit;text-align:center;' class='" + w + "'>";
            return x += $, k.single_date ? ($ = _.form_blocks.getTimePicker.call(this, k, true), x += "<span></span>") : x += "<span class='gantt_section_time_spacer'> &nbsp;&ndash;&nbsp; </span>", (x += $) + "</div>";
          }, p.prototype.set_value = function(k, $, w, x) {
            var S = x, T = k.getElementsByTagName("select"), E = x._time_format_order;
            if (S.auto_end_date) for (var C = function() {
              I = new Date(T[E[2]].value, T[E[1]].value, T[E[0]].value, 0, 0), M = _.calculateEndDate({ start_date: I, duration: 1, task: w }), _.form_blocks._fill_lightbox_select(T, E.size, M, E, S);
            }, D = 0; D < 4; D++) T[D].onchange = C;
            var A = _._resolve_default_mapping(x);
            typeof A == "string" && (A = { start_date: A });
            var I = w[A.start_date] || /* @__PURE__ */ new Date(), M = w[A.end_date] || _.calculateEndDate({ start_date: I, duration: 1, task: w });
            _.form_blocks._fill_lightbox_select(T, 0, I, E, S), _.form_blocks._fill_lightbox_select(T, E.size, M, E, S);
          }, p.prototype.get_value = function(k, $, w) {
            var x, S = k.getElementsByTagName("select"), T = w._time_format_order;
            return x = _.form_blocks.getTimePickerValue(S, w), typeof _._resolve_default_mapping(w) == "string" ? x : { start_date: x, end_date: function(E, C, D) {
              var A = _.form_blocks.getTimePickerValue(E, w, C.size);
              return A <= D && (w.autofix_end !== false || w.single_date) ? _.date.add(D, _._get_timepicker_step(), "minute") : A;
            }(S, T, x) };
          }, p.prototype.focus = function(k) {
            _._focus(k.getElementsByTagName("select")[0]);
          }, p;
        }(t), a = Gt(t), r = function(_) {
          var m = dt();
          function p() {
            return m.apply(this, arguments) || this;
          }
          return z(p, m), p.prototype.render = function(k) {
            const $ = k.height ? `height:${k.height}px;` : "";
            let w = `<div class='gantt_cal_ltext gantt_cal_lcheckbox gantt_section_${k.name}' ${$ ? `style='${$}'` : ""}>`;
            if (k.options && k.options.length) for (var x = 0; x < k.options.length; x++) w += "<label><input type='checkbox' value='" + k.options[x].key + "' name='" + k.name + "'>" + k.options[x].label + "</label>";
            else k.single_value = true, w += "<label><input type='checkbox' name='" + k.name + "'></label>";
            return w += "</div>", w;
          }, p.prototype.set_value = function(k, $, w, x) {
            var S = Array.prototype.slice.call(k.querySelectorAll("input[type=checkbox]"));
            !k._dhx_onchange && x.onchange && (k.onchange = x.onchange, k._dhx_onchange = true), x.single_value ? S[0].checked = !!$ : kt(S, function(T) {
              T.checked = !!$ && $.indexOf(T.value) >= 0;
            });
          }, p.prototype.get_value = function(k, $, w) {
            return w.single_value ? k.querySelector("input[type=checkbox]").checked : function(x, S) {
              if (x.map) return x.map(S);
              for (var T = x.slice(), E = [], C = 0; C < T.length; C++) E.push(S(T[C], C));
              return E;
            }(Array.prototype.slice.call(k.querySelectorAll("input[type=checkbox]:checked")), function(x) {
              return x.value;
            });
          }, p.prototype.focus = function(k) {
            _._focus(k.querySelector("input[type=checkbox]"));
          }, p;
        }(t), s = function(_) {
          const m = dt();
          function p() {
            return m.apply(this, arguments) || this;
          }
          return z(p, m), p.prototype.render = function(k) {
            const $ = k.height ? `${k.height}px` : "";
            let w = `<div class='gantt_cal_ltext gantt_cal_lradio gantt_section_${k.name}' ${$ ? `style='height:${$};'` : ""}>`;
            if (k.options && k.options.length) for (var x = 0; x < k.options.length; x++) w += "<label><input type='radio' value='" + k.options[x].key + "' name='" + k.name + "'>" + k.options[x].label + "</label>";
            return w += "</div>", w;
          }, p.prototype.set_value = function(k, $, w, x) {
            var S;
            x.options && x.options.length && (S = k.querySelector("input[type=radio][value='" + $ + "']") || k.querySelector("input[type=radio][value='" + x.default_value + "']")) && (!k._dhx_onchange && x.onchange && (k.onchange = x.onchange, k._dhx_onchange = true), S.checked = true);
          }, p.prototype.get_value = function(k, $) {
            var w = k.querySelector("input[type=radio]:checked");
            return w ? w.value : "";
          }, p.prototype.focus = function(k) {
            _._focus(k.querySelector("input[type=radio]"));
          }, p;
        }(t), o = function(_) {
          var m = dt();
          function p() {
            return m.apply(this, arguments) || this;
          }
          function k(x) {
            return x.formatter || new Ct();
          }
          function $(x, S) {
            var T = x.getElementsByTagName("select"), E = S._time_format_order, C = 0, D = 0;
            if (_.defined(E[3])) {
              var A = T[E[3]], I = parseInt(A.value, 10);
              isNaN(I) && A.hasAttribute("data-value") && (I = parseInt(A.getAttribute("data-value"), 10)), C = Math.floor(I / 60), D = I % 60;
            }
            return new Date(T[E[2]].value, T[E[1]].value, T[E[0]].value, C, D);
          }
          function w(x, S) {
            var T = x.getElementsByTagName("input")[1];
            return (T = k(S).parse(T.value)) && !window.isNaN(T) || (T = 1), T < 0 && (T *= -1), T;
          }
          return z(p, m), p.prototype.render = function(x) {
            var S = "<div class='gantt_time_selects'>" + _.form_blocks.getTimePicker.call(this, x) + "</div>", T = " " + _.locale.labels[_.config.duration_unit + "s"] + " ", E = x.single_date ? " style='display:none'" : "", C = x.readonly ? " disabled='disabled'" : "", D = _._waiAria.lightboxDurationInputAttrString(x), A = "gantt_duration_value";
            x.formatter && (T = "", A += " gantt_duration_value_formatted");
            var I = "<div class='gantt_duration' " + E + "><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value='\u2212'" + C + "><input type='text' value='5days' class='" + A + "'" + C + " " + D + "><input type='button' class='gantt_duration_inc' value='+'" + C + "></div><div class='gantt_duration_end_date'>" + T + "<span></span></div></div></div>";
            let M = "gantt_section_time gantt_section_duration";
            return x.name !== "time" && (M += " gantt_section_" + x.name), "<div style='padding-top:0px;font-size:inherit;' class='" + M + "'>" + S + " " + I + "</div>";
          }, p.prototype.set_value = function(x, S, T, E) {
            var C, D, A, I, M = x.getElementsByTagName("select"), L = x.getElementsByTagName("input"), P = L[1], H = [L[0], L[2]], U = x.getElementsByTagName("span")[0], gt = E._time_format_order;
            function O() {
              var X = $.call(_, x, E), B = w.call(_, x, E), ft = _.calculateEndDate({ start_date: X, duration: B, task: T }), Pt = _.templates.task_end_date || _.templates.task_date;
              U.innerHTML = Pt(ft);
            }
            function tt(X) {
              var B = P.value;
              B = k(E).parse(B), window.isNaN(B) && (B = 0), (B += X) < 1 && (B = 1), P.value = k(E).format(B), O();
            }
            H[0].onclick = _.bind(function() {
              tt(-1 * _.config.duration_step);
            }, this), H[1].onclick = _.bind(function() {
              tt(1 * _.config.duration_step);
            }, this), M[0].onchange = O, M[1].onchange = O, M[2].onchange = O, M[3] && (M[3].onchange = O), P.onkeydown = _.bind(function(X) {
              var B;
              return (B = (X = X || window.event).charCode || X.keyCode || X.which) == _.constants.KEY_CODES.DOWN ? (tt(-1 * _.config.duration_step), false) : B == _.constants.KEY_CODES.UP ? (tt(1 * _.config.duration_step), false) : void window.setTimeout(O, 1);
            }, this), P.onchange = _.bind(O, this), typeof (C = _._resolve_default_mapping(E)) == "string" && (C = { start_date: C }), D = T[C.start_date] || /* @__PURE__ */ new Date(), A = T[C.end_date] || _.calculateEndDate({ start_date: D, duration: 1, task: T }), I = Math.round(T[C.duration]) || _.calculateDuration({ start_date: D, end_date: A, task: T }), I = k(E).format(I), _.form_blocks._fill_lightbox_select(M, 0, D, gt, E), P.value = I, O();
          }, p.prototype.get_value = function(x, S, T) {
            var E = $(x, T), C = w(x, T), D = _.calculateEndDate({ start_date: E, duration: C, task: S });
            return typeof _._resolve_default_mapping(T) == "string" ? E : { start_date: E, end_date: D, duration: C };
          }, p.prototype.focus = function(x) {
            _._focus(x.getElementsByTagName("select")[0]);
          }, p;
        }(t), l = Ka(t), d = Gt(t), c = function(_) {
          var m = dt();
          function p() {
            return m.apply(this, arguments) || this;
          }
          function k(w) {
            return !w || w === _.config.constraint_types.ASAP || w === _.config.constraint_types.ALAP;
          }
          function $(w, x) {
            for (var S = k(x), T = 0; T < w.length; T++) w[T].disabled = S;
          }
          return z(p, m), p.prototype.render = function(w) {
            const x = w.height ? `height:${w.height}px;` : "";
            let S = `<div class='gantt_cal_ltext gantt_section_${w.name}' ${x ? `style='${x}'` : ""}>`;
            var T = [];
            for (var E in _.config.constraint_types) T.push({ key: _.config.constraint_types[E], label: _.locale.labels[_.config.constraint_types[E]] });
            return w.options = w.options || T, S += "<span data-constraint-type-select>" + xn.getHtmlSelect(w.options, [{ key: "data-type", value: "constraint-type" }]) + "</span>", S += "<label data-constraint-time-select>" + (_.locale.labels.constraint_date || "Constraint date") + ": " + _.form_blocks.getTimePicker.call(this, w) + "</label>", S += "</div>", S;
          }, p.prototype.set_value = function(w, x, S, T) {
            var E = w.querySelector("[data-constraint-type-select] select"), C = w.querySelectorAll("[data-constraint-time-select] select"), D = T._time_format_order, A = _._resolve_default_mapping(T);
            E._eventsInitialized || (E.addEventListener("change", function(L) {
              $(C, L.target.value);
            }), E._eventsInitialized = true);
            var I = S[A.constraint_date] || /* @__PURE__ */ new Date();
            _.form_blocks._fill_lightbox_select(C, 0, I, D, T);
            var M = S[A.constraint_type] || _.getConstraintType(S);
            E.value = M, $(C, M);
          }, p.prototype.get_value = function(w, x, S) {
            var T = w.querySelector("[data-constraint-type-select] select"), E = w.querySelectorAll("[data-constraint-time-select] select"), C = T.value, D = null;
            return k(C) || (D = _.form_blocks.getTimePickerValue(E, S)), { constraint_type: C, constraint_date: D };
          }, p.prototype.focus = function(w) {
            _._focus(w.querySelector("select"));
          }, p;
        }(t), u = function(_) {
          const m = Gt(_);
          function p() {
            return m.apply(this, arguments) || this;
          }
          return z(p, m), p.prototype.render = function(k) {
            var $ = _.config.types, w = _.locale.labels, x = [], S = k.filter || function(C, D) {
              return !$.placeholder || D !== $.placeholder;
            };
            for (var T in $) !S(T, $[T]) == 0 && x.push({ key: $[T], label: w["type_" + T] });
            k.options = x;
            var E = k.onchange;
            return k.onchange = function() {
              _._lightbox_current_type = this.value, _.changeLightboxType(this.value), typeof E == "function" && E.apply(this, arguments);
            }, m.prototype.render.apply(this, arguments);
          }, p;
        }(t), h = function(_) {
          var m = dt();
          function p() {
            return m.apply(this, arguments) || this;
          }
          function k(S) {
            return S.formatter || new Ct();
          }
          function $(S, T, E, C) {
            const D = "<div class='gantt_time_selects'>" + _.form_blocks.getTimePicker.call(_, C) + "</div>";
            let A = " " + _.locale.labels[_.config.duration_unit + "s"] + " ";
            const I = C.single_date ? " style='display:none'" : "", M = C.readonly ? " disabled='disabled'" : "", L = _._waiAria.lightboxDurationInputAttrString(C), P = _.locale.labels.baselines_remove_button;
            let H = "gantt_duration_value";
            C.formatter && (A = "", H += " gantt_duration_value_formatted");
            const U = "<div class='gantt_duration' " + I + "><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value='\u2212'" + M + "><input type='text' value='5days' class='" + H + "'" + M + " " + L + "><input type='button' class='gantt_duration_inc' value='+'" + M + "></div><div class='gantt_duration_end_date'>" + A + "<span></span></div></div></div>", gt = `<div><div class='baseline_delete_button gantt_custom_button'>${P}</div></div>`, O = document.createElement("div");
            O.className = "gantt_section_time gantt_section_duration", O.setAttribute("data-baseline-id", T.id), O.innerHTML = D + U + gt + "<br>", S.appendChild(O);
            var tt, X, B, ft = O.getElementsByTagName("select"), Pt = O.getElementsByTagName("input"), Rt = Pt[1], Sn = [Pt[0], Pt[2]], Qa = O.getElementsByTagName("span")[0], tr = C._time_format_order;
            function pt() {
              var ct = w.call(_, O, C), q = x.call(_, O, C), er = _.calculateEndDate({ start_date: ct, duration: q, task: E }), nr = _.templates.task_end_date || _.templates.task_date;
              Qa.innerHTML = nr(er);
            }
            function Xt(ct) {
              var q = Rt.value;
              q = k(C).parse(q), window.isNaN(q) && (q = 0), (q += ct) < 1 && (q = 1), Rt.value = k(C).format(q), pt();
            }
            O.querySelector(".baseline_delete_button").onclick = function(ct) {
              const q = O.parentNode;
              O.innerHTML = "", O.remove(), q.innerHTML === "" && (q.innerHTML = _.locale.labels.baselines_section_placeholder);
            }, Sn[0].onclick = _.bind(function() {
              Xt(-1 * _.config.duration_step);
            }, _), Sn[1].onclick = _.bind(function() {
              Xt(1 * _.config.duration_step);
            }, _), ft[0].onchange = pt, ft[1].onchange = pt, ft[2].onchange = pt, ft[3] && (ft[3].onchange = pt), Rt.onkeydown = _.bind(function(ct) {
              var q;
              return (q = (ct = ct || window.event).charCode || ct.keyCode || ct.which) == _.constants.KEY_CODES.DOWN ? (Xt(-1 * _.config.duration_step), false) : q == _.constants.KEY_CODES.UP ? (Xt(1 * _.config.duration_step), false) : void window.setTimeout(pt, 1);
            }, _), Rt.onchange = _.bind(pt, _), _._resolve_default_mapping(C), tt = T.start_date || /* @__PURE__ */ new Date(), X = T.end_date || _.calculateEndDate({ start_date: tt, duration: 1, task: E }), B = _.calculateDuration({ start_date: tt, end_date: X, task: E }), B = k(C).format(B), _.form_blocks._fill_lightbox_select(ft, 0, tt, tr, C), Rt.value = B, pt();
          }
          function w(S, T) {
            var E = S.getElementsByTagName("select"), C = T._time_format_order, D = 0, A = 0;
            if (_.defined(C[3])) {
              var I = E[C[3]], M = parseInt(I.value, 10);
              isNaN(M) && I.hasAttribute("data-value") && (M = parseInt(I.getAttribute("data-value"), 10)), D = Math.floor(M / 60), A = M % 60;
            }
            return new Date(E[C[2]].value, E[C[1]].value, E[C[0]].value, D, A);
          }
          function x(S, T) {
            var E = S.getElementsByTagName("input")[1];
            return (E = k(T).parse(E.value)) && !window.isNaN(E) || (E = 1), E < 0 && (E *= -1), E;
          }
          return z(p, m), p.prototype.render = function(S) {
            return `<div style='height: ${S.height || 100}px; padding-top:0px; font-size:inherit;' class='gantt_section_baselines'></div>`;
          }, p.prototype.set_value = function(S, T, E, C) {
            E.baselines ? (S.innerHTML = "", E.baselines.forEach((D) => {
              $(S, D, E, C);
            })) : S.innerHTML = _.locale.labels.baselines_section_placeholder;
          }, p.prototype.get_value = function(S, T, E) {
            const C = [];
            return S.querySelectorAll("[data-baseline-id]").forEach((D) => {
              const A = D.dataset.baselineId;
              let I, M = _.getDatastore("baselines").getItem(A);
              I = M ? _.copy(M) : { id: _.uid(), task_id: T.id, text: "Baseline 1" }, I.start_date = w(D, E), I.duration = x(D, E), I.end_date = _.calculateEndDate({ start_date: I.start_date, duration: I.duration, task: T }), C.push(I);
            }), C;
          }, p.prototype.button_click = function(S, T, E, C) {
            if (_.callEvent("onSectionButton", [_._lightbox_id, E]) !== false && (T.closest(".gantt_custom_button.gantt_remove_baselines") && (C.innerHTML = _.locale.labels.baselines_section_placeholder), T.closest(".gantt_custom_button.gantt_add_baselines"))) {
              C.innerHTML == _.locale.labels.baselines_section_placeholder && (C.innerHTML = "");
              const D = _.getTask(_._lightbox_id);
              $(C, { id: _.uid(), task_id: D.id, text: "Baseline 1", start_date: D.start_date, end_date: D.end_date }, D, _._get_typed_lightbox_config()[S]);
            }
          }, p.prototype.focus = function(S) {
            _._focus(S.getElementsByTagName("select")[0]);
          }, p;
        }(t);
        t._lightbox_methods = {}, t._lightbox_template = "<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span></div><div class='gantt_cal_larea'></div>", t._lightbox_template = `<div class='gantt_cal_ltitle'><div class="dhx_cal_ltitle_descr"><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='dhx_title'></span>
</div>
<div class="gantt_cal_ltitle_controls">
	<a class="gantt_cal_ltitle_close_btn dhx_gantt_icon dhx_gantt_icon_close"></a>

</div></div><div class='gantt_cal_larea'></div>`, t._lightbox_root = t.$root, t.$services.getService("state").registerProvider("lightbox", function() {
          return { lightbox: t._lightbox_id };
        }), t.showLightbox = function(_) {
          var m = this.getTask(_);
          if (this.callEvent("onBeforeLightbox", [_])) {
            var p = this.getLightbox(this.getTaskType(m.type));
            this.showCover(p), this._fill_lightbox(_, p), this._setLbPosition(p), this._waiAria.lightboxVisibleAttr(p), this.callEvent("onLightbox", [_]);
          } else t.isTaskExists(_) && t.getTask(_).$new && this.$data.tasksStore._updateOrder();
        }, t._get_timepicker_step = function() {
          if (this.config.round_dnd_dates) {
            var _;
            if (function(p) {
              var k = p.$ui.getView("timeline");
              return !(!k || !k.isVisible());
            }(this)) {
              var m = t.getScale();
              _ = Bt(m.unit) * m.step / 60;
            }
            return (!_ || _ >= 1440) && (_ = this.config.time_step), _;
          }
          return this.config.time_step;
        }, t.getLabel = function(_, m) {
          for (var p = this._get_typed_lightbox_config(), k = 0; k < p.length; k++) if (p[k].map_to == _) {
            for (var $ = p[k].options, w = 0; w < $.length; w++) if ($[w].key == m) return $[w].label;
          }
          return "";
        }, t.updateCollection = function(_, m) {
          m = m.slice(0);
          var p = t.serverList(_);
          if (!p) return false;
          p.splice(0, p.length), p.push.apply(p, m || []), t.resetLightbox();
        }, t.getLightboxType = function() {
          return this.getTaskType(this._lightbox_type);
        }, t.getLightbox = function(_) {
          var m, p, k, $, w, x = "";
          if (function() {
            const T = t.config.csp === true, E = !!window.Sfdc || !!window.$A || window.Aura || "$shadowResolver$" in document.body;
            t._lightbox_root = T || E ? t.$root : document.body;
          }(), _ === void 0 && (_ = this.getLightboxType()), !this._lightbox || this.getLightboxType() != this.getTaskType(_)) {
            this._lightbox_type = this.getTaskType(_), m = document.createElement("div"), x = "gantt_cal_light", p = this._is_lightbox_timepicker(), t.config.wide_form && (x += " gantt_cal_light_wide"), p && (x += " gantt_cal_light_full"), m.className = x, m.style.visibility = "hidden", k = this._lightbox_template, k += "<div class='gantt_cal_lcontrols'>", k += y(this.config.buttons_left), k += "<div class='gantt_cal_lcontrols_push_right'></div>", k += y(this.config.buttons_right), k += "</div>", m.innerHTML = k, t._waiAria.lightboxAttr(m), t.config.drag_lightbox && (m.firstChild.onmousedown = t._ready_to_dnd, m.firstChild.ontouchstart = function(T) {
              t._ready_to_dnd(T.touches[0]);
            }, m.firstChild.onselectstart = function() {
              return false;
            }, m.firstChild.style.cursor = "pointer", t._init_dnd_events()), this._lightbox && this.resetLightbox(), g(), this._cover.insertBefore(m, this._cover.firstChild), this._lightbox = m, $ = this._get_typed_lightbox_config(_), k = this._render_sections($);
            var S = (w = m.querySelector("div.gantt_cal_larea")).style.overflow;
            w.style.overflow = "hidden", w.innerHTML = k, function(T) {
              var E, C, D, A, I, M;
              for (M = 0; M < T.length; M++) E = T[M], D = t._lightbox_root.querySelector("#" + E.id), E.id && D && (C = D.querySelector("label"), (A = D.nextSibling) && (I = A.querySelector("input, select, textarea")) && (I.id = I.id || "input_" + t.uid(), E.inputId = I.id, C.setAttribute("for", E.inputId)));
            }($), w.style.overflow = S, this._init_lightbox_events(this), m.style.display = "none", m.style.visibility = "visible";
          }
          return this._lightbox;
        }, t._render_sections = function(_) {
          for (var m = "", p = 0; p < _.length; p++) {
            var k = this.form_blocks[_[p].type];
            if (k) {
              _[p].id = "area_" + this.uid();
              var $ = _[p].hidden ? " style='display:none'" : "", w = "";
              _[p].button && (w = "<div class='gantt_custom_button' data-index='" + p + "'><div class='gantt_custom_button_" + _[p].button + "'></div><div class='gantt_custom_button_label'>" + this.locale.labels["button_" + _[p].button] + "</div></div>"), _[p].type == "baselines" && (w = "<div class='gantt_custom_button gantt_remove_baselines' data-index='" + p + "'><div class='gantt_custom_button_delete_baselines'></div><div class='gantt_custom_button_label'>" + this.locale.labels.baselines_remove_all_button + "</div></div><div class='gantt_custom_button gantt_add_baselines' data-index='" + p + "'><div class='gantt_custom_button_add_baseline'></div><div class='gantt_custom_button_label'>" + this.locale.labels.baselines_add_button + "</div></div>"), this.config.wide_form && (m += "<div class='gantt_wrap_section' " + $ + ">"), m += "<div id='" + _[p].id + "' class='gantt_cal_lsection'><label>" + w + this.locale.labels["section_" + _[p].name] + "</label></div>" + k.render.call(this, _[p]), m += "</div>";
            }
          }
          return m;
        }, t._center_lightbox = function(_) {
          t._setLbPosition(_);
        }, t._setLbPosition = function(_) {
          if (!_) return;
          const m = t._lightbox_root || t.$root;
          _.style.top = Math.max(m.offsetHeight / 2 - _.offsetHeight / 2, 0) + "px", _.style.left = Math.max(m.offsetWidth / 2 - _.offsetWidth / 2, 0) + "px";
        }, t.showCover = function(_) {
          _ && (_.style.display = "block", this._setLbPosition(_)), g(), this._cover.style.display = "";
        };
        const g = function() {
          t._cover || (t._cover = document.createElement("div"), t._cover.className = "gantt_cal_cover", t._cover.style.display = "none", t.event(t._cover, "mousemove", t._move_while_dnd), t.event(t._cover, "mouseup", t._finish_dnd), (t._lightbox_root || t.$root).appendChild(t._cover));
        };
        function f(_) {
          for (var m in this.config.types) if (this.config.types[m] == _) return m;
          return "task";
        }
        function y(_, m) {
          var p, k, $ = "";
          for (k = 0; k < _.length; k++) p = t.config._migrate_buttons[_[k]] ? t.config._migrate_buttons[_[k]] : _[k], $ += "<div " + t._waiAria.lightboxButtonAttrString(p) + " class='gantt_btn_set gantt_left_btn_set " + p + "_set'><div dhx_button='1' data-dhx-button='1' class='" + p + "'></div><div>" + t.locale.labels[p] + "</div></div>";
          return $;
        }
        function v(_) {
          var m, p;
          return _.time_format ? _.time_format : (p = ["%d", "%m", "%Y"], Bt((m = t.getScale()) ? m.unit : t.config.duration_unit) < Bt("day") && p.push("%H:%i"), p);
        }
        function b(_, m, p) {
          var k, $, w, x, S, T, E = "";
          switch (p.timeFormat[m]) {
            case "%Y":
              for (_._time_format_order[2] = m, _._time_format_order.size++, _.year_range && (isNaN(_.year_range) ? _.year_range.push && (w = _.year_range[0], x = _.year_range[1]) : k = _.year_range), k = k || 10, $ = $ || Math.floor(k / 2), w = w || p.date.getFullYear() - $, x = x || t.getState().max_date.getFullYear() + $, S = w; S < x; S++) E += "<option value='" + S + "'>" + S + "</option>";
              break;
            case "%m":
              for (_._time_format_order[1] = m, _._time_format_order.size++, S = 0; S < 12; S++) E += "<option value='" + S + "'>" + t.locale.date.month_full[S] + "</option>";
              break;
            case "%d":
              for (_._time_format_order[0] = m, _._time_format_order.size++, S = 1; S < 32; S++) E += "<option value='" + S + "'>" + S + "</option>";
              break;
            case "%H:%i":
              for (_._time_format_order[3] = m, _._time_format_order.size++, S = p.first, T = p.date.getDate(), _._time_values = []; S < p.last; ) E += "<option value='" + S + "'>" + t.templates.time_picker(p.date) + "</option>", _._time_values.push(S), p.date.setTime(p.date.valueOf() + 60 * t._get_timepicker_step() * 1e3), S = 24 * (p.date.getDate() != T ? 1 : 0) * 60 + 60 * p.date.getHours() + p.date.getMinutes();
          }
          return E;
        }
        t._init_lightbox_events = function() {
          t.lightbox_events = {}, t.lightbox_events.gantt_save_btn = function() {
            t._save_lightbox();
          }, t.lightbox_events.gantt_delete_btn = function() {
            t._lightbox_current_type = null, t.callEvent("onLightboxDelete", [t._lightbox_id]) && (t.isTaskExists(t._lightbox_id) ? t.$click.buttons.delete(t._lightbox_id) : t.hideLightbox());
          }, t.lightbox_events.gantt_cancel_btn = function() {
            t._cancel_lightbox();
          }, t.lightbox_events.default = function(_, m) {
            if (m.getAttribute("data-dhx-button")) t.callEvent("onLightboxButton", [m.className, m, _]);
            else {
              var p, k, $ = Y(m);
              if ($.indexOf("gantt_custom_button") != -1) if ($.indexOf("gantt_custom_button_") != -1) for (p = m.parentNode.getAttribute("data-index"), k = m; k && Y(k).indexOf("gantt_cal_lsection") == -1; ) k = k.parentNode;
              else p = m.getAttribute("data-index"), k = m.closest(".gantt_cal_lsection"), m = m.firstChild;
              var w = t._get_typed_lightbox_config();
              p && (p *= 1, t.form_blocks[w[1 * p].type].button_click(p, m, k, k.nextSibling));
            }
          }, this.event(t.getLightbox(), "click", function(_) {
            _.target.closest(".gantt_cal_ltitle_close_btn") && t._cancel_lightbox();
            var m = mt(_), p = Y(m);
            return p || (p = Y(m = m.previousSibling)), m && p && p.indexOf("gantt_btn_set") === 0 && (p = Y(m = m.firstChild)), !(!m || !p) && (t.defined(t.lightbox_events[m.className]) ? t.lightbox_events[m.className] : t.lightbox_events.default)(_, m);
          }), t.getLightbox().onkeydown = function(_) {
            var m = _ || window.event, p = _.target || _.srcElement, k = Y(p).indexOf("gantt_btn_set") > -1;
            switch ((_ || m).keyCode) {
              case t.constants.KEY_CODES.SPACE:
                if ((_ || m).shiftKey) return;
                k && p.click && p.click();
                break;
              case t.keys.edit_save:
                if ((_ || m).shiftKey) return;
                k && p.click ? p.click() : t._save_lightbox();
                break;
              case t.keys.edit_cancel:
                t._cancel_lightbox();
            }
          };
        }, t._cancel_lightbox = function() {
          var _ = this.getLightboxValues();
          t._lightbox_current_type = null, this.callEvent("onLightboxCancel", [this._lightbox_id, _.$new]), t.isTaskExists(_.id) && _.$new && (this.silent(function() {
            t.$data.tasksStore.removeItem(_.id), t._update_flags(_.id, null);
          }), this.refreshData()), this.hideLightbox();
        }, t._save_lightbox = function() {
          var _ = this.getLightboxValues();
          t._lightbox_current_type = null, this.callEvent("onLightboxSave", [this._lightbox_id, _, !!_.$new]) && (t.$data.tasksStore._skipTaskRecalculation = "lightbox", _.$new ? (delete _.$new, this.addTask(_, _.parent, this.getTaskIndex(_.id))) : this.isTaskExists(_.id) && (this.mixin(this.getTask(_.id), _, true), this.refreshTask(_.id), this.updateTask(_.id)), t.$data.tasksStore._skipTaskRecalculation = false, this.refreshData(), this.hideLightbox());
        }, t._resolve_default_mapping = function(_) {
          var m = _.map_to;
          return { time: true, time_optional: true, duration: true, duration_optional: true }[_.type] ? _.map_to == "auto" ? m = { start_date: "start_date", end_date: "end_date", duration: "duration" } : typeof _.map_to == "string" && (m = { start_date: _.map_to }) : _.type === "constraint" && (_.map_to && typeof _.map_to != "string" || (m = { constraint_type: "constraint_type", constraint_date: "constraint_date" })), m;
        }, t.getLightboxValues = function() {
          var _ = {};
          t.isTaskExists(this._lightbox_id) && (_ = this.mixin({}, this.getTask(this._lightbox_id)));
          for (var m = this._get_typed_lightbox_config(), p = 0; p < m.length; p++) {
            var k = t._lightbox_root.querySelector("#" + m[p].id);
            k = k && k.nextSibling;
            var $ = this.form_blocks[m[p].type];
            if ($) {
              var w = $.get_value.call(this, k, _, m[p]), x = t._resolve_default_mapping(m[p]);
              if (typeof x == "string" && x != "auto") _[x] = w;
              else if (typeof x == "object") for (var S in x) x[S] && (_[x[S]] = w[S]);
            }
          }
          return t._lightbox_current_type && (_.type = t._lightbox_current_type), _;
        }, t.hideLightbox = function() {
          var _ = this.getLightbox();
          _ && (_.style.display = "none"), this._waiAria.lightboxHiddenAttr(_), this._lightbox_id = null, this.hideCover(_), this.resetLightbox(), this.callEvent("onAfterLightbox", []);
        }, t.hideCover = function(_) {
          _ && (_.style.display = "none"), this._cover && this._cover.parentNode.removeChild(this._cover), this._cover = null;
        }, t.resetLightbox = function() {
          t._lightbox && !t._custom_lightbox && t._lightbox.remove(), t._lightbox = null;
        }, t._set_lightbox_values = function(_, m) {
          var p = _, k = m.getElementsByTagName("span"), $ = [];
          t.templates.lightbox_header ? ($.push(""), $.push(t.templates.lightbox_header(p.start_date, p.end_date, p)), k[1].innerHTML = "", k[2].innerHTML = t.templates.lightbox_header(p.start_date, p.end_date, p)) : ($.push(this.templates.task_time(p.start_date, p.end_date, p)), $.push(String(this.templates.task_text(p.start_date, p.end_date, p) || "").substr(0, 70)), k[1].innerHTML = this.templates.task_time(p.start_date, p.end_date, p), k[2].innerHTML = String(this.templates.task_text(p.start_date, p.end_date, p) || "").substr(0, 70)), k[1].innerHTML = $[0], k[2].innerHTML = $[1], t._waiAria.lightboxHeader(m, $.join(" "));
          for (var w = this._get_typed_lightbox_config(this.getLightboxType()), x = 0; x < w.length; x++) {
            var S = w[x];
            if (this.form_blocks[S.type]) {
              var T = t._lightbox_root.querySelector("#" + S.id).nextSibling, E = this.form_blocks[S.type], C = t._resolve_default_mapping(w[x]), D = this.defined(p[C]) ? p[C] : S.default_value;
              E.set_value.call(t, T, D, p, S), S.focus && E.focus.call(t, T);
            }
          }
          t.isTaskExists(_.id) && (t._lightbox_id = _.id);
        }, t._fill_lightbox = function(_, m) {
          var p = this.getTask(_);
          this._set_lightbox_values(p, m);
        }, t.getLightboxSection = function(_) {
          for (var m = this._get_typed_lightbox_config(), p = 0; p < m.length && m[p].name != _; p++) ;
          var k = m[p];
          if (!k) return null;
          this._lightbox || this.getLightbox();
          var $ = t._lightbox_root.querySelector("#" + k.id), w = $.nextSibling, x = { section: k, header: $, node: w, getValue: function(T) {
            return t.form_blocks[k.type].get_value.call(t, w, T || {}, k);
          }, setValue: function(T, E) {
            return t.form_blocks[k.type].set_value.call(t, w, T, E || {}, k);
          } }, S = this._lightbox_methods["get_" + k.type + "_control"];
          return S ? S(x) : x;
        }, t._lightbox_methods.get_template_control = function(_) {
          return _.control = _.node, _;
        }, t._lightbox_methods.get_select_control = function(_) {
          return _.control = _.node.getElementsByTagName("select")[0], _;
        }, t._lightbox_methods.get_textarea_control = function(_) {
          return _.control = _.node.getElementsByTagName("textarea")[0], _;
        }, t._lightbox_methods.get_time_control = function(_) {
          return _.control = _.node.getElementsByTagName("select"), _;
        }, t._init_dnd_events = function() {
          var _ = t._lightbox_root;
          this.event(_, "mousemove", t._move_while_dnd), this.event(_, "mouseup", t._finish_dnd), this.event(_, "touchmove", function(m) {
            t._move_while_dnd(m.touches[0]);
          }), this.event(_, "touchend", function(m) {
            t._finish_dnd(m.touches[0]);
          });
        }, t._move_while_dnd = function(_) {
          if (t._dnd_start_lb) {
            document.gantt_unselectable || (t._lightbox_root.className += " gantt_unselectable", document.gantt_unselectable = true);
            var m = t.getLightbox(), p = [_.pageX, _.pageY];
            m.style.top = t._lb_start[1] + p[1] - t._dnd_start_lb[1] + "px", m.style.left = t._lb_start[0] + p[0] - t._dnd_start_lb[0] + "px";
          }
        }, t._ready_to_dnd = function(_) {
          var m = t.getLightbox();
          t._lb_start = [m.offsetLeft, m.offsetTop], t._dnd_start_lb = [_.pageX, _.pageY];
        }, t._finish_dnd = function() {
          t._lb_start && (t._lb_start = t._dnd_start_lb = false, t._lightbox_root.className = t._lightbox_root.className.replace(" gantt_unselectable", ""), document.gantt_unselectable = false);
        }, t._focus = function(_, m) {
          if (_ && _.focus && !t.config.touch) try {
            m && _.select && _.select(), _.focus();
          } catch {
          }
        }, t.form_blocks = { getTimePicker: function(_, m) {
          var p, k, $, w = "", x = this.config, S = { first: 0, last: 1440, date: this.date.date_part(new Date(t._min_date.valueOf())), timeFormat: v(_) };
          for (_._time_format_order = { size: 0 }, t.config.limit_time_select && (S.first = 60 * x.first_hour, S.last = 60 * x.last_hour + 1, S.date.setHours(x.first_hour)), p = 0; p < S.timeFormat.length; p++) p > 0 && (w += " "), (k = b(_, p, S)) && ($ = t._waiAria.lightboxSelectAttrString(S.timeFormat[p]), w += "<select " + (_.readonly ? "disabled='disabled'" : "") + (m ? " style='display:none' " : "") + $ + ">" + k + "</select>");
          return w;
        }, getTimePickerValue: function(_, m, p) {
          var k, $ = m._time_format_order, w = 0, x = 0, S = p || 0;
          return t.defined($[3]) && (k = parseInt(_[$[3] + S].value, 10), w = Math.floor(k / 60), x = k % 60), new Date(_[$[2] + S].value, _[$[1] + S].value, _[$[0] + S].value, w, x);
        }, _fill_lightbox_select: function(_, m, p, k) {
          if (_[m + k[0]].value = p.getDate(), _[m + k[1]].value = p.getMonth(), _[m + k[2]].value = p.getFullYear(), t.defined(k[3])) {
            var $ = 60 * p.getHours() + p.getMinutes();
            $ = Math.round($ / t._get_timepicker_step()) * t._get_timepicker_step();
            var w = _[m + k[3]];
            w.value = $, w.setAttribute("data-value", $);
          }
        }, template: new e(), textarea: new n(), select: new a(), time: new i(), duration: new o(), parent: new l(), radio: new s(), checkbox: new r(), resources: new d(), constraint: new c(), baselines: new h(), typeselect: new u() }, t._is_lightbox_timepicker = function() {
          for (var _ = this._get_typed_lightbox_config(), m = 0; m < _.length; m++) if (_[m].name == "time" && _[m].type == "time") return true;
          return false;
        }, t._simple_confirm = function(_, m, p, k) {
          if (!_) return p();
          var $ = { text: _ };
          m && ($.title = m), k && ($.ok = k), p && ($.callback = function(w) {
            w && p();
          }), t.confirm($);
        }, t._get_typed_lightbox_config = function(_) {
          _ === void 0 && (_ = this.getLightboxType());
          var m = f.call(this, _);
          return t.config.lightbox[m + "_sections"] ? t.config.lightbox[m + "_sections"] : t.config.lightbox.sections;
        }, t._silent_redraw_lightbox = function(_) {
          var m = this.getLightboxType();
          if (this.getState().lightbox) {
            var p = this.getState().lightbox, k = this.getLightboxValues(), $ = this.copy(this.getTask(p));
            this.resetLightbox();
            var w = this.mixin($, k, true), x = this.getLightbox(_ || void 0);
            this._set_lightbox_values(w, x), this.showCover(x);
          } else this.resetLightbox(), this.getLightbox(_ || void 0);
          this.callEvent("onLightboxChange", [m, this.getLightboxType()]);
        };
      }
      function Za(t) {
        if (!ht.isNode) {
          t.utils = { arrayFind: Mn, dom: Ne };
          var e = re();
          t.event = e.attach, t.eventRemove = e.detach, t._eventRemoveAll = e.detachAll, t._createDomEventScope = e.extend, N(t, sa(t));
          var n = ja.init(t);
          t.$ui = n.factory, t.$ui.layers = n.render, t.$mouseEvents = n.mouseEvents, t.$services.setService("mouseEvents", function() {
            return t.$mouseEvents;
          }), t.mixin(t, n.layersApi), function(i) {
            delete i.addTaskLayer, delete i.addLinkLayer;
          }(t), t.$services.setService("layers", function() {
            return n.layersService;
          }), t.mixin(t, /* @__PURE__ */ function() {
            function i(u) {
              return u.$ui.getView("timeline");
            }
            function a(u) {
              return u.$ui.getView("grid");
            }
            function r(u) {
              var h = i(u);
              if (h && !h.$config.hidden) return h;
              var g = a(u);
              return g && !g.$config.hidden ? g : null;
            }
            function s(u) {
              var h = null, g = false;
              return [".gantt_drag_marker.gantt_grid_resize_area", ".gantt_drag_marker .gantt_row.gantt_row_task", ".gantt_drag_marker.gantt_grid_dnd_marker"].forEach(function(f) {
                g = g || !!document.querySelector(f);
              }), (h = g ? a(u) : r(u)) ? l(u, h, "scrollY") : null;
            }
            function o(u) {
              var h = r(u);
              return h && h.id != "grid" ? l(u, h, "scrollX") : null;
            }
            function l(u, h, g) {
              var f = h.$config[g];
              return u.$ui.getView(f);
            }
            var d = "DEFAULT_VALUE";
            function c(u, h, g, f) {
              var y = u(this);
              return y && y.isVisible() ? y[h].apply(y, g) : f ? f() : d;
            }
            return { getColumnIndex: function(u) {
              var h = c.call(this, a, "getColumnIndex", [u]);
              return h === d ? 0 : h;
            }, dateFromPos: function(u) {
              var h = c.call(this, i, "dateFromPos", Array.prototype.slice.call(arguments));
              return h === d ? this.getState().min_date : h;
            }, posFromDate: function(u) {
              var h = c.call(this, i, "posFromDate", [u]);
              return h === d ? 0 : h;
            }, getRowTop: function(u) {
              var h = this, g = c.call(h, i, "getRowTop", [u], function() {
                return c.call(h, a, "getRowTop", [u]);
              });
              return g === d ? 0 : g;
            }, getTaskTop: function(u) {
              var h = this, g = c.call(h, i, "getItemTop", [u], function() {
                return c.call(h, a, "getItemTop", [u]);
              });
              return g === d ? 0 : g;
            }, getTaskPosition: function(u, h, g) {
              var f = c.call(this, i, "getItemPosition", [u, h, g]);
              return f === d ? { left: 0, top: this.getTaskTop(u.id), height: this.getTaskBarHeight(u.id), width: 0 } : f;
            }, getTaskBarHeight: function(u, h) {
              var g = this, f = c.call(g, i, "getBarHeight", [u, h], function() {
                return c.call(g, a, "getItemHeight", [u]);
              });
              return f === d ? 0 : f;
            }, getTaskHeight: function(u) {
              var h = this, g = c.call(h, i, "getItemHeight", [u], function() {
                return c.call(h, a, "getItemHeight", [u]);
              });
              return g === d ? 0 : g;
            }, columnIndexByDate: function(u) {
              var h = c.call(this, i, "columnIndexByDate", [u]);
              return h === d ? 0 : h;
            }, roundTaskDates: function() {
              c.call(this, i, "roundTaskDates", []);
            }, getScale: function() {
              var u = c.call(this, i, "getScale", []);
              return u === d ? null : u;
            }, getTaskNode: function(u) {
              var h = i(this);
              if (h && h.isVisible()) {
                var g = h._taskRenderer.rendered[u];
                if (!g) {
                  var f = h.$config.item_attribute;
                  g = h.$task_bars.querySelector("[" + f + "='" + u + "']");
                }
                return g || null;
              }
              return null;
            }, getLinkNode: function(u) {
              var h = i(this);
              return h.isVisible() ? h._linkRenderer.rendered[u] : null;
            }, scrollTo: function(u, h) {
              var g = s(this), f = o(this), y = { position: 0 }, v = { position: 0 };
              g && (v = g.getScrollState()), f && (y = f.getScrollState());
              var b = f && 1 * u == u, _ = g && 1 * h == h;
              if (b && _) for (var m = g._getLinkedViews(), p = f._getLinkedViews(), k = [], $ = 0; $ < m.length; $++) for (var w = 0; w < p.length; w++) m[$].$config.id && p[w].$config.id && m[$].$config.id === p[w].$config.id && k.push(m[$].$config.id);
              b && (k && k.forEach(function(T) {
                this.$ui.getView(T).$config.$skipSmartRenderOnScroll = true;
              }.bind(this)), f.scroll(u), k && k.forEach(function(T) {
                this.$ui.getView(T).$config.$skipSmartRenderOnScroll = false;
              }.bind(this))), _ && g.scroll(h);
              var x = { position: 0 }, S = { position: 0 };
              g && (x = g.getScrollState()), f && (S = f.getScrollState()), this.callEvent("onGanttScroll", [y.position, v.position, S.position, x.position]);
            }, showDate: function(u) {
              var h = this.posFromDate(u), g = Math.max(h - this.config.task_scroll_offset, 0);
              this.scrollTo(g);
            }, showTask: function(u) {
              var h = this.getTaskPosition(this.getTask(u)), g = h.left;
              this.config.rtl && (g = h.left + h.width);
              var f, y = Math.max(g - this.config.task_scroll_offset, 0), v = this._scroll_state().y;
              f = v ? h.top - (v - this.getTaskBarHeight(u)) / 2 : h.top, this.scrollTo(y, f);
              var b = a(this), _ = i(this);
              b && _ && b.$config.scrollY != _.$config.scrollY && l(this, b, "scrollY").scrollTo(null, f);
            }, _scroll_state: function() {
              var u = { x: false, y: false, x_pos: 0, y_pos: 0, scroll_size: this.config.scroll_size + 1, x_inner: 0, y_inner: 0 }, h = s(this), g = o(this);
              if (g) {
                var f = g.getScrollState();
                f.visible && (u.x = f.size, u.x_inner = f.scrollSize), u.x_pos = f.position || 0;
              }
              if (h) {
                var y = h.getScrollState();
                y.visible && (u.y = y.size, u.y_inner = y.scrollSize), u.y_pos = y.position || 0;
              }
              return u;
            }, getScrollState: function() {
              var u = this._scroll_state();
              return { x: u.x_pos, y: u.y_pos, inner_width: u.x, inner_height: u.y, width: u.x_inner, height: u.y_inner };
            }, getLayoutView: function(u) {
              return this.$ui.getView(u);
            }, scrollLayoutCell: function(u, h, g) {
              const f = this.$ui.getView(u);
              if (!f) return false;
              if (h !== null) {
                const y = this.$ui.getView(f.$config.scrollX);
                y && y.scrollTo(h, null);
              }
              if (g !== null) {
                const y = this.$ui.getView(f.$config.scrollY);
                y && y.scrollTo(null, g);
              }
            } };
          }()), function(i) {
            i.resetSkin || (i.resetSkin = function() {
              this.skin = "", $e(true, this);
            }, i.skins = {}, i.attachEvent("onGanttLayoutReady", function() {
              $e(false, this), r();
            })), i._addThemeClass = function() {
              document.documentElement.setAttribute("data-gantt-theme", i.skin);
            }, i.setSkin = function(s) {
              this.skin = s, i._addThemeClass(), r(), i.$root && ($e(true, i), this.render());
            };
            let a = null;
            function r() {
              const s = i.$root;
              a && clearInterval(a), s && (a = setInterval(() => {
                const o = getComputedStyle(s).getPropertyValue("--dhx-gantt-theme");
                o && o !== i.skin && i.setSkin(o);
              }, 100));
            }
            i.attachEvent("onDestroy", function() {
              clearInterval(a);
            });
          }(t), function(i) {
            i.skins.skyblue = { config: { grid_width: 370, row_height: 27, bar_height_padding: 4, scale_height: 27, link_line_width: 1, link_arrow_size: 8, link_radius: 2, lightbox_additional_height: 75 }, _second_column_width: 95, _third_column_width: 80 };
          }(t), function(i) {
            i.skins.dark = { config: { grid_width: 390, row_height: 36, scale_height: 36, link_line_width: 2, link_arrow_size: 12, bar_height_padding: 9, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 70 };
          }(t), function(i) {
            i.skins.meadow = { config: { grid_width: 380, row_height: 27, scale_height: 30, link_line_width: 2, link_arrow_size: 10, bar_height_padding: 4, lightbox_additional_height: 72 }, _second_column_width: 95, _third_column_width: 80 };
          }(t), function(i) {
            i.skins.terrace = { config: { grid_width: 390, row_height: 36, scale_height: 36, link_line_width: 2, link_arrow_size: 12, bar_height_padding: 9, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 70 };
          }(t), function(i) {
            i.skins.broadway = { config: { grid_width: 390, row_height: 35, scale_height: 35, link_line_width: 1, link_arrow_size: 9, bar_height_padding: 4, lightbox_additional_height: 86 }, _second_column_width: 100, _third_column_width: 80, _lightbox_template: "<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span><div class='gantt_cancel_btn'></div></div><div class='gantt_cal_larea'></div>", _config_buttons_left: {}, _config_buttons_right: { gantt_delete_btn: "icon_delete", gantt_save_btn: "icon_save" } };
          }(t), function(i) {
            i.skins.material = { config: { grid_width: 411, row_height: 34, scale_height: 36, link_line_width: 2, link_arrow_size: 12, bar_height_padding: 9, lightbox_additional_height: 80 }, _second_column_width: 110, _third_column_width: 75, _redefine_lightbox_buttons: { buttons_left: ["dhx_delete_btn"], buttons_right: ["dhx_cancel_btn", "dhx_save_btn"] } }, i.attachEvent("onAfterTaskDrag", function(a) {
              var r = i.getTaskNode(a);
              r && (r.className += " gantt_drag_animation", setTimeout(function() {
                var s = r.className.indexOf(" gantt_drag_animation");
                s > -1 && (r.className = r.className.slice(0, s));
              }, 200));
            });
          }(t), function(i) {
            i.skins.contrast_black = { config: { grid_width: 390, row_height: 35, scale_height: 35, link_line_width: 2, link_arrow_size: 12, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 80 };
          }(t), function(i) {
            i.skins.contrast_white = { config: { grid_width: 390, row_height: 35, scale_height: 35, link_line_width: 2, link_arrow_size: 12, lightbox_additional_height: 75 }, _second_column_width: 100, _third_column_width: 80 };
          }(t), function(i) {
            i.ext || (i.ext = {});
            for (var a = [Fa, Va, Ua], r = 0; r < a.length; r++) a[r] && a[r](i);
            i.ext.zoom = new Ya(i);
          }(t), Ja(t), Xa(t), function(i) {
            i._extend_to_optional = function(a) {
              var r = a, s = { render: r.render, focus: r.focus, set_value: function(o, l, d, c) {
                var u = i._resolve_default_mapping(c);
                if (!d[u.start_date] || u.start_date == "start_date" && this._isAllowedUnscheduledTask(d)) {
                  s.disable(o, c);
                  var h = {};
                  for (var g in u) h[u[g]] = d[g];
                  return r.set_value.call(i, o, l, h, c);
                }
                return s.enable(o, c), r.set_value.call(i, o, l, d, c);
              }, get_value: function(o, l, d) {
                return d.disabled ? { start_date: null } : r.get_value.call(i, o, l, d);
              }, update_block: function(o, l) {
                if (i.callEvent("onSectionToggle", [i._lightbox_id, l]), o.style.display = l.disabled ? "none" : "", l.button) {
                  var d = o.previousSibling.querySelector(".gantt_custom_button_label"), c = i.locale.labels, u = l.disabled ? c[l.name + "_enable_button"] : c[l.name + "_disable_button"];
                  d.innerHTML = u;
                }
              }, disable: function(o, l) {
                l.disabled = true, s.update_block(o, l);
              }, enable: function(o, l) {
                l.disabled = false, s.update_block(o, l);
              }, button_click: function(o, l, d, c) {
                if (i.callEvent("onSectionButton", [i._lightbox_id, d]) !== false) {
                  var u = i._get_typed_lightbox_config()[o];
                  u.disabled ? s.enable(c, u) : s.disable(c, u);
                }
              } };
              return s;
            }, i.form_blocks.duration_optional = i._extend_to_optional(i.form_blocks.duration), i.form_blocks.time_optional = i._extend_to_optional(i.form_blocks.time);
          }(t), function(i) {
            var a = new RegExp(`<(?:.|
)*?>`, "gm"), r = new RegExp(" +", "gm");
            function s(c) {
              return (c + "").replace(a, " ").replace(r, " ");
            }
            var o = new RegExp("'", "gm");
            function l(c) {
              return (c + "").replace(o, "&#39;");
            }
            for (var d in i._waiAria = { getAttributeString: function(c) {
              var u = [" "];
              for (var h in c) {
                var g = l(s(c[h]));
                u.push(h + "='" + g + "'");
              }
              return u.push(" "), u.join(" ");
            }, getTimelineCellAttr: function(c) {
              return i._waiAria.getAttributeString({ "aria-label": c });
            }, _taskCommonAttr: function(c, u) {
              c.start_date && c.end_date && (u.setAttribute("aria-label", s(i.templates.tooltip_text(c.start_date, c.end_date, c))), c.$dataprocessor_class && u.setAttribute("aria-busy", true));
            }, setTaskBarAttr: function(c, u) {
              this._taskCommonAttr(c, u), u.setAttribute("role", "img"), !i.isReadonly(c) && i.config.drag_move && (c.id != i.getState("tasksDnd").drag_id ? u.setAttribute("aria-grabbed", false) : u.setAttribute("aria-grabbed", true));
            }, taskRowAttr: function(c, u) {
              this._taskCommonAttr(c, u), !i.isReadonly(c) && i.config.order_branch && u.setAttribute("aria-grabbed", false), u.setAttribute("role", "row"), u.setAttribute("aria-selected", i.isSelectedTask(c.id) ? "true" : "false"), u.setAttribute("aria-level", c.$level + 1 || 1), i.hasChild(c.id) && u.setAttribute("aria-expanded", c.$open ? "true" : "false");
            }, linkAttr: function(c, u) {
              var h = i.config.links, g = c.type == h.finish_to_start || c.type == h.start_to_start, f = c.type == h.start_to_start || c.type == h.start_to_finish, y = i.locale.labels.link + " " + i.templates.drag_link(c.source, f, c.target, g);
              u.setAttribute("role", "img"), u.setAttribute("aria-label", s(y)), i.isReadonly(c) && u.setAttribute("aria-readonly", true);
            }, gridSeparatorAttr: function(c) {
              c.setAttribute("role", "columnheader");
            }, rowResizerAttr: function(c) {
              c.setAttribute("role", "row");
            }, lightboxHiddenAttr: function(c) {
              c.setAttribute("aria-hidden", "true");
            }, lightboxVisibleAttr: function(c) {
              c.setAttribute("aria-hidden", "false");
            }, lightboxAttr: function(c) {
              c.setAttribute("role", "dialog"), c.setAttribute("aria-hidden", "true"), c.firstChild.setAttribute("role", "heading"), c.firstChild.setAttribute("aria-level", "1");
            }, lightboxButtonAttrString: function(c) {
              return this.getAttributeString({ role: "button", "aria-label": i.locale.labels[c], tabindex: "0" });
            }, lightboxHeader: function(c, u) {
              c.setAttribute("aria-label", u);
            }, lightboxSelectAttrString: function(c) {
              var u = "";
              switch (c) {
                case "%Y":
                  u = i.locale.labels.years;
                  break;
                case "%m":
                  u = i.locale.labels.months;
                  break;
                case "%d":
                  u = i.locale.labels.days;
                  break;
                case "%H:%i":
                  u = i.locale.labels.hours + i.locale.labels.minutes;
              }
              return i._waiAria.getAttributeString({ "aria-label": u });
            }, lightboxDurationInputAttrString: function(c) {
              return this.getAttributeString({ "aria-label": i.locale.labels.column_duration, "aria-valuemin": "0", role: "spinbutton" });
            }, inlineEditorAttr: function(c) {
              c.setAttribute("role", "row");
            }, gridAttrString: function() {
              return [" role='treegrid'", i.config.multiselect ? "aria-multiselectable='true'" : "aria-multiselectable='false'", " "].join(" ");
            }, gridScaleRowAttrString: function() {
              return "role='row'";
            }, gridScaleCellAttrString: function(c, u) {
              var h = "";
              if (c.name == "add") h = this.getAttributeString({ role: "columnheader", "aria-label": i.locale.labels.new_task });
              else {
                var g = { role: "columnheader", "aria-label": u };
                i._sort && i._sort.name == c.name && (i._sort.direction == "asc" ? g["aria-sort"] = "ascending" : g["aria-sort"] = "descending"), h = this.getAttributeString(g);
              }
              return h;
            }, gridDataAttrString: function() {
              return "role='rowgroup'";
            }, reorderMarkerAttr: function(c) {
              c.setAttribute("role", "grid"), c.firstChild.removeAttribute("aria-level"), c.firstChild.setAttribute("aria-grabbed", "true");
            }, gridCellAttrString: function(c, u, h) {
              var g = { role: "gridcell", "aria-label": u };
              return c.editor && !i.isReadonly(h) || (g["aria-readonly"] = true), this.getAttributeString(g);
            }, gridAddButtonAttrString: function(c) {
              return this.getAttributeString({ role: "button", "aria-label": i.locale.labels.new_task });
            }, messageButtonAttrString: function(c) {
              return "tabindex='0' role='button' aria-label='" + c + "'";
            }, messageInfoAttr: function(c) {
              c.setAttribute("role", "alert");
            }, messageModalAttr: function(c, u) {
              c.setAttribute("role", "dialog"), u && c.setAttribute("aria-labelledby", u);
            }, quickInfoAttr: function(c) {
              c.setAttribute("role", "dialog");
            }, quickInfoHeaderAttrString: function() {
              return " role='heading' aria-level='1' ";
            }, quickInfoHeader: function(c, u) {
              c.setAttribute("aria-label", u);
            }, quickInfoButtonAttrString: function(c) {
              return i._waiAria.getAttributeString({ role: "button", "aria-label": c, tabindex: "0" });
            }, tooltipAttr: function(c) {
              c.setAttribute("role", "tooltip");
            }, tooltipVisibleAttr: function(c) {
              c.setAttribute("aria-hidden", "false");
            }, tooltipHiddenAttr: function(c) {
              c.setAttribute("aria-hidden", "true");
            } }, i._waiAria) i._waiAria[d] = /* @__PURE__ */ function(c) {
              return function() {
                return i.config.wai_aria_attributes ? c.apply(this, arguments) : "";
              };
            }(i._waiAria[d]);
          }(t), t.locate = function(i) {
            var a = mt(i);
            if (ot(a, ".gantt_task_row")) return null;
            var r = arguments[1] || this.config.task_attribute, s = Z(a, r);
            return s ? s.getAttribute(r) : null;
          }, t._locate_css = function(i, a, r) {
            return ut(i, a, r);
          }, t._locateHTML = function(i, a) {
            return Z(i, a || this.config.task_attribute);
          };
        }
        t.attachEvent("onParse", function() {
          F(t) || t.attachEvent("onGanttRender", function() {
            if (t.config.initial_scroll) {
              var i = t.getTaskByIndex(0), a = i ? i.id : t.config.root_id;
              t.isTaskExists(a) && t.$task && t.utils.dom.isChildOf(t.$task, t.$container) && t.showTask(a);
            }
          }, { once: true });
        }), t.attachEvent("onBeforeGanttReady", function() {
          this.config.scroll_size || (this.config.scroll_size = Te() || 15), F(t) || (this._eventRemoveAll(), this.$mouseEvents.reset(), this.resetLightbox());
        }), t.attachEvent("onGanttReady", function() {
          !F(t) && t.config.rtl && t.$layout.getCellsByType("viewCell").forEach(function(i) {
            var a = i.$config.scrollX;
            if (a) {
              var r = t.$ui.getView(a);
              r && r.scrollTo(r.$config.scrollSize, 0);
            }
          });
        }), t.attachEvent("onGanttReady", function() {
          if (!F(t)) {
            var i = t.plugins(), a = { auto_scheduling: t.autoSchedule, click_drag: t.ext.clickDrag, critical_path: t.isCriticalTask, drag_timeline: t.ext.dragTimeline, export_api: t.exportToPDF, fullscreen: t.ext.fullscreen, grouping: t.groupBy, keyboard_navigation: t.ext.keyboardNavigation, marker: t.addMarker, multiselect: t.eachSelectedTask, overlay: t.ext.overlay, quick_info: t.templates.quick_info_content, tooltip: t.ext.tooltips, undo: t.undo };
            for (let r in a) a[r] && !i[r] && console.warn(`You connected the '${r}' extension via an obsolete file. 
To fix it, you need to remove the obsolete file and connect the extension via the plugins method: https://docs.dhtmlx.com/gantt/api__gantt_plugins.html`);
          }
        });
      }
      const wn = lt.gantt = function(t) {
        var e = ra(t);
        return e.env.isNode || (Za(e), function(n) {
          n.load = function(i, a, r) {
            this._load_url = i, this.assert(arguments.length, "Invalid load arguments");
            var s = "json", o = null;
            return arguments.length >= 3 ? (s = a, o = r) : typeof arguments[1] == "string" ? s = arguments[1] : typeof arguments[1] == "function" && (o = arguments[1]), this._load_type = s, this.callEvent("onLoadStart", [i, s]), this.ajax.get(i, n.bind(function(l) {
              this.on_load(l, s), this.callEvent("onLoadEnd", [i, s]), typeof o == "function" && o.call(this);
            }, this));
          };
        }(e)), e;
      }(jn);
      yt.default = wn, yt.gantt = wn, Object.defineProperties(yt, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    });
  }
});

// node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
var turbo_es2017_esm_exports = {};
__export(turbo_es2017_esm_exports, {
  FetchEnctype: () => FetchEnctype,
  FetchMethod: () => FetchMethod,
  FetchRequest: () => FetchRequest,
  FetchResponse: () => FetchResponse,
  FrameElement: () => FrameElement,
  FrameLoadingStyle: () => FrameLoadingStyle,
  FrameRenderer: () => FrameRenderer,
  PageRenderer: () => PageRenderer,
  PageSnapshot: () => PageSnapshot,
  StreamActions: () => StreamActions,
  StreamElement: () => StreamElement,
  StreamSourceElement: () => StreamSourceElement,
  cache: () => cache,
  clearCache: () => clearCache,
  config: () => config,
  connectStreamSource: () => connectStreamSource,
  disconnectStreamSource: () => disconnectStreamSource,
  fetch: () => fetchWithTurboHeaders,
  fetchEnctypeFromString: () => fetchEnctypeFromString,
  fetchMethodFromString: () => fetchMethodFromString,
  isSafe: () => isSafe,
  navigator: () => navigator$1,
  registerAdapter: () => registerAdapter,
  renderStreamMessage: () => renderStreamMessage,
  session: () => session,
  setConfirmMethod: () => setConfirmMethod,
  setFormMode: () => setFormMode,
  setProgressBarDelay: () => setProgressBarDelay,
  start: () => start,
  visit: () => visit
});
(function(prototype) {
  if (typeof prototype.requestSubmit == "function") return;
  prototype.requestSubmit = function(submitter2) {
    if (submitter2) {
      validateSubmitter(submitter2, this);
      submitter2.click();
    } else {
      submitter2 = document.createElement("input");
      submitter2.type = "submit";
      submitter2.hidden = true;
      this.appendChild(submitter2);
      submitter2.click();
      this.removeChild(submitter2);
    }
  };
  function validateSubmitter(submitter2, form) {
    submitter2 instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
    submitter2.type == "submit" || raise(TypeError, "The specified element is not a submit button");
    submitter2.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
  }
  function raise(errorConstructor, message, name) {
    throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
  }
})(HTMLFormElement.prototype);
var submittersByForm = /* @__PURE__ */ new WeakMap();
function findSubmitterFromClickTarget(target) {
  const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
  const candidate = element ? element.closest("input, button") : null;
  return candidate?.type == "submit" ? candidate : null;
}
function clickCaptured(event) {
  const submitter2 = findSubmitterFromClickTarget(event.target);
  if (submitter2 && submitter2.form) {
    submittersByForm.set(submitter2.form, submitter2);
  }
}
(function() {
  if ("submitter" in Event.prototype) return;
  let prototype = window.Event.prototype;
  if ("SubmitEvent" in window) {
    const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
    if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
      prototype = prototypeOfSubmitEvent;
    } else {
      return;
    }
  }
  addEventListener("click", clickCaptured, true);
  Object.defineProperty(prototype, "submitter", {
    get() {
      if (this.type == "submit" && this.target instanceof HTMLFormElement) {
        return submittersByForm.get(this.target);
      }
    }
  });
})();
var FrameLoadingStyle = {
  eager: "eager",
  lazy: "lazy"
};
var FrameElement = class _FrameElement extends HTMLElement {
  static delegateConstructor = void 0;
  loaded = Promise.resolve();
  static get observedAttributes() {
    return ["disabled", "loading", "src"];
  }
  constructor() {
    super();
    this.delegate = new _FrameElement.delegateConstructor(this);
  }
  connectedCallback() {
    this.delegate.connect();
  }
  disconnectedCallback() {
    this.delegate.disconnect();
  }
  reload() {
    return this.delegate.sourceURLReloaded();
  }
  attributeChangedCallback(name) {
    if (name == "loading") {
      this.delegate.loadingStyleChanged();
    } else if (name == "src") {
      this.delegate.sourceURLChanged();
    } else if (name == "disabled") {
      this.delegate.disabledChanged();
    }
  }
  /**
   * Gets the URL to lazily load source HTML from
   */
  get src() {
    return this.getAttribute("src");
  }
  /**
   * Sets the URL to lazily load source HTML from
   */
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }
  /**
   * Gets the refresh mode for the frame.
   */
  get refresh() {
    return this.getAttribute("refresh");
  }
  /**
   * Sets the refresh mode for the frame.
   */
  set refresh(value) {
    if (value) {
      this.setAttribute("refresh", value);
    } else {
      this.removeAttribute("refresh");
    }
  }
  get shouldReloadWithMorph() {
    return this.src && this.refresh === "morph";
  }
  /**
   * Determines if the element is loading
   */
  get loading() {
    return frameLoadingStyleFromString(this.getAttribute("loading") || "");
  }
  /**
   * Sets the value of if the element is loading
   */
  set loading(value) {
    if (value) {
      this.setAttribute("loading", value);
    } else {
      this.removeAttribute("loading");
    }
  }
  /**
   * Gets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  get disabled() {
    return this.hasAttribute("disabled");
  }
  /**
   * Sets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  set disabled(value) {
    if (value) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }
  /**
   * Gets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  get autoscroll() {
    return this.hasAttribute("autoscroll");
  }
  /**
   * Sets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  set autoscroll(value) {
    if (value) {
      this.setAttribute("autoscroll", "");
    } else {
      this.removeAttribute("autoscroll");
    }
  }
  /**
   * Determines if the element has finished loading
   */
  get complete() {
    return !this.delegate.isLoading;
  }
  /**
   * Gets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isActive() {
    return this.ownerDocument === document && !this.isPreview;
  }
  /**
   * Sets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isPreview() {
    return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
  }
};
function frameLoadingStyleFromString(style) {
  switch (style.toLowerCase()) {
    case "lazy":
      return FrameLoadingStyle.lazy;
    default:
      return FrameLoadingStyle.eager;
  }
}
var drive = {
  enabled: true,
  progressBarDelay: 500,
  unvisitableExtensions: /* @__PURE__ */ new Set(
    [
      ".7z",
      ".aac",
      ".apk",
      ".avi",
      ".bmp",
      ".bz2",
      ".css",
      ".csv",
      ".deb",
      ".dmg",
      ".doc",
      ".docx",
      ".exe",
      ".gif",
      ".gz",
      ".heic",
      ".heif",
      ".ico",
      ".iso",
      ".jpeg",
      ".jpg",
      ".js",
      ".json",
      ".m4a",
      ".mkv",
      ".mov",
      ".mp3",
      ".mp4",
      ".mpeg",
      ".mpg",
      ".msi",
      ".ogg",
      ".ogv",
      ".pdf",
      ".pkg",
      ".png",
      ".ppt",
      ".pptx",
      ".rar",
      ".rtf",
      ".svg",
      ".tar",
      ".tif",
      ".tiff",
      ".txt",
      ".wav",
      ".webm",
      ".webp",
      ".wma",
      ".wmv",
      ".xls",
      ".xlsx",
      ".xml",
      ".zip"
    ]
  )
};
function activateScriptElement(element) {
  if (element.getAttribute("data-turbo-eval") == "false") {
    return element;
  } else {
    const createdScriptElement = document.createElement("script");
    const cspNonce = getCspNonce();
    if (cspNonce) {
      createdScriptElement.nonce = cspNonce;
    }
    createdScriptElement.textContent = element.textContent;
    createdScriptElement.async = false;
    copyElementAttributes(createdScriptElement, element);
    return createdScriptElement;
  }
}
function copyElementAttributes(destinationElement, sourceElement) {
  for (const { name, value } of sourceElement.attributes) {
    destinationElement.setAttribute(name, value);
  }
}
function createDocumentFragment(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function dispatch(eventName, { target, cancelable, detail } = {}) {
  const event = new CustomEvent(eventName, {
    cancelable,
    bubbles: true,
    composed: true,
    detail
  });
  if (target && target.isConnected) {
    target.dispatchEvent(event);
  } else {
    document.documentElement.dispatchEvent(event);
  }
  return event;
}
function cancelEvent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function nextRepaint() {
  if (document.visibilityState === "hidden") {
    return nextEventLoopTick();
  } else {
    return nextAnimationFrame();
  }
}
function nextAnimationFrame() {
  return new Promise((resolve) => requestAnimationFrame(() => resolve()));
}
function nextEventLoopTick() {
  return new Promise((resolve) => setTimeout(() => resolve(), 0));
}
function nextMicrotask() {
  return Promise.resolve();
}
function parseHTMLDocument(html = "") {
  return new DOMParser().parseFromString(html, "text/html");
}
function unindent(strings, ...values) {
  const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
  const match = lines[0].match(/^\s+/);
  const indent = match ? match[0].length : 0;
  return lines.map((line) => line.slice(indent)).join("\n");
}
function interpolate(strings, values) {
  return strings.reduce((result, string, i) => {
    const value = values[i] == void 0 ? "" : values[i];
    return result + string + value;
  }, "");
}
function uuid() {
  return Array.from({ length: 36 }).map((_, i) => {
    if (i == 8 || i == 13 || i == 18 || i == 23) {
      return "-";
    } else if (i == 14) {
      return "4";
    } else if (i == 19) {
      return (Math.floor(Math.random() * 4) + 8).toString(16);
    } else {
      return Math.floor(Math.random() * 15).toString(16);
    }
  }).join("");
}
function getAttribute(attributeName, ...elements) {
  for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
    if (typeof value == "string") return value;
  }
  return null;
}
function hasAttribute(attributeName, ...elements) {
  return elements.some((element) => element && element.hasAttribute(attributeName));
}
function markAsBusy(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.setAttribute("busy", "");
    }
    element.setAttribute("aria-busy", "true");
  }
}
function clearBusyState(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.removeAttribute("busy");
    }
    element.removeAttribute("aria-busy");
  }
}
function waitForLoad(element, timeoutInMilliseconds = 2e3) {
  return new Promise((resolve) => {
    const onComplete = () => {
      element.removeEventListener("error", onComplete);
      element.removeEventListener("load", onComplete);
      resolve();
    };
    element.addEventListener("load", onComplete, { once: true });
    element.addEventListener("error", onComplete, { once: true });
    setTimeout(resolve, timeoutInMilliseconds);
  });
}
function getHistoryMethodForAction(action) {
  switch (action) {
    case "replace":
      return history.replaceState;
    case "advance":
    case "restore":
      return history.pushState;
  }
}
function isAction(action) {
  return action == "advance" || action == "replace" || action == "restore";
}
function getVisitAction(...elements) {
  const action = getAttribute("data-turbo-action", ...elements);
  return isAction(action) ? action : null;
}
function getMetaElement(name) {
  return document.querySelector(`meta[name="${name}"]`);
}
function getMetaContent(name) {
  const element = getMetaElement(name);
  return element && element.content;
}
function getCspNonce() {
  const element = getMetaElement("csp-nonce");
  if (element) {
    const { nonce, content } = element;
    return nonce == "" ? content : nonce;
  }
}
function setMetaContent(name, content) {
  let element = getMetaElement(name);
  if (!element) {
    element = document.createElement("meta");
    element.setAttribute("name", name);
    document.head.appendChild(element);
  }
  element.setAttribute("content", content);
  return element;
}
function findClosestRecursively(element, selector) {
  if (element instanceof Element) {
    return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
  }
}
function elementIsFocusable(element) {
  const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
}
function queryAutofocusableElement(elementOrDocumentFragment) {
  return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
}
async function around(callback, reader) {
  const before = reader();
  callback();
  await nextAnimationFrame();
  const after = reader();
  return [before, after];
}
function doesNotTargetIFrame(name) {
  if (name === "_blank") {
    return false;
  } else if (name) {
    for (const element of document.getElementsByName(name)) {
      if (element instanceof HTMLIFrameElement) return false;
    }
    return true;
  } else {
    return true;
  }
}
function findLinkFromClickTarget(target) {
  return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
}
function getLocationForLink(link) {
  return expandURL(link.getAttribute("href") || "");
}
function debounce(fn2, delay) {
  let timeoutId = null;
  return (...args) => {
    const callback = () => fn2.apply(this, args);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(callback, delay);
  };
}
var submitter = {
  "aria-disabled": {
    beforeSubmit: (submitter2) => {
      submitter2.setAttribute("aria-disabled", "true");
      submitter2.addEventListener("click", cancelEvent);
    },
    afterSubmit: (submitter2) => {
      submitter2.removeAttribute("aria-disabled");
      submitter2.removeEventListener("click", cancelEvent);
    }
  },
  "disabled": {
    beforeSubmit: (submitter2) => submitter2.disabled = true,
    afterSubmit: (submitter2) => submitter2.disabled = false
  }
};
var Config = class {
  #submitter = null;
  constructor(config2) {
    Object.assign(this, config2);
  }
  get submitter() {
    return this.#submitter;
  }
  set submitter(value) {
    this.#submitter = submitter[value] || value;
  }
};
var forms = new Config({
  mode: "on",
  submitter: "disabled"
});
var config = {
  drive,
  forms
};
function expandURL(locatable) {
  return new URL(locatable.toString(), document.baseURI);
}
function getAnchor(url) {
  let anchorMatch;
  if (url.hash) {
    return url.hash.slice(1);
  } else if (anchorMatch = url.href.match(/#(.*)$/)) {
    return anchorMatch[1];
  }
}
function getAction$1(form, submitter2) {
  const action = submitter2?.getAttribute("formaction") || form.getAttribute("action") || form.action;
  return expandURL(action);
}
function getExtension(url) {
  return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
}
function isPrefixedBy(baseURL, url) {
  const prefix = getPrefix(url);
  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
}
function locationIsVisitable(location2, rootLocation) {
  return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
}
function getRequestURL(url) {
  const anchor = getAnchor(url);
  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
}
function toCacheKey(url) {
  return getRequestURL(url);
}
function urlsAreEqual(left2, right2) {
  return expandURL(left2).href == expandURL(right2).href;
}
function getPathComponents(url) {
  return url.pathname.split("/").slice(1);
}
function getLastPathComponent(url) {
  return getPathComponents(url).slice(-1)[0];
}
function getPrefix(url) {
  return addTrailingSlash(url.origin + url.pathname);
}
function addTrailingSlash(value) {
  return value.endsWith("/") ? value : value + "/";
}
var FetchResponse = class {
  constructor(response) {
    this.response = response;
  }
  get succeeded() {
    return this.response.ok;
  }
  get failed() {
    return !this.succeeded;
  }
  get clientError() {
    return this.statusCode >= 400 && this.statusCode <= 499;
  }
  get serverError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
  get redirected() {
    return this.response.redirected;
  }
  get location() {
    return expandURL(this.response.url);
  }
  get isHTML() {
    return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
  }
  get statusCode() {
    return this.response.status;
  }
  get contentType() {
    return this.header("Content-Type");
  }
  get responseText() {
    return this.response.clone().text();
  }
  get responseHTML() {
    if (this.isHTML) {
      return this.response.clone().text();
    } else {
      return Promise.resolve(void 0);
    }
  }
  header(name) {
    return this.response.headers.get(name);
  }
};
var LimitedSet = class extends Set {
  constructor(maxSize) {
    super();
    this.maxSize = maxSize;
  }
  add(value) {
    if (this.size >= this.maxSize) {
      const iterator = this.values();
      const oldestValue = iterator.next().value;
      this.delete(oldestValue);
    }
    super.add(value);
  }
};
var recentRequests = new LimitedSet(20);
var nativeFetch = window.fetch;
function fetchWithTurboHeaders(url, options = {}) {
  const modifiedHeaders = new Headers(options.headers || {});
  const requestUID = uuid();
  recentRequests.add(requestUID);
  modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
  return nativeFetch(url, {
    ...options,
    headers: modifiedHeaders
  });
}
function fetchMethodFromString(method) {
  switch (method.toLowerCase()) {
    case "get":
      return FetchMethod.get;
    case "post":
      return FetchMethod.post;
    case "put":
      return FetchMethod.put;
    case "patch":
      return FetchMethod.patch;
    case "delete":
      return FetchMethod.delete;
  }
}
var FetchMethod = {
  get: "get",
  post: "post",
  put: "put",
  patch: "patch",
  delete: "delete"
};
function fetchEnctypeFromString(encoding) {
  switch (encoding.toLowerCase()) {
    case FetchEnctype.multipart:
      return FetchEnctype.multipart;
    case FetchEnctype.plain:
      return FetchEnctype.plain;
    default:
      return FetchEnctype.urlEncoded;
  }
}
var FetchEnctype = {
  urlEncoded: "application/x-www-form-urlencoded",
  multipart: "multipart/form-data",
  plain: "text/plain"
};
var FetchRequest = class {
  abortController = new AbortController();
  #resolveRequestPromise = (_value) => {
  };
  constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
    const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
    this.delegate = delegate;
    this.url = url;
    this.target = target;
    this.fetchOptions = {
      credentials: "same-origin",
      redirect: "follow",
      method: method.toUpperCase(),
      headers: { ...this.defaultHeaders },
      body,
      signal: this.abortSignal,
      referrer: this.delegate.referrer?.href
    };
    this.enctype = enctype;
  }
  get method() {
    return this.fetchOptions.method;
  }
  set method(value) {
    const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
    const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;
    this.url.search = "";
    const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
    this.url = url;
    this.fetchOptions.body = body;
    this.fetchOptions.method = fetchMethod.toUpperCase();
  }
  get headers() {
    return this.fetchOptions.headers;
  }
  set headers(value) {
    this.fetchOptions.headers = value;
  }
  get body() {
    if (this.isSafe) {
      return this.url.searchParams;
    } else {
      return this.fetchOptions.body;
    }
  }
  set body(value) {
    this.fetchOptions.body = value;
  }
  get location() {
    return this.url;
  }
  get params() {
    return this.url.searchParams;
  }
  get entries() {
    return this.body ? Array.from(this.body.entries()) : [];
  }
  cancel() {
    this.abortController.abort();
  }
  async perform() {
    const { fetchOptions } = this;
    this.delegate.prepareRequest(this);
    const event = await this.#allowRequestToBeIntercepted(fetchOptions);
    try {
      this.delegate.requestStarted(this);
      if (event.detail.fetchRequest) {
        this.response = event.detail.fetchRequest.response;
      } else {
        this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
      }
      const response = await this.response;
      return await this.receive(response);
    } catch (error2) {
      if (error2.name !== "AbortError") {
        if (this.#willDelegateErrorHandling(error2)) {
          this.delegate.requestErrored(this, error2);
        }
        throw error2;
      }
    } finally {
      this.delegate.requestFinished(this);
    }
  }
  async receive(response) {
    const fetchResponse = new FetchResponse(response);
    const event = dispatch("turbo:before-fetch-response", {
      cancelable: true,
      detail: { fetchResponse },
      target: this.target
    });
    if (event.defaultPrevented) {
      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
    } else if (fetchResponse.succeeded) {
      this.delegate.requestSucceededWithResponse(this, fetchResponse);
    } else {
      this.delegate.requestFailedWithResponse(this, fetchResponse);
    }
    return fetchResponse;
  }
  get defaultHeaders() {
    return {
      Accept: "text/html, application/xhtml+xml"
    };
  }
  get isSafe() {
    return isSafe(this.method);
  }
  get abortSignal() {
    return this.abortController.signal;
  }
  acceptResponseType(mimeType) {
    this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
  }
  async #allowRequestToBeIntercepted(fetchOptions) {
    const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
    const event = dispatch("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: this.#resolveRequestPromise
      },
      target: this.target
    });
    this.url = event.detail.url;
    if (event.defaultPrevented) await requestInterception;
    return event;
  }
  #willDelegateErrorHandling(error2) {
    const event = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: { request: this, error: error2 }
    });
    return !event.defaultPrevented;
  }
};
function isSafe(fetchMethod) {
  return fetchMethodFromString(fetchMethod) == FetchMethod.get;
}
function buildResourceAndBody(resource, method, requestBody, enctype) {
  const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
  if (isSafe(method)) {
    return [mergeIntoURLSearchParams(resource, searchParams), null];
  } else if (enctype == FetchEnctype.urlEncoded) {
    return [resource, searchParams];
  } else {
    return [resource, requestBody];
  }
}
function entriesExcludingFiles(requestBody) {
  const entries = [];
  for (const [name, value] of requestBody) {
    if (value instanceof File) continue;
    else entries.push([name, value]);
  }
  return entries;
}
function mergeIntoURLSearchParams(url, requestBody) {
  const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
  url.search = searchParams.toString();
  return url;
}
var AppearanceObserver = class {
  started = false;
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
    this.intersectionObserver = new IntersectionObserver(this.intersect);
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.intersectionObserver.observe(this.element);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.intersectionObserver.unobserve(this.element);
    }
  }
  intersect = (entries) => {
    const lastEntry = entries.slice(-1)[0];
    if (lastEntry?.isIntersecting) {
      this.delegate.elementAppearedInViewport(this.element);
    }
  };
};
var StreamMessage = class {
  static contentType = "text/vnd.turbo-stream.html";
  static wrap(message) {
    if (typeof message == "string") {
      return new this(createDocumentFragment(message));
    } else {
      return message;
    }
  }
  constructor(fragment) {
    this.fragment = importStreamElements(fragment);
  }
};
function importStreamElements(fragment) {
  for (const element of fragment.querySelectorAll("turbo-stream")) {
    const streamElement = document.importNode(element, true);
    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
    }
    element.replaceWith(streamElement);
  }
  return fragment;
}
var PREFETCH_DELAY = 100;
var PrefetchCache = class {
  #prefetchTimeout = null;
  #prefetched = null;
  get(url) {
    if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
      return this.#prefetched.request;
    }
  }
  setLater(url, request, ttl) {
    this.clear();
    this.#prefetchTimeout = setTimeout(() => {
      request.perform();
      this.set(url, request, ttl);
      this.#prefetchTimeout = null;
    }, PREFETCH_DELAY);
  }
  set(url, request, ttl) {
    this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
  }
  clear() {
    if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
    this.#prefetched = null;
  }
};
var cacheTtl = 10 * 1e3;
var prefetchCache = new PrefetchCache();
var FormSubmissionState = {
  initialized: "initialized",
  requesting: "requesting",
  waiting: "waiting",
  receiving: "receiving",
  stopping: "stopping",
  stopped: "stopped"
};
var FormSubmission = class _FormSubmission {
  state = FormSubmissionState.initialized;
  static confirmMethod(message) {
    return Promise.resolve(confirm(message));
  }
  constructor(delegate, formElement, submitter2, mustRedirect = false) {
    const method = getMethod(formElement, submitter2);
    const action = getAction(getFormAction(formElement, submitter2), method);
    const body = buildFormData(formElement, submitter2);
    const enctype = getEnctype(formElement, submitter2);
    this.delegate = delegate;
    this.formElement = formElement;
    this.submitter = submitter2;
    this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
    this.mustRedirect = mustRedirect;
  }
  get method() {
    return this.fetchRequest.method;
  }
  set method(value) {
    this.fetchRequest.method = value;
  }
  get action() {
    return this.fetchRequest.url.toString();
  }
  set action(value) {
    this.fetchRequest.url = expandURL(value);
  }
  get body() {
    return this.fetchRequest.body;
  }
  get enctype() {
    return this.fetchRequest.enctype;
  }
  get isSafe() {
    return this.fetchRequest.isSafe;
  }
  get location() {
    return this.fetchRequest.url;
  }
  // The submission process
  async start() {
    const { initialized, requesting } = FormSubmissionState;
    const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
    if (typeof confirmationMessage === "string") {
      const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : _FormSubmission.confirmMethod;
      const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
      if (!answer) {
        return;
      }
    }
    if (this.state == initialized) {
      this.state = requesting;
      return this.fetchRequest.perform();
    }
  }
  stop() {
    const { stopping, stopped } = FormSubmissionState;
    if (this.state != stopping && this.state != stopped) {
      this.state = stopping;
      this.fetchRequest.cancel();
      return true;
    }
  }
  // Fetch request delegate
  prepareRequest(request) {
    if (!request.isSafe) {
      const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
      if (token) {
        request.headers["X-CSRF-Token"] = token;
      }
    }
    if (this.requestAcceptsTurboStreamResponse(request)) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    this.state = FormSubmissionState.waiting;
    if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);
    this.setSubmitsWith();
    markAsBusy(this.formElement);
    dispatch("turbo:submit-start", {
      target: this.formElement,
      detail: { formSubmission: this }
    });
    this.delegate.formSubmissionStarted(this);
  }
  requestPreventedHandlingResponse(request, response) {
    prefetchCache.clear();
    this.result = { success: response.succeeded, fetchResponse: response };
  }
  requestSucceededWithResponse(request, response) {
    if (response.clientError || response.serverError) {
      this.delegate.formSubmissionFailedWithResponse(this, response);
      return;
    }
    prefetchCache.clear();
    if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
      const error2 = new Error("Form responses must redirect to another location");
      this.delegate.formSubmissionErrored(this, error2);
    } else {
      this.state = FormSubmissionState.receiving;
      this.result = { success: true, fetchResponse: response };
      this.delegate.formSubmissionSucceededWithResponse(this, response);
    }
  }
  requestFailedWithResponse(request, response) {
    this.result = { success: false, fetchResponse: response };
    this.delegate.formSubmissionFailedWithResponse(this, response);
  }
  requestErrored(request, error2) {
    this.result = { success: false, error: error2 };
    this.delegate.formSubmissionErrored(this, error2);
  }
  requestFinished(_request) {
    this.state = FormSubmissionState.stopped;
    if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);
    this.resetSubmitterText();
    clearBusyState(this.formElement);
    dispatch("turbo:submit-end", {
      target: this.formElement,
      detail: { formSubmission: this, ...this.result }
    });
    this.delegate.formSubmissionFinished(this);
  }
  // Private
  setSubmitsWith() {
    if (!this.submitter || !this.submitsWith) return;
    if (this.submitter.matches("button")) {
      this.originalSubmitText = this.submitter.innerHTML;
      this.submitter.innerHTML = this.submitsWith;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      this.originalSubmitText = input.value;
      input.value = this.submitsWith;
    }
  }
  resetSubmitterText() {
    if (!this.submitter || !this.originalSubmitText) return;
    if (this.submitter.matches("button")) {
      this.submitter.innerHTML = this.originalSubmitText;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      input.value = this.originalSubmitText;
    }
  }
  requestMustRedirect(request) {
    return !request.isSafe && this.mustRedirect;
  }
  requestAcceptsTurboStreamResponse(request) {
    return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
  }
  get submitsWith() {
    return this.submitter?.getAttribute("data-turbo-submits-with");
  }
};
function buildFormData(formElement, submitter2) {
  const formData = new FormData(formElement);
  const name = submitter2?.getAttribute("name");
  const value = submitter2?.getAttribute("value");
  if (name) {
    formData.append(name, value || "");
  }
  return formData;
}
function getCookieValue(cookieName) {
  if (cookieName != null) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      return value ? decodeURIComponent(value) : void 0;
    }
  }
}
function responseSucceededWithoutRedirect(response) {
  return response.statusCode == 200 && !response.redirected;
}
function getFormAction(formElement, submitter2) {
  const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
  if (submitter2?.hasAttribute("formaction")) {
    return submitter2.getAttribute("formaction") || "";
  } else {
    return formElement.getAttribute("action") || formElementAction || "";
  }
}
function getAction(formAction, fetchMethod) {
  const action = expandURL(formAction);
  if (isSafe(fetchMethod)) {
    action.search = "";
  }
  return action;
}
function getMethod(formElement, submitter2) {
  const method = submitter2?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
}
function getEnctype(formElement, submitter2) {
  return fetchEnctypeFromString(submitter2?.getAttribute("formenctype") || formElement.enctype);
}
var Snapshot = class {
  constructor(element) {
    this.element = element;
  }
  get activeElement() {
    return this.element.ownerDocument.activeElement;
  }
  get children() {
    return [...this.element.children];
  }
  hasAnchor(anchor) {
    return this.getElementForAnchor(anchor) != null;
  }
  getElementForAnchor(anchor) {
    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
  }
  get isConnected() {
    return this.element.isConnected;
  }
  get firstAutofocusableElement() {
    return queryAutofocusableElement(this.element);
  }
  get permanentElements() {
    return queryPermanentElementsAll(this.element);
  }
  getPermanentElementById(id) {
    return getPermanentElementById(this.element, id);
  }
  getPermanentElementMapForSnapshot(snapshot) {
    const permanentElementMap = {};
    for (const currentPermanentElement of this.permanentElements) {
      const { id } = currentPermanentElement;
      const newPermanentElement = snapshot.getPermanentElementById(id);
      if (newPermanentElement) {
        permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
      }
    }
    return permanentElementMap;
  }
};
function getPermanentElementById(node, id) {
  return node.querySelector(`#${id}[data-turbo-permanent]`);
}
function queryPermanentElementsAll(node) {
  return node.querySelectorAll("[id][data-turbo-permanent]");
}
var FormSubmitObserver = class {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("submit", this.submitCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
      this.started = false;
    }
  }
  submitCaptured = () => {
    this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
    this.eventTarget.addEventListener("submit", this.submitBubbled, false);
  };
  submitBubbled = (event) => {
    if (!event.defaultPrevented) {
      const form = event.target instanceof HTMLFormElement ? event.target : void 0;
      const submitter2 = event.submitter || void 0;
      if (form && submissionDoesNotDismissDialog(form, submitter2) && submissionDoesNotTargetIFrame(form, submitter2) && this.delegate.willSubmitForm(form, submitter2)) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this.delegate.formSubmitted(form, submitter2);
      }
    }
  };
};
function submissionDoesNotDismissDialog(form, submitter2) {
  const method = submitter2?.getAttribute("formmethod") || form.getAttribute("method");
  return method != "dialog";
}
function submissionDoesNotTargetIFrame(form, submitter2) {
  const target = submitter2?.getAttribute("formtarget") || form.getAttribute("target");
  return doesNotTargetIFrame(target);
}
var View = class {
  #resolveRenderPromise = (_value) => {
  };
  #resolveInterceptionPromise = (_value) => {
  };
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }
  // Scrolling
  scrollToAnchor(anchor) {
    const element = this.snapshot.getElementForAnchor(anchor);
    if (element) {
      this.scrollToElement(element);
      this.focusElement(element);
    } else {
      this.scrollToPosition({ x: 0, y: 0 });
    }
  }
  scrollToAnchorFromLocation(location2) {
    this.scrollToAnchor(getAnchor(location2));
  }
  scrollToElement(element) {
    element.scrollIntoView();
  }
  focusElement(element) {
    if (element instanceof HTMLElement) {
      if (element.hasAttribute("tabindex")) {
        element.focus();
      } else {
        element.setAttribute("tabindex", "-1");
        element.focus();
        element.removeAttribute("tabindex");
      }
    }
  }
  scrollToPosition({ x, y }) {
    this.scrollRoot.scrollTo(x, y);
  }
  scrollToTop() {
    this.scrollToPosition({ x: 0, y: 0 });
  }
  get scrollRoot() {
    return window;
  }
  // Rendering
  async render(renderer) {
    const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
    const shouldInvalidate = willRender;
    if (shouldRender) {
      try {
        this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
        this.renderer = renderer;
        await this.prepareToRenderSnapshot(renderer);
        const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
        const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
        if (!immediateRender) await renderInterception;
        await this.renderSnapshot(renderer);
        this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
        this.delegate.preloadOnLoadLinksForView(this.element);
        this.finishRenderingSnapshot(renderer);
      } finally {
        delete this.renderer;
        this.#resolveRenderPromise(void 0);
        delete this.renderPromise;
      }
    } else if (shouldInvalidate) {
      this.invalidate(renderer.reloadReason);
    }
  }
  invalidate(reason) {
    this.delegate.viewInvalidated(reason);
  }
  async prepareToRenderSnapshot(renderer) {
    this.markAsPreview(renderer.isPreview);
    await renderer.prepareToRender();
  }
  markAsPreview(isPreview) {
    if (isPreview) {
      this.element.setAttribute("data-turbo-preview", "");
    } else {
      this.element.removeAttribute("data-turbo-preview");
    }
  }
  markVisitDirection(direction) {
    this.element.setAttribute("data-turbo-visit-direction", direction);
  }
  unmarkVisitDirection() {
    this.element.removeAttribute("data-turbo-visit-direction");
  }
  async renderSnapshot(renderer) {
    await renderer.render();
  }
  finishRenderingSnapshot(renderer) {
    renderer.finishRendering();
  }
};
var FrameView = class extends View {
  missing() {
    this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
  }
  get snapshot() {
    return new Snapshot(this.element);
  }
};
var LinkInterceptor = class {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }
  start() {
    this.element.addEventListener("click", this.clickBubbled);
    document.addEventListener("turbo:click", this.linkClicked);
    document.addEventListener("turbo:before-visit", this.willVisit);
  }
  stop() {
    this.element.removeEventListener("click", this.clickBubbled);
    document.removeEventListener("turbo:click", this.linkClicked);
    document.removeEventListener("turbo:before-visit", this.willVisit);
  }
  clickBubbled = (event) => {
    if (this.clickEventIsSignificant(event)) {
      this.clickEvent = event;
    } else {
      delete this.clickEvent;
    }
  };
  linkClicked = (event) => {
    if (this.clickEvent && this.clickEventIsSignificant(event)) {
      if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
        this.clickEvent.preventDefault();
        event.preventDefault();
        this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
      }
    }
    delete this.clickEvent;
  };
  willVisit = (_event) => {
    delete this.clickEvent;
  };
  clickEventIsSignificant(event) {
    const target = event.composed ? event.target?.parentElement : event.target;
    const element = findLinkFromClickTarget(target) || target;
    return element instanceof Element && element.closest("turbo-frame, html") == this.element;
  }
};
var LinkClickObserver = class {
  started = false;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("click", this.clickCaptured, true);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("click", this.clickCaptured, true);
      this.started = false;
    }
  }
  clickCaptured = () => {
    this.eventTarget.removeEventListener("click", this.clickBubbled, false);
    this.eventTarget.addEventListener("click", this.clickBubbled, false);
  };
  clickBubbled = (event) => {
    if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
      const target = event.composedPath && event.composedPath()[0] || event.target;
      const link = findLinkFromClickTarget(target);
      if (link && doesNotTargetIFrame(link.target)) {
        const location2 = getLocationForLink(link);
        if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
          event.preventDefault();
          this.delegate.followedLinkToLocation(link, location2);
        }
      }
    }
  };
  clickEventIsSignificant(event) {
    return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
  }
};
var FormLinkClickObserver = class {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.linkInterceptor = new LinkClickObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
  }
  stop() {
    this.linkInterceptor.stop();
  }
  // Link hover observer delegate
  canPrefetchRequestToLocation(link, location2) {
    return false;
  }
  prefetchAndCacheRequestToLocation(link, location2) {
    return;
  }
  // Link click observer delegate
  willFollowLinkToLocation(link, location2, originalEvent) {
    return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"));
  }
  followedLinkToLocation(link, location2) {
    const form = document.createElement("form");
    const type = "hidden";
    for (const [name, value] of location2.searchParams) {
      form.append(Object.assign(document.createElement("input"), { type, name, value }));
    }
    const action = Object.assign(location2, { search: "" });
    form.setAttribute("data-turbo", "true");
    form.setAttribute("action", action.href);
    form.setAttribute("hidden", "");
    const method = link.getAttribute("data-turbo-method");
    if (method) form.setAttribute("method", method);
    const turboFrame = link.getAttribute("data-turbo-frame");
    if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
    const turboAction = getVisitAction(link);
    if (turboAction) form.setAttribute("data-turbo-action", turboAction);
    const turboConfirm = link.getAttribute("data-turbo-confirm");
    if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
    const turboStream = link.hasAttribute("data-turbo-stream");
    if (turboStream) form.setAttribute("data-turbo-stream", "");
    this.delegate.submittedFormLinkToLocation(link, location2, form);
    document.body.appendChild(form);
    form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
    requestAnimationFrame(() => form.requestSubmit());
  }
};
var Bardo = class {
  static async preservingPermanentElements(delegate, permanentElementMap, callback) {
    const bardo = new this(delegate, permanentElementMap);
    bardo.enter();
    await callback();
    bardo.leave();
  }
  constructor(delegate, permanentElementMap) {
    this.delegate = delegate;
    this.permanentElementMap = permanentElementMap;
  }
  enter() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
    }
  }
  leave() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement] = this.permanentElementMap[id];
      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
      this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      this.delegate.leavingBardo(currentPermanentElement);
    }
  }
  replaceNewPermanentElementWithPlaceholder(permanentElement) {
    const placeholder = createPlaceholderForPermanentElement(permanentElement);
    permanentElement.replaceWith(placeholder);
  }
  replaceCurrentPermanentElementWithClone(permanentElement) {
    const clone = permanentElement.cloneNode(true);
    permanentElement.replaceWith(clone);
  }
  replacePlaceholderWithPermanentElement(permanentElement) {
    const placeholder = this.getPlaceholderById(permanentElement.id);
    placeholder?.replaceWith(permanentElement);
  }
  getPlaceholderById(id) {
    return this.placeholders.find((element) => element.content == id);
  }
  get placeholders() {
    return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
  }
};
function createPlaceholderForPermanentElement(permanentElement) {
  const element = document.createElement("meta");
  element.setAttribute("name", "turbo-permanent-placeholder");
  element.setAttribute("content", permanentElement.id);
  return element;
}
var Renderer = class {
  #activeElement = null;
  static renderElement(currentElement, newElement) {
  }
  constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
    this.currentSnapshot = currentSnapshot;
    this.newSnapshot = newSnapshot;
    this.isPreview = isPreview;
    this.willRender = willRender;
    this.renderElement = this.constructor.renderElement;
    this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
  }
  get shouldRender() {
    return true;
  }
  get shouldAutofocus() {
    return true;
  }
  get reloadReason() {
    return;
  }
  prepareToRender() {
    return;
  }
  render() {
  }
  finishRendering() {
    if (this.resolvingFunctions) {
      this.resolvingFunctions.resolve();
      delete this.resolvingFunctions;
    }
  }
  async preservingPermanentElements(callback) {
    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
  }
  focusFirstAutofocusableElement() {
    if (this.shouldAutofocus) {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
  }
  // Bardo delegate
  enteringBardo(currentPermanentElement) {
    if (this.#activeElement) return;
    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
      this.#activeElement = this.currentSnapshot.activeElement;
    }
  }
  leavingBardo(currentPermanentElement) {
    if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
      this.#activeElement.focus();
      this.#activeElement = null;
    }
  }
  get connectedSnapshot() {
    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
  }
  get currentElement() {
    return this.currentSnapshot.element;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  get permanentElementMap() {
    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
  }
  get renderMethod() {
    return "replace";
  }
};
var FrameRenderer = class extends Renderer {
  static renderElement(currentElement, newElement) {
    const destinationRange = document.createRange();
    destinationRange.selectNodeContents(currentElement);
    destinationRange.deleteContents();
    const frameElement = newElement;
    const sourceRange = frameElement.ownerDocument?.createRange();
    if (sourceRange) {
      sourceRange.selectNodeContents(frameElement);
      currentElement.appendChild(sourceRange.extractContents());
    }
  }
  constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
    this.delegate = delegate;
  }
  get shouldRender() {
    return true;
  }
  async render() {
    await nextRepaint();
    this.preservingPermanentElements(() => {
      this.loadFrameElement();
    });
    this.scrollFrameIntoView();
    await nextRepaint();
    this.focusFirstAutofocusableElement();
    await nextRepaint();
    this.activateScriptElements();
  }
  loadFrameElement() {
    this.delegate.willRenderFrame(this.currentElement, this.newElement);
    this.renderElement(this.currentElement, this.newElement);
  }
  scrollFrameIntoView() {
    if (this.currentElement.autoscroll || this.newElement.autoscroll) {
      const element = this.currentElement.firstElementChild;
      const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
      const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
      if (element) {
        element.scrollIntoView({ block, behavior });
        return true;
      }
    }
    return false;
  }
  activateScriptElements() {
    for (const inertScriptElement of this.newScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  get newScriptElements() {
    return this.currentElement.querySelectorAll("script");
  }
};
function readScrollLogicalPosition(value, defaultValue) {
  if (value == "end" || value == "start" || value == "center" || value == "nearest") {
    return value;
  } else {
    return defaultValue;
  }
}
function readScrollBehavior(value, defaultValue) {
  if (value == "auto" || value == "smooth") {
    return value;
  } else {
    return defaultValue;
  }
}
var Idiomorph = /* @__PURE__ */ function() {
  let EMPTY_SET = /* @__PURE__ */ new Set();
  let defaults = {
    morphStyle: "outerHTML",
    callbacks: {
      beforeNodeAdded: noOp,
      afterNodeAdded: noOp,
      beforeNodeMorphed: noOp,
      afterNodeMorphed: noOp,
      beforeNodeRemoved: noOp,
      afterNodeRemoved: noOp,
      beforeAttributeUpdated: noOp
    },
    head: {
      style: "merge",
      shouldPreserve: function(elt) {
        return elt.getAttribute("im-preserve") === "true";
      },
      shouldReAppend: function(elt) {
        return elt.getAttribute("im-re-append") === "true";
      },
      shouldRemove: noOp,
      afterHeadMorphed: noOp
    }
  };
  function morph(oldNode, newContent, config2 = {}) {
    if (oldNode instanceof Document) {
      oldNode = oldNode.documentElement;
    }
    if (typeof newContent === "string") {
      newContent = parseContent(newContent);
    }
    let normalizedContent = normalizeContent(newContent);
    let ctx = createMorphContext(oldNode, normalizedContent, config2);
    return morphNormalizedContent(oldNode, normalizedContent, ctx);
  }
  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
    if (ctx.head.block) {
      let oldHead = oldNode.querySelector("head");
      let newHead = normalizedNewContent.querySelector("head");
      if (oldHead && newHead) {
        let promises = handleHeadElement(newHead, oldHead, ctx);
        Promise.all(promises).then(function() {
          morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {
            head: {
              block: false,
              ignore: true
            }
          }));
        });
        return;
      }
    }
    if (ctx.morphStyle === "innerHTML") {
      morphChildren2(normalizedNewContent, oldNode, ctx);
      return oldNode.children;
    } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
      let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);
      let previousSibling = bestMatch?.previousSibling;
      let nextSibling = bestMatch?.nextSibling;
      let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);
      if (bestMatch) {
        return insertSiblings(previousSibling, morphedNode, nextSibling);
      } else {
        return [];
      }
    } else {
      throw "Do not understand how to morph style " + ctx.morphStyle;
    }
  }
  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
    return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
  }
  function morphOldNodeTo(oldNode, newContent, ctx) {
    if (ctx.ignoreActive && oldNode === document.activeElement) ;
    else if (newContent == null) {
      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
      oldNode.remove();
      ctx.callbacks.afterNodeRemoved(oldNode);
      return null;
    } else if (!isSoftMatch(oldNode, newContent)) {
      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
      oldNode.parentElement.replaceChild(newContent, oldNode);
      ctx.callbacks.afterNodeAdded(newContent);
      ctx.callbacks.afterNodeRemoved(oldNode);
      return newContent;
    } else {
      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;
      else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== "morph") {
        handleHeadElement(newContent, oldNode, ctx);
      } else {
        syncNodeFrom(newContent, oldNode, ctx);
        if (!ignoreValueOfActiveElement(oldNode, ctx)) {
          morphChildren2(newContent, oldNode, ctx);
        }
      }
      ctx.callbacks.afterNodeMorphed(oldNode, newContent);
      return oldNode;
    }
  }
  function morphChildren2(newParent, oldParent, ctx) {
    let nextNewChild = newParent.firstChild;
    let insertionPoint = oldParent.firstChild;
    let newChild;
    while (nextNewChild) {
      newChild = nextNewChild;
      nextNewChild = newChild.nextSibling;
      if (insertionPoint == null) {
        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.appendChild(newChild);
        ctx.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      if (isIdSetMatch(newChild, insertionPoint, ctx)) {
        morphOldNodeTo(insertionPoint, newChild, ctx);
        insertionPoint = insertionPoint.nextSibling;
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);
      if (idSetMatch) {
        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);
        morphOldNodeTo(idSetMatch, newChild, ctx);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);
      if (softMatch) {
        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);
        morphOldNodeTo(softMatch, newChild, ctx);
        removeIdsFromConsideration(ctx, newChild);
        continue;
      }
      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
      oldParent.insertBefore(newChild, insertionPoint);
      ctx.callbacks.afterNodeAdded(newChild);
      removeIdsFromConsideration(ctx, newChild);
    }
    while (insertionPoint !== null) {
      let tempNode = insertionPoint;
      insertionPoint = insertionPoint.nextSibling;
      removeNode(tempNode, ctx);
    }
  }
  function ignoreAttribute(attr, to, updateType, ctx) {
    if (attr === "value" && ctx.ignoreActiveValue && to === document.activeElement) {
      return true;
    }
    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;
  }
  function syncNodeFrom(from, to, ctx) {
    let type = from.nodeType;
    if (type === 1) {
      const fromAttributes = from.attributes;
      const toAttributes = to.attributes;
      for (const fromAttribute of fromAttributes) {
        if (ignoreAttribute(fromAttribute.name, to, "update", ctx)) {
          continue;
        }
        if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
          to.setAttribute(fromAttribute.name, fromAttribute.value);
        }
      }
      for (let i = toAttributes.length - 1; 0 <= i; i--) {
        const toAttribute = toAttributes[i];
        if (ignoreAttribute(toAttribute.name, to, "remove", ctx)) {
          continue;
        }
        if (!from.hasAttribute(toAttribute.name)) {
          to.removeAttribute(toAttribute.name);
        }
      }
    }
    if (type === 8 || type === 3) {
      if (to.nodeValue !== from.nodeValue) {
        to.nodeValue = from.nodeValue;
      }
    }
    if (!ignoreValueOfActiveElement(to, ctx)) {
      syncInputValue(from, to, ctx);
    }
  }
  function syncBooleanAttribute(from, to, attributeName, ctx) {
    if (from[attributeName] !== to[attributeName]) {
      let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx);
      if (!ignoreUpdate) {
        to[attributeName] = from[attributeName];
      }
      if (from[attributeName]) {
        if (!ignoreUpdate) {
          to.setAttribute(attributeName, from[attributeName]);
        }
      } else {
        if (!ignoreAttribute(attributeName, to, "remove", ctx)) {
          to.removeAttribute(attributeName);
        }
      }
    }
  }
  function syncInputValue(from, to, ctx) {
    if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
      let fromValue = from.value;
      let toValue = to.value;
      syncBooleanAttribute(from, to, "checked", ctx);
      syncBooleanAttribute(from, to, "disabled", ctx);
      if (!from.hasAttribute("value")) {
        if (!ignoreAttribute("value", to, "remove", ctx)) {
          to.value = "";
          to.removeAttribute("value");
        }
      } else if (fromValue !== toValue) {
        if (!ignoreAttribute("value", to, "update", ctx)) {
          to.setAttribute("value", fromValue);
          to.value = fromValue;
        }
      }
    } else if (from instanceof HTMLOptionElement) {
      syncBooleanAttribute(from, to, "selected", ctx);
    } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
      let fromValue = from.value;
      let toValue = to.value;
      if (ignoreAttribute("value", to, "update", ctx)) {
        return;
      }
      if (fromValue !== toValue) {
        to.value = fromValue;
      }
      if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
        to.firstChild.nodeValue = fromValue;
      }
    }
  }
  function handleHeadElement(newHeadTag, currentHead, ctx) {
    let added = [];
    let removed = [];
    let preserved = [];
    let nodesToAppend = [];
    let headMergeStyle = ctx.head.style;
    let srcToNewHeadNodes = /* @__PURE__ */ new Map();
    for (const newHeadChild of newHeadTag.children) {
      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
    }
    for (const currentHeadElt of currentHead.children) {
      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
      if (inNewContent || isPreserved) {
        if (isReAppended) {
          removed.push(currentHeadElt);
        } else {
          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
          preserved.push(currentHeadElt);
        }
      } else {
        if (headMergeStyle === "append") {
          if (isReAppended) {
            removed.push(currentHeadElt);
            nodesToAppend.push(currentHeadElt);
          }
        } else {
          if (ctx.head.shouldRemove(currentHeadElt) !== false) {
            removed.push(currentHeadElt);
          }
        }
      }
    }
    nodesToAppend.push(...srcToNewHeadNodes.values());
    let promises = [];
    for (const newNode of nodesToAppend) {
      let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
        if (newElt.href || newElt.src) {
          let resolve = null;
          let promise = new Promise(function(_resolve) {
            resolve = _resolve;
          });
          newElt.addEventListener("load", function() {
            resolve();
          });
          promises.push(promise);
        }
        currentHead.appendChild(newElt);
        ctx.callbacks.afterNodeAdded(newElt);
        added.push(newElt);
      }
    }
    for (const removedElement of removed) {
      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
        currentHead.removeChild(removedElement);
        ctx.callbacks.afterNodeRemoved(removedElement);
      }
    }
    ctx.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
    return promises;
  }
  function noOp() {
  }
  function mergeDefaults(config2) {
    let finalConfig = {};
    Object.assign(finalConfig, defaults);
    Object.assign(finalConfig, config2);
    finalConfig.callbacks = {};
    Object.assign(finalConfig.callbacks, defaults.callbacks);
    Object.assign(finalConfig.callbacks, config2.callbacks);
    finalConfig.head = {};
    Object.assign(finalConfig.head, defaults.head);
    Object.assign(finalConfig.head, config2.head);
    return finalConfig;
  }
  function createMorphContext(oldNode, newContent, config2) {
    config2 = mergeDefaults(config2);
    return {
      target: oldNode,
      newContent,
      config: config2,
      morphStyle: config2.morphStyle,
      ignoreActive: config2.ignoreActive,
      ignoreActiveValue: config2.ignoreActiveValue,
      idMap: createIdMap(oldNode, newContent),
      deadIds: /* @__PURE__ */ new Set(),
      callbacks: config2.callbacks,
      head: config2.head
    };
  }
  function isIdSetMatch(node1, node2, ctx) {
    if (node1 == null || node2 == null) {
      return false;
    }
    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
      if (node1.id !== "" && node1.id === node2.id) {
        return true;
      } else {
        return getIdIntersectionCount(ctx, node1, node2) > 0;
      }
    }
    return false;
  }
  function isSoftMatch(node1, node2) {
    if (node1 == null || node2 == null) {
      return false;
    }
    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
  }
  function removeNodesBetween(startInclusive, endExclusive, ctx) {
    while (startInclusive !== endExclusive) {
      let tempNode = startInclusive;
      startInclusive = startInclusive.nextSibling;
      removeNode(tempNode, ctx);
    }
    removeIdsFromConsideration(ctx, endExclusive);
    return endExclusive.nextSibling;
  }
  function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
    let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);
    let potentialMatch = null;
    if (newChildPotentialIdCount > 0) {
      let potentialMatch2 = insertionPoint;
      let otherMatchCount = 0;
      while (potentialMatch2 != null) {
        if (isIdSetMatch(newChild, potentialMatch2, ctx)) {
          return potentialMatch2;
        }
        otherMatchCount += getIdIntersectionCount(ctx, potentialMatch2, newContent);
        if (otherMatchCount > newChildPotentialIdCount) {
          return null;
        }
        potentialMatch2 = potentialMatch2.nextSibling;
      }
    }
    return potentialMatch;
  }
  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {
    let potentialSoftMatch = insertionPoint;
    let nextSibling = newChild.nextSibling;
    let siblingSoftMatchCount = 0;
    while (potentialSoftMatch != null) {
      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {
        return null;
      }
      if (isSoftMatch(newChild, potentialSoftMatch)) {
        return potentialSoftMatch;
      }
      if (isSoftMatch(nextSibling, potentialSoftMatch)) {
        siblingSoftMatchCount++;
        nextSibling = nextSibling.nextSibling;
        if (siblingSoftMatchCount >= 2) {
          return null;
        }
      }
      potentialSoftMatch = potentialSoftMatch.nextSibling;
    }
    return potentialSoftMatch;
  }
  function parseContent(newContent) {
    let parser = new DOMParser();
    let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
    if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
      let content = parser.parseFromString(newContent, "text/html");
      if (contentWithSvgsRemoved.match(/<\/html>/)) {
        content.generatedByIdiomorph = true;
        return content;
      } else {
        let htmlElement = content.firstChild;
        if (htmlElement) {
          htmlElement.generatedByIdiomorph = true;
          return htmlElement;
        } else {
          return null;
        }
      }
    } else {
      let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
      let content = responseDoc.body.querySelector("template").content;
      content.generatedByIdiomorph = true;
      return content;
    }
  }
  function normalizeContent(newContent) {
    if (newContent == null) {
      const dummyParent = document.createElement("div");
      return dummyParent;
    } else if (newContent.generatedByIdiomorph) {
      return newContent;
    } else if (newContent instanceof Node) {
      const dummyParent = document.createElement("div");
      dummyParent.append(newContent);
      return dummyParent;
    } else {
      const dummyParent = document.createElement("div");
      for (const elt of [...newContent]) {
        dummyParent.append(elt);
      }
      return dummyParent;
    }
  }
  function insertSiblings(previousSibling, morphedNode, nextSibling) {
    let stack = [];
    let added = [];
    while (previousSibling != null) {
      stack.push(previousSibling);
      previousSibling = previousSibling.previousSibling;
    }
    while (stack.length > 0) {
      let node = stack.pop();
      added.push(node);
      morphedNode.parentElement.insertBefore(node, morphedNode);
    }
    added.push(morphedNode);
    while (nextSibling != null) {
      stack.push(nextSibling);
      added.push(nextSibling);
      nextSibling = nextSibling.nextSibling;
    }
    while (stack.length > 0) {
      morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
    }
    return added;
  }
  function findBestNodeMatch(newContent, oldNode, ctx) {
    let currentElement;
    currentElement = newContent.firstChild;
    let bestElement = currentElement;
    let score = 0;
    while (currentElement) {
      let newScore = scoreElement(currentElement, oldNode, ctx);
      if (newScore > score) {
        bestElement = currentElement;
        score = newScore;
      }
      currentElement = currentElement.nextSibling;
    }
    return bestElement;
  }
  function scoreElement(node1, node2, ctx) {
    if (isSoftMatch(node1, node2)) {
      return 0.5 + getIdIntersectionCount(ctx, node1, node2);
    }
    return 0;
  }
  function removeNode(tempNode, ctx) {
    removeIdsFromConsideration(ctx, tempNode);
    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;
    tempNode.remove();
    ctx.callbacks.afterNodeRemoved(tempNode);
  }
  function isIdInConsideration(ctx, id) {
    return !ctx.deadIds.has(id);
  }
  function idIsWithinNode(ctx, id, targetNode) {
    let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
    return idSet.has(id);
  }
  function removeIdsFromConsideration(ctx, node) {
    let idSet = ctx.idMap.get(node) || EMPTY_SET;
    for (const id of idSet) {
      ctx.deadIds.add(id);
    }
  }
  function getIdIntersectionCount(ctx, node1, node2) {
    let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
    let matchCount = 0;
    for (const id of sourceSet) {
      if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {
        ++matchCount;
      }
    }
    return matchCount;
  }
  function populateIdMapForNode(node, idMap) {
    let nodeParent = node.parentElement;
    let idElements = node.querySelectorAll("[id]");
    for (const elt of idElements) {
      let current = elt;
      while (current !== nodeParent && current != null) {
        let idSet = idMap.get(current);
        if (idSet == null) {
          idSet = /* @__PURE__ */ new Set();
          idMap.set(current, idSet);
        }
        idSet.add(elt.id);
        current = current.parentElement;
      }
    }
  }
  function createIdMap(oldContent, newContent) {
    let idMap = /* @__PURE__ */ new Map();
    populateIdMapForNode(oldContent, idMap);
    populateIdMapForNode(newContent, idMap);
    return idMap;
  }
  return {
    morph,
    defaults
  };
}();
function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
  Idiomorph.morph(currentElement, newElement, {
    ...options,
    callbacks: new DefaultIdiomorphCallbacks(callbacks)
  });
}
function morphChildren(currentElement, newElement) {
  morphElements(currentElement, newElement.children, {
    morphStyle: "innerHTML"
  });
}
var DefaultIdiomorphCallbacks = class {
  #beforeNodeMorphed;
  constructor({ beforeNodeMorphed } = {}) {
    this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
  }
  beforeNodeAdded = (node) => {
    return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
  };
  beforeNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
        const event = dispatch("turbo:before-morph-element", {
          cancelable: true,
          target: currentElement,
          detail: { currentElement, newElement }
        });
        return !event.defaultPrevented;
      } else {
        return false;
      }
    }
  };
  beforeAttributeUpdated = (attributeName, target, mutationType) => {
    const event = dispatch("turbo:before-morph-attribute", {
      cancelable: true,
      target,
      detail: { attributeName, mutationType }
    });
    return !event.defaultPrevented;
  };
  beforeNodeRemoved = (node) => {
    return this.beforeNodeMorphed(node);
  };
  afterNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      dispatch("turbo:morph-element", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
    }
  };
};
var MorphingFrameRenderer = class extends FrameRenderer {
  static renderElement(currentElement, newElement) {
    dispatch("turbo:before-frame-morph", {
      target: currentElement,
      detail: { currentElement, newElement }
    });
    morphChildren(currentElement, newElement);
  }
  async preservingPermanentElements(callback) {
    return await callback();
  }
};
var ProgressBar = class _ProgressBar {
  static animationDuration = 300;
  /*ms*/
  static get defaultCSS() {
    return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
  }
  hiding = false;
  value = 0;
  visible = false;
  constructor() {
    this.stylesheetElement = this.createStylesheetElement();
    this.progressElement = this.createProgressElement();
    this.installStylesheetElement();
    this.setValue(0);
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this.installProgressElement();
      this.startTrickling();
    }
  }
  hide() {
    if (this.visible && !this.hiding) {
      this.hiding = true;
      this.fadeProgressElement(() => {
        this.uninstallProgressElement();
        this.stopTrickling();
        this.visible = false;
        this.hiding = false;
      });
    }
  }
  setValue(value) {
    this.value = value;
    this.refresh();
  }
  // Private
  installStylesheetElement() {
    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
  }
  installProgressElement() {
    this.progressElement.style.width = "0";
    this.progressElement.style.opacity = "1";
    document.documentElement.insertBefore(this.progressElement, document.body);
    this.refresh();
  }
  fadeProgressElement(callback) {
    this.progressElement.style.opacity = "0";
    setTimeout(callback, _ProgressBar.animationDuration * 1.5);
  }
  uninstallProgressElement() {
    if (this.progressElement.parentNode) {
      document.documentElement.removeChild(this.progressElement);
    }
  }
  startTrickling() {
    if (!this.trickleInterval) {
      this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
    }
  }
  stopTrickling() {
    window.clearInterval(this.trickleInterval);
    delete this.trickleInterval;
  }
  trickle = () => {
    this.setValue(this.value + Math.random() / 100);
  };
  refresh() {
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${10 + this.value * 90}%`;
    });
  }
  createStylesheetElement() {
    const element = document.createElement("style");
    element.type = "text/css";
    element.textContent = _ProgressBar.defaultCSS;
    const cspNonce = getCspNonce();
    if (cspNonce) {
      element.nonce = cspNonce;
    }
    return element;
  }
  createProgressElement() {
    const element = document.createElement("div");
    element.className = "turbo-progress-bar";
    return element;
  }
};
var HeadSnapshot = class extends Snapshot {
  detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
    const { outerHTML } = element;
    const details = outerHTML in result ? result[outerHTML] : {
      type: elementType(element),
      tracked: elementIsTracked(element),
      elements: []
    };
    return {
      ...result,
      [outerHTML]: {
        ...details,
        elements: [...details.elements, element]
      }
    };
  }, {});
  get trackedElementSignature() {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
  }
  getScriptElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
  }
  getStylesheetElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
  }
  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
    return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
  }
  get provisionalElements() {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
      if (type == null && !tracked) {
        return [...result, ...elements];
      } else if (elements.length > 1) {
        return [...result, ...elements.slice(1)];
      } else {
        return result;
      }
    }, []);
  }
  getMetaValue(name) {
    const element = this.findMetaElementByName(name);
    return element ? element.getAttribute("content") : null;
  }
  findMetaElementByName(name) {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        elements: [element]
      } = this.detailsByOuterHTML[outerHTML];
      return elementIsMetaElementWithName(element, name) ? element : result;
    }, void 0 | void 0);
  }
};
function elementType(element) {
  if (elementIsScript(element)) {
    return "script";
  } else if (elementIsStylesheet(element)) {
    return "stylesheet";
  }
}
function elementIsTracked(element) {
  return element.getAttribute("data-turbo-track") == "reload";
}
function elementIsScript(element) {
  const tagName = element.localName;
  return tagName == "script";
}
function elementIsNoscript(element) {
  const tagName = element.localName;
  return tagName == "noscript";
}
function elementIsStylesheet(element) {
  const tagName = element.localName;
  return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
}
function elementIsMetaElementWithName(element, name) {
  const tagName = element.localName;
  return tagName == "meta" && element.getAttribute("name") == name;
}
function elementWithoutNonce(element) {
  if (element.hasAttribute("nonce")) {
    element.setAttribute("nonce", "");
  }
  return element;
}
var PageSnapshot = class _PageSnapshot extends Snapshot {
  static fromHTMLString(html = "") {
    return this.fromDocument(parseHTMLDocument(html));
  }
  static fromElement(element) {
    return this.fromDocument(element.ownerDocument);
  }
  static fromDocument({ documentElement, body, head }) {
    return new this(documentElement, body, new HeadSnapshot(head));
  }
  constructor(documentElement, body, headSnapshot) {
    super(body);
    this.documentElement = documentElement;
    this.headSnapshot = headSnapshot;
  }
  clone() {
    const clonedElement = this.element.cloneNode(true);
    const selectElements = this.element.querySelectorAll("select");
    const clonedSelectElements = clonedElement.querySelectorAll("select");
    for (const [index, source] of selectElements.entries()) {
      const clone = clonedSelectElements[index];
      for (const option of clone.selectedOptions) option.selected = false;
      for (const option of source.selectedOptions) clone.options[option.index].selected = true;
    }
    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
      clonedPasswordInput.value = "";
    }
    return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
  }
  get lang() {
    return this.documentElement.getAttribute("lang");
  }
  get headElement() {
    return this.headSnapshot.element;
  }
  get rootLocation() {
    const root = this.getSetting("root") ?? "/";
    return expandURL(root);
  }
  get cacheControlValue() {
    return this.getSetting("cache-control");
  }
  get isPreviewable() {
    return this.cacheControlValue != "no-preview";
  }
  get isCacheable() {
    return this.cacheControlValue != "no-cache";
  }
  get isVisitable() {
    return this.getSetting("visit-control") != "reload";
  }
  get prefersViewTransitions() {
    return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
  }
  get shouldMorphPage() {
    return this.getSetting("refresh-method") === "morph";
  }
  get shouldPreserveScrollPosition() {
    return this.getSetting("refresh-scroll") === "preserve";
  }
  // Private
  getSetting(name) {
    return this.headSnapshot.getMetaValue(`turbo-${name}`);
  }
};
var ViewTransitioner = class {
  #viewTransitionStarted = false;
  #lastOperation = Promise.resolve();
  renderChange(useViewTransition, render) {
    if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
      this.#viewTransitionStarted = true;
      this.#lastOperation = this.#lastOperation.then(async () => {
        await document.startViewTransition(render).finished;
      });
    } else {
      this.#lastOperation = this.#lastOperation.then(render);
    }
    return this.#lastOperation;
  }
  get viewTransitionsAvailable() {
    return document.startViewTransition;
  }
};
var defaultOptions = {
  action: "advance",
  historyChanged: false,
  visitCachedSnapshot: () => {
  },
  willRender: true,
  updateHistory: true,
  shouldCacheSnapshot: true,
  acceptsStreamResponse: false
};
var TimingMetric = {
  visitStart: "visitStart",
  requestStart: "requestStart",
  requestEnd: "requestEnd",
  visitEnd: "visitEnd"
};
var VisitState = {
  initialized: "initialized",
  started: "started",
  canceled: "canceled",
  failed: "failed",
  completed: "completed"
};
var SystemStatusCode = {
  networkFailure: 0,
  timeoutFailure: -1,
  contentTypeMismatch: -2
};
var Direction = {
  advance: "forward",
  restore: "back",
  replace: "none"
};
var Visit = class {
  identifier = uuid();
  // Required by turbo-ios
  timingMetrics = {};
  followedRedirect = false;
  historyChanged = false;
  scrolled = false;
  shouldCacheSnapshot = true;
  acceptsStreamResponse = false;
  snapshotCached = false;
  state = VisitState.initialized;
  viewTransitioner = new ViewTransitioner();
  constructor(delegate, location2, restorationIdentifier, options = {}) {
    this.delegate = delegate;
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier || uuid();
    const {
      action,
      historyChanged,
      referrer,
      snapshot,
      snapshotHTML,
      response,
      visitCachedSnapshot,
      willRender,
      updateHistory,
      shouldCacheSnapshot,
      acceptsStreamResponse,
      direction
    } = {
      ...defaultOptions,
      ...options
    };
    this.action = action;
    this.historyChanged = historyChanged;
    this.referrer = referrer;
    this.snapshot = snapshot;
    this.snapshotHTML = snapshotHTML;
    this.response = response;
    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
    this.isPageRefresh = this.view.isPageRefresh(this);
    this.visitCachedSnapshot = visitCachedSnapshot;
    this.willRender = willRender;
    this.updateHistory = updateHistory;
    this.scrolled = !willRender;
    this.shouldCacheSnapshot = shouldCacheSnapshot;
    this.acceptsStreamResponse = acceptsStreamResponse;
    this.direction = direction || Direction[action];
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get history() {
    return this.delegate.history;
  }
  get restorationData() {
    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
  }
  get silent() {
    return this.isSamePage;
  }
  start() {
    if (this.state == VisitState.initialized) {
      this.recordTimingMetric(TimingMetric.visitStart);
      this.state = VisitState.started;
      this.adapter.visitStarted(this);
      this.delegate.visitStarted(this);
    }
  }
  cancel() {
    if (this.state == VisitState.started) {
      if (this.request) {
        this.request.cancel();
      }
      this.cancelRender();
      this.state = VisitState.canceled;
    }
  }
  complete() {
    if (this.state == VisitState.started) {
      this.recordTimingMetric(TimingMetric.visitEnd);
      this.adapter.visitCompleted(this);
      this.state = VisitState.completed;
      this.followRedirect();
      if (!this.followedRedirect) {
        this.delegate.visitCompleted(this);
      }
    }
  }
  fail() {
    if (this.state == VisitState.started) {
      this.state = VisitState.failed;
      this.adapter.visitFailed(this);
      this.delegate.visitCompleted(this);
    }
  }
  changeHistory() {
    if (!this.historyChanged && this.updateHistory) {
      const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
      const method = getHistoryMethodForAction(actionForHistory);
      this.history.update(method, this.location, this.restorationIdentifier);
      this.historyChanged = true;
    }
  }
  issueRequest() {
    if (this.hasPreloadedResponse()) {
      this.simulateRequest();
    } else if (this.shouldIssueRequest() && !this.request) {
      this.request = new FetchRequest(this, FetchMethod.get, this.location);
      this.request.perform();
    }
  }
  simulateRequest() {
    if (this.response) {
      this.startRequest();
      this.recordResponse();
      this.finishRequest();
    }
  }
  startRequest() {
    this.recordTimingMetric(TimingMetric.requestStart);
    this.adapter.visitRequestStarted(this);
  }
  recordResponse(response = this.response) {
    this.response = response;
    if (response) {
      const { statusCode } = response;
      if (isSuccessful(statusCode)) {
        this.adapter.visitRequestCompleted(this);
      } else {
        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
      }
    }
  }
  finishRequest() {
    this.recordTimingMetric(TimingMetric.requestEnd);
    this.adapter.visitRequestFinished(this);
  }
  loadResponse() {
    if (this.response) {
      const { statusCode, responseHTML } = this.response;
      this.render(async () => {
        if (this.shouldCacheSnapshot) this.cacheSnapshot();
        if (this.view.renderPromise) await this.view.renderPromise;
        if (isSuccessful(statusCode) && responseHTML != null) {
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          await this.renderPageSnapshot(snapshot, false);
          this.adapter.visitRendered(this);
          this.complete();
        } else {
          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
          this.adapter.visitRendered(this);
          this.fail();
        }
      });
    }
  }
  getCachedSnapshot() {
    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
      if (this.action == "restore" || snapshot.isPreviewable) {
        return snapshot;
      }
    }
  }
  getPreloadedSnapshot() {
    if (this.snapshotHTML) {
      return PageSnapshot.fromHTMLString(this.snapshotHTML);
    }
  }
  hasCachedSnapshot() {
    return this.getCachedSnapshot() != null;
  }
  loadCachedSnapshot() {
    const snapshot = this.getCachedSnapshot();
    if (snapshot) {
      const isPreview = this.shouldIssueRequest();
      this.render(async () => {
        this.cacheSnapshot();
        if (this.isSamePage || this.isPageRefresh) {
          this.adapter.visitRendered(this);
        } else {
          if (this.view.renderPromise) await this.view.renderPromise;
          await this.renderPageSnapshot(snapshot, isPreview);
          this.adapter.visitRendered(this);
          if (!isPreview) {
            this.complete();
          }
        }
      });
    }
  }
  followRedirect() {
    if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
      this.adapter.visitProposedToLocation(this.redirectedToLocation, {
        action: "replace",
        response: this.response,
        shouldCacheSnapshot: false,
        willRender: false
      });
      this.followedRedirect = true;
    }
  }
  goToSamePageAnchor() {
    if (this.isSamePage) {
      this.render(async () => {
        this.cacheSnapshot();
        this.performScroll();
        this.changeHistory();
        this.adapter.visitRendered(this);
      });
    }
  }
  // Fetch request delegate
  prepareRequest(request) {
    if (this.acceptsStreamResponse) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted() {
    this.startRequest();
  }
  requestPreventedHandlingResponse(_request, _response) {
  }
  async requestSucceededWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == void 0) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.redirectedToLocation = response.redirected ? response.location : void 0;
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  async requestFailedWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == void 0) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.recordResponse({ statusCode, responseHTML, redirected });
    }
  }
  requestErrored(_request, _error) {
    this.recordResponse({
      statusCode: SystemStatusCode.networkFailure,
      redirected: false
    });
  }
  requestFinished() {
    this.finishRequest();
  }
  // Scrolling
  performScroll() {
    if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
      if (this.action == "restore") {
        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
      } else {
        this.scrollToAnchor() || this.view.scrollToTop();
      }
      if (this.isSamePage) {
        this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
      }
      this.scrolled = true;
    }
  }
  scrollToRestoredPosition() {
    const { scrollPosition } = this.restorationData;
    if (scrollPosition) {
      this.view.scrollToPosition(scrollPosition);
      return true;
    }
  }
  scrollToAnchor() {
    const anchor = getAnchor(this.location);
    if (anchor != null) {
      this.view.scrollToAnchor(anchor);
      return true;
    }
  }
  // Instrumentation
  recordTimingMetric(metric) {
    this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
  }
  getTimingMetrics() {
    return { ...this.timingMetrics };
  }
  // Private
  getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  hasPreloadedResponse() {
    return typeof this.response == "object";
  }
  shouldIssueRequest() {
    if (this.isSamePage) {
      return false;
    } else if (this.action == "restore") {
      return !this.hasCachedSnapshot();
    } else {
      return this.willRender;
    }
  }
  cacheSnapshot() {
    if (!this.snapshotCached) {
      this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
      this.snapshotCached = true;
    }
  }
  async render(callback) {
    this.cancelRender();
    await new Promise((resolve) => {
      this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
    });
    await callback();
    delete this.frame;
  }
  async renderPageSnapshot(snapshot, isPreview) {
    await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
      await this.view.renderPage(snapshot, isPreview, this.willRender, this);
      this.performScroll();
    });
  }
  cancelRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  }
};
function isSuccessful(statusCode) {
  return statusCode >= 200 && statusCode < 300;
}
var BrowserAdapter = class {
  progressBar = new ProgressBar();
  constructor(session2) {
    this.session = session2;
  }
  visitProposedToLocation(location2, options) {
    if (locationIsVisitable(location2, this.navigator.rootLocation)) {
      this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
    } else {
      window.location.href = location2.toString();
    }
  }
  visitStarted(visit2) {
    this.location = visit2.location;
    visit2.loadCachedSnapshot();
    visit2.issueRequest();
    visit2.goToSamePageAnchor();
  }
  visitRequestStarted(visit2) {
    this.progressBar.setValue(0);
    if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
      this.showVisitProgressBarAfterDelay();
    } else {
      this.showProgressBar();
    }
  }
  visitRequestCompleted(visit2) {
    visit2.loadResponse();
  }
  visitRequestFailedWithStatusCode(visit2, statusCode) {
    switch (statusCode) {
      case SystemStatusCode.networkFailure:
      case SystemStatusCode.timeoutFailure:
      case SystemStatusCode.contentTypeMismatch:
        return this.reload({
          reason: "request_failed",
          context: {
            statusCode
          }
        });
      default:
        return visit2.loadResponse();
    }
  }
  visitRequestFinished(_visit) {
  }
  visitCompleted(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  pageInvalidated(reason) {
    this.reload(reason);
  }
  visitFailed(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }
  visitRendered(_visit) {
  }
  // Form Submission Delegate
  formSubmissionStarted(_formSubmission) {
    this.progressBar.setValue(0);
    this.showFormProgressBarAfterDelay();
  }
  formSubmissionFinished(_formSubmission) {
    this.progressBar.setValue(1);
    this.hideFormProgressBar();
  }
  // Private
  showVisitProgressBarAfterDelay() {
    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }
  hideVisitProgressBar() {
    this.progressBar.hide();
    if (this.visitProgressBarTimeout != null) {
      window.clearTimeout(this.visitProgressBarTimeout);
      delete this.visitProgressBarTimeout;
    }
  }
  showFormProgressBarAfterDelay() {
    if (this.formProgressBarTimeout == null) {
      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
  }
  hideFormProgressBar() {
    this.progressBar.hide();
    if (this.formProgressBarTimeout != null) {
      window.clearTimeout(this.formProgressBarTimeout);
      delete this.formProgressBarTimeout;
    }
  }
  showProgressBar = () => {
    this.progressBar.show();
  };
  reload(reason) {
    dispatch("turbo:reload", { detail: reason });
    window.location.href = this.location?.toString() || window.location.href;
  }
  get navigator() {
    return this.session.navigator;
  }
};
var CacheObserver = class {
  selector = "[data-turbo-temporary]";
  deprecatedSelector = "[data-turbo-cache=false]";
  started = false;
  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }
  removeTemporaryElements = (_event) => {
    for (const element of this.temporaryElements) {
      element.remove();
    }
  };
  get temporaryElements() {
    return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
  }
  get temporaryElementsWithDeprecation() {
    const elements = document.querySelectorAll(this.deprecatedSelector);
    if (elements.length) {
      console.warn(
        `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
      );
    }
    return [...elements];
  }
};
var FrameRedirector = class {
  constructor(session2, element) {
    this.session = session2;
    this.element = element;
    this.linkInterceptor = new LinkInterceptor(this, element);
    this.formSubmitObserver = new FormSubmitObserver(this, element);
  }
  start() {
    this.linkInterceptor.start();
    this.formSubmitObserver.start();
  }
  stop() {
    this.linkInterceptor.stop();
    this.formSubmitObserver.stop();
  }
  // Link interceptor delegate
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldRedirect(element);
  }
  linkClickIntercepted(element, url, event) {
    const frame = this.#findFrameElement(element);
    if (frame) {
      frame.delegate.linkClickIntercepted(element, url, event);
    }
  }
  // Form submit observer delegate
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter2) && this.#shouldRedirect(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    if (frame) {
      frame.delegate.formSubmitted(element, submitter2);
    }
  }
  #shouldSubmit(form, submitter2) {
    const action = getAction$1(form, submitter2);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL(meta?.content ?? "/");
    return this.#shouldRedirect(form, submitter2) && locationIsVisitable(action, rootLocation);
  }
  #shouldRedirect(element, submitter2) {
    const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
    if (isNavigatable) {
      const frame = this.#findFrameElement(element, submitter2);
      return frame ? frame != element.closest("turbo-frame") : false;
    } else {
      return false;
    }
  }
  #findFrameElement(element, submitter2) {
    const id = submitter2?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame;
      }
    }
  }
};
var History = class {
  location;
  restorationIdentifier = uuid();
  restorationData = {};
  started = false;
  pageLoaded = false;
  currentIndex = 0;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("popstate", this.onPopState, false);
      addEventListener("load", this.onPageLoad, false);
      this.currentIndex = history.state?.turbo?.restorationIndex || 0;
      this.started = true;
      this.replace(new URL(window.location.href));
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("popstate", this.onPopState, false);
      removeEventListener("load", this.onPageLoad, false);
      this.started = false;
    }
  }
  push(location2, restorationIdentifier) {
    this.update(history.pushState, location2, restorationIdentifier);
  }
  replace(location2, restorationIdentifier) {
    this.update(history.replaceState, location2, restorationIdentifier);
  }
  update(method, location2, restorationIdentifier = uuid()) {
    if (method === history.pushState) ++this.currentIndex;
    const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
    method.call(history, state, "", location2.href);
    this.location = location2;
    this.restorationIdentifier = restorationIdentifier;
  }
  // Restoration data
  getRestorationDataForIdentifier(restorationIdentifier) {
    return this.restorationData[restorationIdentifier] || {};
  }
  updateRestorationData(additionalData) {
    const { restorationIdentifier } = this;
    const restorationData = this.restorationData[restorationIdentifier];
    this.restorationData[restorationIdentifier] = {
      ...restorationData,
      ...additionalData
    };
  }
  // Scroll restoration
  assumeControlOfScrollRestoration() {
    if (!this.previousScrollRestoration) {
      this.previousScrollRestoration = history.scrollRestoration ?? "auto";
      history.scrollRestoration = "manual";
    }
  }
  relinquishControlOfScrollRestoration() {
    if (this.previousScrollRestoration) {
      history.scrollRestoration = this.previousScrollRestoration;
      delete this.previousScrollRestoration;
    }
  }
  // Event handlers
  onPopState = (event) => {
    if (this.shouldHandlePopState()) {
      const { turbo } = event.state || {};
      if (turbo) {
        this.location = new URL(window.location.href);
        const { restorationIdentifier, restorationIndex } = turbo;
        this.restorationIdentifier = restorationIdentifier;
        const direction = restorationIndex > this.currentIndex ? "forward" : "back";
        this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
        this.currentIndex = restorationIndex;
      }
    }
  };
  onPageLoad = async (_event) => {
    await nextMicrotask();
    this.pageLoaded = true;
  };
  // Private
  shouldHandlePopState() {
    return this.pageIsLoaded();
  }
  pageIsLoaded() {
    return this.pageLoaded || document.readyState == "complete";
  }
};
var LinkPrefetchObserver = class {
  started = false;
  #prefetchedLink = null;
  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }
  start() {
    if (this.started) return;
    if (this.eventTarget.readyState === "loading") {
      this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
    } else {
      this.#enable();
    }
  }
  stop() {
    if (!this.started) return;
    this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = false;
  }
  #enable = () => {
    this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = true;
  };
  #tryToPrefetchRequest = (event) => {
    if (getMetaContent("turbo-prefetch") === "false") return;
    const target = event.target;
    const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
    if (isLink && this.#isPrefetchable(target)) {
      const link = target;
      const location2 = getLocationForLink(link);
      if (this.delegate.canPrefetchRequestToLocation(link, location2)) {
        this.#prefetchedLink = link;
        const fetchRequest = new FetchRequest(
          this,
          FetchMethod.get,
          location2,
          new URLSearchParams(),
          target
        );
        prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
      }
    }
  };
  #cancelRequestIfObsolete = (event) => {
    if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
  };
  #cancelPrefetchRequest = () => {
    prefetchCache.clear();
    this.#prefetchedLink = null;
  };
  #tryToUsePrefetchedRequest = (event) => {
    if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
      const cached = prefetchCache.get(event.detail.url.toString());
      if (cached) {
        event.detail.fetchRequest = cached;
      }
      prefetchCache.clear();
    }
  };
  prepareRequest(request) {
    const link = request.target;
    request.headers["X-Sec-Purpose"] = "prefetch";
    const turboFrame = link.closest("turbo-frame");
    const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
    if (turboFrameTarget && turboFrameTarget !== "_top") {
      request.headers["Turbo-Frame"] = turboFrameTarget;
    }
  }
  // Fetch request interface
  requestSucceededWithResponse() {
  }
  requestStarted(fetchRequest) {
  }
  requestErrored(fetchRequest) {
  }
  requestFinished(fetchRequest) {
  }
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
  }
  requestFailedWithResponse(fetchRequest, fetchResponse) {
  }
  get #cacheTtl() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
  }
  #isPrefetchable(link) {
    const href = link.getAttribute("href");
    if (!href) return false;
    if (unfetchableLink(link)) return false;
    if (linkToTheSamePage(link)) return false;
    if (linkOptsOut(link)) return false;
    if (nonSafeLink(link)) return false;
    if (eventPrevented(link)) return false;
    return true;
  }
};
var unfetchableLink = (link) => {
  return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target");
};
var linkToTheSamePage = (link) => {
  return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith("#");
};
var linkOptsOut = (link) => {
  if (link.getAttribute("data-turbo-prefetch") === "false") return true;
  if (link.getAttribute("data-turbo") === "false") return true;
  const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
  if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
  return false;
};
var nonSafeLink = (link) => {
  const turboMethod = link.getAttribute("data-turbo-method");
  if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
  if (isUJS(link)) return true;
  if (link.hasAttribute("data-turbo-confirm")) return true;
  if (link.hasAttribute("data-turbo-stream")) return true;
  return false;
};
var isUJS = (link) => {
  return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method");
};
var eventPrevented = (link) => {
  const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
  return event.defaultPrevented;
};
var Navigator = class {
  constructor(delegate) {
    this.delegate = delegate;
  }
  proposeVisit(location2, options = {}) {
    if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
      this.delegate.visitProposedToLocation(location2, options);
    }
  }
  startVisit(locatable, restorationIdentifier, options = {}) {
    this.stop();
    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
      referrer: this.location,
      ...options
    });
    this.currentVisit.start();
  }
  submitForm(form, submitter2) {
    this.stop();
    this.formSubmission = new FormSubmission(this, form, submitter2, true);
    this.formSubmission.start();
  }
  stop() {
    if (this.formSubmission) {
      this.formSubmission.stop();
      delete this.formSubmission;
    }
    if (this.currentVisit) {
      this.currentVisit.cancel();
      delete this.currentVisit;
    }
  }
  get adapter() {
    return this.delegate.adapter;
  }
  get view() {
    return this.delegate.view;
  }
  get rootLocation() {
    return this.view.snapshot.rootLocation;
  }
  get history() {
    return this.delegate.history;
  }
  // Form submission delegate
  formSubmissionStarted(formSubmission) {
    if (typeof this.adapter.formSubmissionStarted === "function") {
      this.adapter.formSubmissionStarted(formSubmission);
    }
  }
  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
    if (formSubmission == this.formSubmission) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const shouldCacheSnapshot = formSubmission.isSafe;
        if (!shouldCacheSnapshot) {
          this.view.clearSnapshotCache();
        }
        const { statusCode, redirected } = fetchResponse;
        const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
        const visitOptions = {
          action,
          shouldCacheSnapshot,
          response: { statusCode, responseHTML, redirected }
        };
        this.proposeVisit(fetchResponse.location, visitOptions);
      }
    }
  }
  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    const responseHTML = await fetchResponse.responseHTML;
    if (responseHTML) {
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      if (fetchResponse.serverError) {
        await this.view.renderError(snapshot, this.currentVisit);
      } else {
        await this.view.renderPage(snapshot, false, true, this.currentVisit);
      }
      if (!snapshot.shouldPreserveScrollPosition) {
        this.view.scrollToTop();
      }
      this.view.clearSnapshotCache();
    }
  }
  formSubmissionErrored(formSubmission, error2) {
    console.error(error2);
  }
  formSubmissionFinished(formSubmission) {
    if (typeof this.adapter.formSubmissionFinished === "function") {
      this.adapter.formSubmissionFinished(formSubmission);
    }
  }
  // Visit delegate
  visitStarted(visit2) {
    this.delegate.visitStarted(visit2);
  }
  visitCompleted(visit2) {
    this.delegate.visitCompleted(visit2);
    delete this.currentVisit;
  }
  locationWithActionIsSamePage(location2, action) {
    const anchor = getAnchor(location2);
    const currentAnchor = getAnchor(this.view.lastRenderedLocation);
    const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
    return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
  }
  // Visits
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  #getActionForFormSubmission(formSubmission, fetchResponse) {
    const { submitter: submitter2, formElement } = formSubmission;
    return getVisitAction(submitter2, formElement) || this.#getDefaultAction(fetchResponse);
  }
  #getDefaultAction(fetchResponse) {
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
    return sameLocationRedirect ? "replace" : "advance";
  }
};
var PageStage = {
  initial: 0,
  loading: 1,
  interactive: 2,
  complete: 3
};
var PageObserver = class {
  stage = PageStage.initial;
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      if (this.stage == PageStage.initial) {
        this.stage = PageStage.loading;
      }
      document.addEventListener("readystatechange", this.interpretReadyState, false);
      addEventListener("pagehide", this.pageWillUnload, false);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      document.removeEventListener("readystatechange", this.interpretReadyState, false);
      removeEventListener("pagehide", this.pageWillUnload, false);
      this.started = false;
    }
  }
  interpretReadyState = () => {
    const { readyState } = this;
    if (readyState == "interactive") {
      this.pageIsInteractive();
    } else if (readyState == "complete") {
      this.pageIsComplete();
    }
  };
  pageIsInteractive() {
    if (this.stage == PageStage.loading) {
      this.stage = PageStage.interactive;
      this.delegate.pageBecameInteractive();
    }
  }
  pageIsComplete() {
    this.pageIsInteractive();
    if (this.stage == PageStage.interactive) {
      this.stage = PageStage.complete;
      this.delegate.pageLoaded();
    }
  }
  pageWillUnload = () => {
    this.delegate.pageWillUnload();
  };
  get readyState() {
    return document.readyState;
  }
};
var ScrollObserver = class {
  started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.started) {
      addEventListener("scroll", this.onScroll, false);
      this.onScroll();
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      removeEventListener("scroll", this.onScroll, false);
      this.started = false;
    }
  }
  onScroll = () => {
    this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
  };
  // Private
  updatePosition(position) {
    this.delegate.scrollPositionChanged(position);
  }
};
var StreamMessageRenderer = class {
  render({ fragment }) {
    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
      withAutofocusFromFragment(fragment, () => {
        withPreservedFocus(() => {
          document.documentElement.appendChild(fragment);
        });
      });
    });
  }
  // Bardo delegate
  enteringBardo(currentPermanentElement, newPermanentElement) {
    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
  }
  leavingBardo() {
  }
};
function getPermanentElementMapForFragment(fragment) {
  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
  const permanentElementMap = {};
  for (const permanentElementInDocument of permanentElementsInDocument) {
    const { id } = permanentElementInDocument;
    for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
      if (elementInStream) {
        permanentElementMap[id] = [permanentElementInDocument, elementInStream];
      }
    }
  }
  return permanentElementMap;
}
async function withAutofocusFromFragment(fragment, callback) {
  const generatedID = `turbo-stream-autofocus-${uuid()}`;
  const turboStreams = fragment.querySelectorAll("turbo-stream");
  const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
  let willAutofocusId = null;
  if (elementWithAutofocus) {
    if (elementWithAutofocus.id) {
      willAutofocusId = elementWithAutofocus.id;
    } else {
      willAutofocusId = generatedID;
    }
    elementWithAutofocus.id = willAutofocusId;
  }
  callback();
  await nextRepaint();
  const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
  if (hasNoActiveElement && willAutofocusId) {
    const elementToAutofocus = document.getElementById(willAutofocusId);
    if (elementIsFocusable(elementToAutofocus)) {
      elementToAutofocus.focus();
    }
    if (elementToAutofocus && elementToAutofocus.id == generatedID) {
      elementToAutofocus.removeAttribute("id");
    }
  }
}
async function withPreservedFocus(callback) {
  const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
  const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
  if (restoreFocusTo) {
    const elementToFocus = document.getElementById(restoreFocusTo);
    if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
      elementToFocus.focus();
    }
  }
}
function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
  for (const streamElement of nodeListOfStreamElements) {
    const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
    if (elementWithAutofocus) return elementWithAutofocus;
  }
  return null;
}
var StreamObserver = class {
  sources = /* @__PURE__ */ new Set();
  #started = false;
  constructor(delegate) {
    this.delegate = delegate;
  }
  start() {
    if (!this.#started) {
      this.#started = true;
      addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  stop() {
    if (this.#started) {
      this.#started = false;
      removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }
  connectStreamSource(source) {
    if (!this.streamSourceIsConnected(source)) {
      this.sources.add(source);
      source.addEventListener("message", this.receiveMessageEvent, false);
    }
  }
  disconnectStreamSource(source) {
    if (this.streamSourceIsConnected(source)) {
      this.sources.delete(source);
      source.removeEventListener("message", this.receiveMessageEvent, false);
    }
  }
  streamSourceIsConnected(source) {
    return this.sources.has(source);
  }
  inspectFetchResponse = (event) => {
    const response = fetchResponseFromEvent(event);
    if (response && fetchResponseIsStream(response)) {
      event.preventDefault();
      this.receiveMessageResponse(response);
    }
  };
  receiveMessageEvent = (event) => {
    if (this.#started && typeof event.data == "string") {
      this.receiveMessageHTML(event.data);
    }
  };
  async receiveMessageResponse(response) {
    const html = await response.responseHTML;
    if (html) {
      this.receiveMessageHTML(html);
    }
  }
  receiveMessageHTML(html) {
    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
  }
};
function fetchResponseFromEvent(event) {
  const fetchResponse = event.detail?.fetchResponse;
  if (fetchResponse instanceof FetchResponse) {
    return fetchResponse;
  }
}
function fetchResponseIsStream(response) {
  const contentType = response.contentType ?? "";
  return contentType.startsWith(StreamMessage.contentType);
}
var ErrorRenderer = class extends Renderer {
  static renderElement(currentElement, newElement) {
    const { documentElement, body } = document;
    documentElement.replaceChild(newElement, body);
  }
  async render() {
    this.replaceHeadAndBody();
    this.activateScriptElements();
  }
  replaceHeadAndBody() {
    const { documentElement, head } = document;
    documentElement.replaceChild(this.newHead, head);
    this.renderElement(this.currentElement, this.newElement);
  }
  activateScriptElements() {
    for (const replaceableElement of this.scriptElements) {
      const parentNode = replaceableElement.parentNode;
      if (parentNode) {
        const element = activateScriptElement(replaceableElement);
        parentNode.replaceChild(element, replaceableElement);
      }
    }
  }
  get newHead() {
    return this.newSnapshot.headSnapshot.element;
  }
  get scriptElements() {
    return document.documentElement.querySelectorAll("script");
  }
};
var PageRenderer = class extends Renderer {
  static renderElement(currentElement, newElement) {
    if (document.body && newElement instanceof HTMLBodyElement) {
      document.body.replaceWith(newElement);
    } else {
      document.documentElement.appendChild(newElement);
    }
  }
  get shouldRender() {
    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
  }
  get reloadReason() {
    if (!this.newSnapshot.isVisitable) {
      return {
        reason: "turbo_visit_control_is_reload"
      };
    }
    if (!this.trackedElementsAreIdentical) {
      return {
        reason: "tracked_element_mismatch"
      };
    }
  }
  async prepareToRender() {
    this.#setLanguage();
    await this.mergeHead();
  }
  async render() {
    if (this.willRender) {
      await this.replaceBody();
    }
  }
  finishRendering() {
    super.finishRendering();
    if (!this.isPreview) {
      this.focusFirstAutofocusableElement();
    }
  }
  get currentHeadSnapshot() {
    return this.currentSnapshot.headSnapshot;
  }
  get newHeadSnapshot() {
    return this.newSnapshot.headSnapshot;
  }
  get newElement() {
    return this.newSnapshot.element;
  }
  #setLanguage() {
    const { documentElement } = this.currentSnapshot;
    const { lang } = this.newSnapshot;
    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  }
  async mergeHead() {
    const mergedHeadElements = this.mergeProvisionalElements();
    const newStylesheetElements = this.copyNewHeadStylesheetElements();
    this.copyNewHeadScriptElements();
    await mergedHeadElements;
    await newStylesheetElements;
    if (this.willRender) {
      this.removeUnusedDynamicStylesheetElements();
    }
  }
  async replaceBody() {
    await this.preservingPermanentElements(async () => {
      this.activateNewBody();
      await this.assignNewBody();
    });
  }
  get trackedElementsAreIdentical() {
    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
  }
  async copyNewHeadStylesheetElements() {
    const loadingElements = [];
    for (const element of this.newHeadStylesheetElements) {
      loadingElements.push(waitForLoad(element));
      document.head.appendChild(element);
    }
    await Promise.all(loadingElements);
  }
  copyNewHeadScriptElements() {
    for (const element of this.newHeadScriptElements) {
      document.head.appendChild(activateScriptElement(element));
    }
  }
  removeUnusedDynamicStylesheetElements() {
    for (const element of this.unusedDynamicStylesheetElements) {
      document.head.removeChild(element);
    }
  }
  async mergeProvisionalElements() {
    const newHeadElements = [...this.newHeadProvisionalElements];
    for (const element of this.currentHeadProvisionalElements) {
      if (!this.isCurrentElementInElementList(element, newHeadElements)) {
        document.head.removeChild(element);
      }
    }
    for (const element of newHeadElements) {
      document.head.appendChild(element);
    }
  }
  isCurrentElementInElementList(element, elementList) {
    for (const [index, newElement] of elementList.entries()) {
      if (element.tagName == "TITLE") {
        if (newElement.tagName != "TITLE") {
          continue;
        }
        if (element.innerHTML == newElement.innerHTML) {
          elementList.splice(index, 1);
          return true;
        }
      }
      if (newElement.isEqualNode(element)) {
        elementList.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  removeCurrentHeadProvisionalElements() {
    for (const element of this.currentHeadProvisionalElements) {
      document.head.removeChild(element);
    }
  }
  copyNewHeadProvisionalElements() {
    for (const element of this.newHeadProvisionalElements) {
      document.head.appendChild(element);
    }
  }
  activateNewBody() {
    document.adoptNode(this.newElement);
    this.activateNewBodyScriptElements();
  }
  activateNewBodyScriptElements() {
    for (const inertScriptElement of this.newBodyScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }
  async assignNewBody() {
    await this.renderElement(this.currentElement, this.newElement);
  }
  get unusedDynamicStylesheetElements() {
    return this.oldHeadStylesheetElements.filter((element) => {
      return element.getAttribute("data-turbo-track") === "dynamic";
    });
  }
  get oldHeadStylesheetElements() {
    return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
  }
  get newHeadStylesheetElements() {
    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get newHeadScriptElements() {
    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
  }
  get currentHeadProvisionalElements() {
    return this.currentHeadSnapshot.provisionalElements;
  }
  get newHeadProvisionalElements() {
    return this.newHeadSnapshot.provisionalElements;
  }
  get newBodyScriptElements() {
    return this.newElement.querySelectorAll("script");
  }
};
var MorphingPageRenderer = class extends PageRenderer {
  static renderElement(currentElement, newElement) {
    morphElements(currentElement, newElement, {
      callbacks: {
        beforeNodeMorphed: (element) => !canRefreshFrame(element)
      }
    });
    for (const frame of currentElement.querySelectorAll("turbo-frame")) {
      if (canRefreshFrame(frame)) frame.reload();
    }
    dispatch("turbo:morph", { detail: { currentElement, newElement } });
  }
  async preservingPermanentElements(callback) {
    return await callback();
  }
  get renderMethod() {
    return "morph";
  }
  get shouldAutofocus() {
    return false;
  }
};
function canRefreshFrame(frame) {
  return frame instanceof FrameElement && frame.src && frame.refresh === "morph" && !frame.closest("[data-turbo-permanent]");
}
var SnapshotCache = class {
  keys = [];
  snapshots = {};
  constructor(size) {
    this.size = size;
  }
  has(location2) {
    return toCacheKey(location2) in this.snapshots;
  }
  get(location2) {
    if (this.has(location2)) {
      const snapshot = this.read(location2);
      this.touch(location2);
      return snapshot;
    }
  }
  put(location2, snapshot) {
    this.write(location2, snapshot);
    this.touch(location2);
    return snapshot;
  }
  clear() {
    this.snapshots = {};
  }
  // Private
  read(location2) {
    return this.snapshots[toCacheKey(location2)];
  }
  write(location2, snapshot) {
    this.snapshots[toCacheKey(location2)] = snapshot;
  }
  touch(location2) {
    const key = toCacheKey(location2);
    const index = this.keys.indexOf(key);
    if (index > -1) this.keys.splice(index, 1);
    this.keys.unshift(key);
    this.trim();
  }
  trim() {
    for (const key of this.keys.splice(this.size)) {
      delete this.snapshots[key];
    }
  }
};
var PageView = class extends View {
  snapshotCache = new SnapshotCache(10);
  lastRenderedLocation = new URL(location.href);
  forceReloaded = false;
  shouldTransitionTo(newSnapshot) {
    return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
  }
  renderPage(snapshot, isPreview = false, willRender = true, visit2) {
    const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
    const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
    const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
    if (!renderer.shouldRender) {
      this.forceReloaded = true;
    } else {
      visit2?.changeHistory();
    }
    return this.render(renderer);
  }
  renderError(snapshot, visit2) {
    visit2?.changeHistory();
    const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
    return this.render(renderer);
  }
  clearSnapshotCache() {
    this.snapshotCache.clear();
  }
  async cacheSnapshot(snapshot = this.snapshot) {
    if (snapshot.isCacheable) {
      this.delegate.viewWillCacheSnapshot();
      const { lastRenderedLocation: location2 } = this;
      await nextEventLoopTick();
      const cachedSnapshot = snapshot.clone();
      this.snapshotCache.put(location2, cachedSnapshot);
      return cachedSnapshot;
    }
  }
  getCachedSnapshotForLocation(location2) {
    return this.snapshotCache.get(location2);
  }
  isPageRefresh(visit2) {
    return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
  }
  shouldPreserveScrollPosition(visit2) {
    return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
  }
  get snapshot() {
    return PageSnapshot.fromElement(this.element);
  }
};
var Preloader = class {
  selector = "a[data-turbo-preload]";
  constructor(delegate, snapshotCache) {
    this.delegate = delegate;
    this.snapshotCache = snapshotCache;
  }
  start() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", this.#preloadAll);
    } else {
      this.preloadOnLoadLinksForView(document.body);
    }
  }
  stop() {
    document.removeEventListener("DOMContentLoaded", this.#preloadAll);
  }
  preloadOnLoadLinksForView(element) {
    for (const link of element.querySelectorAll(this.selector)) {
      if (this.delegate.shouldPreloadLink(link)) {
        this.preloadURL(link);
      }
    }
  }
  async preloadURL(link) {
    const location2 = new URL(link.href);
    if (this.snapshotCache.has(location2)) {
      return;
    }
    const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link);
    await fetchRequest.perform();
  }
  // Fetch request delegate
  prepareRequest(fetchRequest) {
    fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
  }
  async requestSucceededWithResponse(fetchRequest, fetchResponse) {
    try {
      const responseHTML = await fetchResponse.responseHTML;
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      this.snapshotCache.put(fetchRequest.url, snapshot);
    } catch (_) {
    }
  }
  requestStarted(fetchRequest) {
  }
  requestErrored(fetchRequest) {
  }
  requestFinished(fetchRequest) {
  }
  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
  }
  requestFailedWithResponse(fetchRequest, fetchResponse) {
  }
  #preloadAll = () => {
    this.preloadOnLoadLinksForView(document.body);
  };
};
var Cache = class {
  constructor(session2) {
    this.session = session2;
  }
  clear() {
    this.session.clearCache();
  }
  resetCacheControl() {
    this.#setCacheControl("");
  }
  exemptPageFromCache() {
    this.#setCacheControl("no-cache");
  }
  exemptPageFromPreview() {
    this.#setCacheControl("no-preview");
  }
  #setCacheControl(value) {
    setMetaContent("turbo-cache-control", value);
  }
};
var Session = class {
  navigator = new Navigator(this);
  history = new History(this);
  view = new PageView(this, document.documentElement);
  adapter = new BrowserAdapter(this);
  pageObserver = new PageObserver(this);
  cacheObserver = new CacheObserver();
  linkPrefetchObserver = new LinkPrefetchObserver(this, document);
  linkClickObserver = new LinkClickObserver(this, window);
  formSubmitObserver = new FormSubmitObserver(this, document);
  scrollObserver = new ScrollObserver(this);
  streamObserver = new StreamObserver(this);
  formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
  frameRedirector = new FrameRedirector(this, document.documentElement);
  streamMessageRenderer = new StreamMessageRenderer();
  cache = new Cache(this);
  enabled = true;
  started = false;
  #pageRefreshDebouncePeriod = 150;
  constructor(recentRequests2) {
    this.recentRequests = recentRequests2;
    this.preloader = new Preloader(this, this.view.snapshotCache);
    this.debouncedRefresh = this.refresh;
    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
  }
  start() {
    if (!this.started) {
      this.pageObserver.start();
      this.cacheObserver.start();
      this.linkPrefetchObserver.start();
      this.formLinkClickObserver.start();
      this.linkClickObserver.start();
      this.formSubmitObserver.start();
      this.scrollObserver.start();
      this.streamObserver.start();
      this.frameRedirector.start();
      this.history.start();
      this.preloader.start();
      this.started = true;
      this.enabled = true;
    }
  }
  disable() {
    this.enabled = false;
  }
  stop() {
    if (this.started) {
      this.pageObserver.stop();
      this.cacheObserver.stop();
      this.linkPrefetchObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkClickObserver.stop();
      this.formSubmitObserver.stop();
      this.scrollObserver.stop();
      this.streamObserver.stop();
      this.frameRedirector.stop();
      this.history.stop();
      this.preloader.stop();
      this.started = false;
    }
  }
  registerAdapter(adapter) {
    this.adapter = adapter;
  }
  visit(location2, options = {}) {
    const frameElement = options.frame ? document.getElementById(options.frame) : null;
    if (frameElement instanceof FrameElement) {
      const action = options.action || getVisitAction(frameElement);
      frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
      frameElement.src = location2.toString();
    } else {
      this.navigator.proposeVisit(expandURL(location2), options);
    }
  }
  refresh(url, requestId) {
    const isRecentRequest = requestId && this.recentRequests.has(requestId);
    if (!isRecentRequest && !this.navigator.currentVisit) {
      this.visit(url, { action: "replace", shouldCacheSnapshot: false });
    }
  }
  connectStreamSource(source) {
    this.streamObserver.connectStreamSource(source);
  }
  disconnectStreamSource(source) {
    this.streamObserver.disconnectStreamSource(source);
  }
  renderStreamMessage(message) {
    this.streamMessageRenderer.render(StreamMessage.wrap(message));
  }
  clearCache() {
    this.view.clearSnapshotCache();
  }
  setProgressBarDelay(delay) {
    console.warn(
      "Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"
    );
    this.progressBarDelay = delay;
  }
  set progressBarDelay(delay) {
    config.drive.progressBarDelay = delay;
  }
  get progressBarDelay() {
    return config.drive.progressBarDelay;
  }
  set drive(value) {
    config.drive.enabled = value;
  }
  get drive() {
    return config.drive.enabled;
  }
  set formMode(value) {
    config.forms.mode = value;
  }
  get formMode() {
    return config.forms.mode;
  }
  get location() {
    return this.history.location;
  }
  get restorationIdentifier() {
    return this.history.restorationIdentifier;
  }
  get pageRefreshDebouncePeriod() {
    return this.#pageRefreshDebouncePeriod;
  }
  set pageRefreshDebouncePeriod(value) {
    this.refresh = debounce(this.debouncedRefresh.bind(this), value);
    this.#pageRefreshDebouncePeriod = value;
  }
  // Preloader delegate
  shouldPreloadLink(element) {
    const isUnsafe = element.hasAttribute("data-turbo-method");
    const isStream = element.hasAttribute("data-turbo-stream");
    const frameTarget = element.getAttribute("data-turbo-frame");
    const frame = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
    if (isUnsafe || isStream || frame instanceof FrameElement) {
      return false;
    } else {
      const location2 = new URL(element.href);
      return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
  }
  // History delegate
  historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction) {
    if (this.enabled) {
      this.navigator.startVisit(location2, restorationIdentifier, {
        action: "restore",
        historyChanged: true,
        direction
      });
    } else {
      this.adapter.pageInvalidated({
        reason: "turbo_disabled"
      });
    }
  }
  // Scroll observer delegate
  scrollPositionChanged(position) {
    this.history.updateRestorationData({ scrollPosition: position });
  }
  // Form click observer delegate
  willSubmitFormLinkToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
  }
  submittedFormLinkToLocation() {
  }
  // Link hover observer delegate
  canPrefetchRequestToLocation(link, location2) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
  }
  // Link click observer delegate
  willFollowLinkToLocation(link, location2, event) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
  }
  followedLinkToLocation(link, location2) {
    const action = this.getActionForLink(link);
    const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
    this.visit(location2.href, { action, acceptsStreamResponse });
  }
  // Navigator delegate
  allowsVisitingLocationWithAction(location2, action) {
    return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
  }
  visitProposedToLocation(location2, options) {
    extendURLWithDeprecatedProperties(location2);
    this.adapter.visitProposedToLocation(location2, options);
  }
  // Visit delegate
  visitStarted(visit2) {
    if (!visit2.acceptsStreamResponse) {
      markAsBusy(document.documentElement);
      this.view.markVisitDirection(visit2.direction);
    }
    extendURLWithDeprecatedProperties(visit2.location);
    if (!visit2.silent) {
      this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
    }
  }
  visitCompleted(visit2) {
    this.view.unmarkVisitDirection();
    clearBusyState(document.documentElement);
    this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
  }
  locationWithActionIsSamePage(location2, action) {
    return this.navigator.locationWithActionIsSamePage(location2, action);
  }
  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
  }
  // Form submit observer delegate
  willSubmitForm(form, submitter2) {
    const action = getAction$1(form, submitter2);
    return this.submissionIsNavigatable(form, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
  }
  formSubmitted(form, submitter2) {
    this.navigator.submitForm(form, submitter2);
  }
  // Page observer delegate
  pageBecameInteractive() {
    this.view.lastRenderedLocation = this.location;
    this.notifyApplicationAfterPageLoad();
  }
  pageLoaded() {
    this.history.assumeControlOfScrollRestoration();
  }
  pageWillUnload() {
    this.history.relinquishControlOfScrollRestoration();
  }
  // Stream observer delegate
  receivedMessageFromStream(message) {
    this.renderStreamMessage(message);
  }
  // Page view delegate
  viewWillCacheSnapshot() {
    if (!this.navigator.currentVisit?.silent) {
      this.notifyApplicationBeforeCachingSnapshot();
    }
  }
  allowsImmediateRender({ element }, options) {
    const event = this.notifyApplicationBeforeRender(element, options);
    const {
      defaultPrevented,
      detail: { render }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
    this.view.lastRenderedLocation = this.history.location;
    this.notifyApplicationAfterRender(renderMethod);
  }
  preloadOnLoadLinksForView(element) {
    this.preloader.preloadOnLoadLinksForView(element);
  }
  viewInvalidated(reason) {
    this.adapter.pageInvalidated(reason);
  }
  // Frame element
  frameLoaded(frame) {
    this.notifyApplicationAfterFrameLoad(frame);
  }
  frameRendered(fetchResponse, frame) {
    this.notifyApplicationAfterFrameRender(fetchResponse, frame);
  }
  // Application events
  applicationAllowsFollowingLinkToLocation(link, location2, ev) {
    const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
    return !event.defaultPrevented;
  }
  applicationAllowsVisitingLocation(location2) {
    const event = this.notifyApplicationBeforeVisitingLocation(location2);
    return !event.defaultPrevented;
  }
  notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
    return dispatch("turbo:click", {
      target: link,
      detail: { url: location2.href, originalEvent: event },
      cancelable: true
    });
  }
  notifyApplicationBeforeVisitingLocation(location2) {
    return dispatch("turbo:before-visit", {
      detail: { url: location2.href },
      cancelable: true
    });
  }
  notifyApplicationAfterVisitingLocation(location2, action) {
    return dispatch("turbo:visit", { detail: { url: location2.href, action } });
  }
  notifyApplicationBeforeCachingSnapshot() {
    return dispatch("turbo:before-cache");
  }
  notifyApplicationBeforeRender(newBody, options) {
    return dispatch("turbo:before-render", {
      detail: { newBody, ...options },
      cancelable: true
    });
  }
  notifyApplicationAfterRender(renderMethod) {
    return dispatch("turbo:render", { detail: { renderMethod } });
  }
  notifyApplicationAfterPageLoad(timing = {}) {
    return dispatch("turbo:load", {
      detail: { url: this.location.href, timing }
    });
  }
  notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
    dispatchEvent(
      new HashChangeEvent("hashchange", {
        oldURL: oldURL.toString(),
        newURL: newURL.toString()
      })
    );
  }
  notifyApplicationAfterFrameLoad(frame) {
    return dispatch("turbo:frame-load", { target: frame });
  }
  notifyApplicationAfterFrameRender(fetchResponse, frame) {
    return dispatch("turbo:frame-render", {
      detail: { fetchResponse },
      target: frame,
      cancelable: true
    });
  }
  // Helpers
  submissionIsNavigatable(form, submitter2) {
    if (config.forms.mode == "off") {
      return false;
    } else {
      const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
      if (config.forms.mode == "optin") {
        return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
      } else {
        return submitterIsNavigatable && this.elementIsNavigatable(form);
      }
    }
  }
  elementIsNavigatable(element) {
    const container = findClosestRecursively(element, "[data-turbo]");
    const withinFrame = findClosestRecursively(element, "turbo-frame");
    if (config.drive.enabled || withinFrame) {
      if (container) {
        return container.getAttribute("data-turbo") != "false";
      } else {
        return true;
      }
    } else {
      if (container) {
        return container.getAttribute("data-turbo") == "true";
      } else {
        return false;
      }
    }
  }
  // Private
  getActionForLink(link) {
    return getVisitAction(link) || "advance";
  }
  get snapshot() {
    return this.view.snapshot;
  }
};
function extendURLWithDeprecatedProperties(url) {
  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
}
var deprecatedLocationPropertyDescriptors = {
  absoluteURL: {
    get() {
      return this.toString();
    }
  }
};
var session = new Session(recentRequests);
var { cache, navigator: navigator$1 } = session;
function start() {
  session.start();
}
function registerAdapter(adapter) {
  session.registerAdapter(adapter);
}
function visit(location2, options) {
  session.visit(location2, options);
}
function connectStreamSource(source) {
  session.connectStreamSource(source);
}
function disconnectStreamSource(source) {
  session.disconnectStreamSource(source);
}
function renderStreamMessage(message) {
  session.renderStreamMessage(message);
}
function clearCache() {
  console.warn(
    "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  session.clearCache();
}
function setProgressBarDelay(delay) {
  console.warn(
    "Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.drive.progressBarDelay = delay;
}
function setConfirmMethod(confirmMethod) {
  console.warn(
    "Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.forms.confirm = confirmMethod;
}
function setFormMode(mode) {
  console.warn(
    "Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.forms.mode = mode;
}
var Turbo = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  navigator: navigator$1,
  session,
  cache,
  PageRenderer,
  PageSnapshot,
  FrameRenderer,
  fetch: fetchWithTurboHeaders,
  config,
  start,
  registerAdapter,
  visit,
  connectStreamSource,
  disconnectStreamSource,
  renderStreamMessage,
  clearCache,
  setProgressBarDelay,
  setConfirmMethod,
  setFormMode
});
var TurboFrameMissingError = class extends Error {
};
var FrameController = class {
  fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
  #currentFetchRequest = null;
  #resolveVisitPromise = () => {
  };
  #connected = false;
  #hasBeenLoaded = false;
  #ignoredAttributes = /* @__PURE__ */ new Set();
  #shouldMorphFrame = false;
  action = null;
  constructor(element) {
    this.element = element;
    this.view = new FrameView(this, this.element);
    this.appearanceObserver = new AppearanceObserver(this, this.element);
    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
    this.linkInterceptor = new LinkInterceptor(this, this.element);
    this.restorationIdentifier = uuid();
    this.formSubmitObserver = new FormSubmitObserver(this, this.element);
  }
  // Frame delegate
  connect() {
    if (!this.#connected) {
      this.#connected = true;
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.#loadSourceURL();
      }
      this.formLinkClickObserver.start();
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
  }
  disconnect() {
    if (this.#connected) {
      this.#connected = false;
      this.appearanceObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
  }
  disabledChanged() {
    if (this.loadingStyle == FrameLoadingStyle.eager) {
      this.#loadSourceURL();
    }
  }
  sourceURLChanged() {
    if (this.#isIgnoringChangesTo("src")) return;
    if (this.element.isConnected) {
      this.complete = false;
    }
    if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
      this.#loadSourceURL();
    }
  }
  sourceURLReloaded() {
    const { refresh, src } = this.element;
    this.#shouldMorphFrame = src && refresh === "morph";
    this.element.removeAttribute("complete");
    this.element.src = null;
    this.element.src = src;
    return this.element.loaded;
  }
  loadingStyleChanged() {
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.appearanceObserver.stop();
      this.#loadSourceURL();
    }
  }
  async #loadSourceURL() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = this.#visit(expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      this.#hasBeenLoaded = true;
    }
  }
  async loadResponse(fetchResponse) {
    if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
      this.sourceURL = fetchResponse.response.url;
    }
    try {
      const html = await fetchResponse.responseHTML;
      if (html) {
        const document2 = parseHTMLDocument(html);
        const pageSnapshot = PageSnapshot.fromDocument(document2);
        if (pageSnapshot.isVisitable) {
          await this.#loadFrameResponse(fetchResponse, document2);
        } else {
          await this.#handleUnvisitableFrameResponse(fetchResponse);
        }
      }
    } finally {
      this.#shouldMorphFrame = false;
      this.fetchResponseLoaded = () => Promise.resolve();
    }
  }
  // Appearance observer delegate
  elementAppearedInViewport(element) {
    this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
    this.#loadSourceURL();
  }
  // Form link click observer delegate
  willSubmitFormLinkToLocation(link) {
    return this.#shouldInterceptNavigation(link);
  }
  submittedFormLinkToLocation(link, _location, form) {
    const frame = this.#findFrameElement(link);
    if (frame) form.setAttribute("data-turbo-frame", frame.id);
  }
  // Link interceptor delegate
  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldInterceptNavigation(element);
  }
  linkClickIntercepted(element, location2) {
    this.#navigateFrame(element, location2);
  }
  // Form submit observer delegate
  willSubmitForm(element, submitter2) {
    return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter2);
  }
  formSubmitted(element, submitter2) {
    if (this.formSubmission) {
      this.formSubmission.stop();
    }
    this.formSubmission = new FormSubmission(this, element, submitter2);
    const { fetchRequest } = this.formSubmission;
    this.prepareRequest(fetchRequest);
    this.formSubmission.start();
  }
  // Fetch request delegate
  prepareRequest(request) {
    request.headers["Turbo-Frame"] = this.id;
    if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }
  requestStarted(_request) {
    markAsBusy(this.element);
  }
  requestPreventedHandlingResponse(_request, _response) {
    this.#resolveVisitPromise();
  }
  async requestSucceededWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  async requestFailedWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }
  requestErrored(request, error2) {
    console.error(error2);
    this.#resolveVisitPromise();
  }
  requestFinished(_request) {
    clearBusyState(this.element);
  }
  // Form submission delegate
  formSubmissionStarted({ formElement }) {
    markAsBusy(formElement, this.#findFrameElement(formElement));
  }
  formSubmissionSucceededWithResponse(formSubmission, response) {
    const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
    frame.delegate.loadResponse(response);
    if (!formSubmission.isSafe) {
      session.clearCache();
    }
  }
  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    this.element.delegate.loadResponse(fetchResponse);
    session.clearCache();
  }
  formSubmissionErrored(formSubmission, error2) {
    console.error(error2);
  }
  formSubmissionFinished({ formElement }) {
    clearBusyState(formElement, this.#findFrameElement(formElement));
  }
  // View delegate
  allowsImmediateRender({ element: newFrame }, options) {
    const event = dispatch("turbo:before-frame-render", {
      target: this.element,
      detail: { newFrame, ...options },
      cancelable: true
    });
    const {
      defaultPrevented,
      detail: { render }
    } = event;
    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }
    return !defaultPrevented;
  }
  viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
  }
  preloadOnLoadLinksForView(element) {
    session.preloadOnLoadLinksForView(element);
  }
  viewInvalidated() {
  }
  // Frame renderer delegate
  willRenderFrame(currentElement, _newElement) {
    this.previousFrameElement = currentElement.cloneNode(true);
  }
  visitCachedSnapshot = ({ element }) => {
    const frame = element.querySelector("#" + this.element.id);
    if (frame && this.previousFrameElement) {
      frame.replaceChildren(...this.previousFrameElement.children);
    }
    delete this.previousFrameElement;
  };
  // Private
  async #loadFrameResponse(fetchResponse, document2) {
    const newFrameElement = await this.extractForeignFrameElement(document2.body);
    const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;
    if (newFrameElement) {
      const snapshot = new Snapshot(newFrameElement);
      const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
      if (this.view.renderPromise) await this.view.renderPromise;
      this.changeHistory();
      await this.view.render(renderer);
      this.complete = true;
      session.frameRendered(fetchResponse, this.element);
      session.frameLoaded(this.element);
      await this.fetchResponseLoaded(fetchResponse);
    } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
      this.#handleFrameMissingFromResponse(fetchResponse);
    }
  }
  async #visit(url) {
    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
    this.#currentFetchRequest?.cancel();
    this.#currentFetchRequest = request;
    return new Promise((resolve) => {
      this.#resolveVisitPromise = () => {
        this.#resolveVisitPromise = () => {
        };
        this.#currentFetchRequest = null;
        resolve();
      };
      request.perform();
    });
  }
  #navigateFrame(element, url, submitter2) {
    const frame = this.#findFrameElement(element, submitter2);
    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter2, element, frame));
    this.#withCurrentNavigationElement(element, () => {
      frame.src = url;
    });
  }
  proposeVisitIfNavigatedWithAction(frame, action = null) {
    this.action = action;
    if (this.action) {
      const pageSnapshot = PageSnapshot.fromElement(frame).clone();
      const { visitCachedSnapshot } = frame.delegate;
      frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
        if (frame.src) {
          const { statusCode, redirected } = fetchResponse;
          const responseHTML = await fetchResponse.responseHTML;
          const response = { statusCode, redirected, responseHTML };
          const options = {
            response,
            visitCachedSnapshot,
            willRender: false,
            updateHistory: false,
            restorationIdentifier: this.restorationIdentifier,
            snapshot: pageSnapshot
          };
          if (this.action) options.action = this.action;
          session.visit(frame.src, options);
        }
      };
    }
  }
  changeHistory() {
    if (this.action) {
      const method = getHistoryMethodForAction(this.action);
      session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
    }
  }
  async #handleUnvisitableFrameResponse(fetchResponse) {
    console.warn(
      `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
    );
    await this.#visitResponse(fetchResponse.response);
  }
  #willHandleFrameMissingFromResponse(fetchResponse) {
    this.element.setAttribute("complete", "");
    const response = fetchResponse.response;
    const visit2 = async (url, options) => {
      if (url instanceof Response) {
        this.#visitResponse(url);
      } else {
        session.visit(url, options);
      }
    };
    const event = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: { response, visit: visit2 },
      cancelable: true
    });
    return !event.defaultPrevented;
  }
  #handleFrameMissingFromResponse(fetchResponse) {
    this.view.missing();
    this.#throwFrameMissingError(fetchResponse);
  }
  #throwFrameMissingError(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message);
  }
  async #visitResponse(response) {
    const wrapped = new FetchResponse(response);
    const responseHTML = await wrapped.responseHTML;
    const { location: location2, redirected, statusCode } = wrapped;
    return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
  }
  #findFrameElement(element, submitter2) {
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    return getFrameElementById(id) ?? this.element;
  }
  async extractForeignFrameElement(container) {
    let element;
    const id = CSS.escape(this.id);
    try {
      element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
      if (element) {
        return element;
      }
      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
      if (element) {
        await element.loaded;
        return await this.extractForeignFrameElement(element);
      }
    } catch (error2) {
      console.error(error2);
      return new FrameElement();
    }
    return null;
  }
  #formActionIsVisitable(form, submitter2) {
    const action = getAction$1(form, submitter2);
    return locationIsVisitable(expandURL(action), this.rootLocation);
  }
  #shouldInterceptNavigation(element, submitter2) {
    const id = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
    if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter2)) {
      return false;
    }
    if (!this.enabled || id == "_top") {
      return false;
    }
    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled;
      }
    }
    if (!session.elementIsNavigatable(element)) {
      return false;
    }
    if (submitter2 && !session.elementIsNavigatable(submitter2)) {
      return false;
    }
    return true;
  }
  // Computed properties
  get id() {
    return this.element.id;
  }
  get enabled() {
    return !this.element.disabled;
  }
  get sourceURL() {
    if (this.element.src) {
      return this.element.src;
    }
  }
  set sourceURL(sourceURL) {
    this.#ignoringChangesToAttribute("src", () => {
      this.element.src = sourceURL ?? null;
    });
  }
  get loadingStyle() {
    return this.element.loading;
  }
  get isLoading() {
    return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
  }
  get complete() {
    return this.element.hasAttribute("complete");
  }
  set complete(value) {
    if (value) {
      this.element.setAttribute("complete", "");
    } else {
      this.element.removeAttribute("complete");
    }
  }
  get isActive() {
    return this.element.isActive && this.#connected;
  }
  get rootLocation() {
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const root = meta?.content ?? "/";
    return expandURL(root);
  }
  #isIgnoringChangesTo(attributeName) {
    return this.#ignoredAttributes.has(attributeName);
  }
  #ignoringChangesToAttribute(attributeName, callback) {
    this.#ignoredAttributes.add(attributeName);
    callback();
    this.#ignoredAttributes.delete(attributeName);
  }
  #withCurrentNavigationElement(element, callback) {
    this.currentNavigationElement = element;
    callback();
    delete this.currentNavigationElement;
  }
};
function getFrameElementById(id) {
  if (id != null) {
    const element = document.getElementById(id);
    if (element instanceof FrameElement) {
      return element;
    }
  }
}
function activateElement(element, currentURL) {
  if (element) {
    const src = element.getAttribute("src");
    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
      throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
    }
    if (element.ownerDocument !== document) {
      element = document.importNode(element, true);
    }
    if (element instanceof FrameElement) {
      element.connectedCallback();
      element.disconnectedCallback();
      return element;
    }
  }
}
var StreamActions = {
  after() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e.nextSibling));
  },
  append() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.append(this.templateContent));
  },
  before() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e));
  },
  prepend() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.prepend(this.templateContent));
  },
  remove() {
    this.targetElements.forEach((e) => e.remove());
  },
  replace() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphElements(targetElement, this.templateContent);
      } else {
        targetElement.replaceWith(this.templateContent);
      }
    });
  },
  update() {
    const method = this.getAttribute("method");
    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphChildren(targetElement, this.templateContent);
      } else {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      }
    });
  },
  refresh() {
    session.refresh(this.baseURI, this.requestId);
  }
};
var StreamElement = class _StreamElement extends HTMLElement {
  static async renderElement(newElement) {
    await newElement.performAction();
  }
  async connectedCallback() {
    try {
      await this.render();
    } catch (error2) {
      console.error(error2);
    } finally {
      this.disconnect();
    }
  }
  async render() {
    return this.renderPromise ??= (async () => {
      const event = this.beforeRenderEvent;
      if (this.dispatchEvent(event)) {
        await nextRepaint();
        await event.detail.render(this);
      }
    })();
  }
  disconnect() {
    try {
      this.remove();
    } catch {
    }
  }
  /**
   * Removes duplicate children (by ID)
   */
  removeDuplicateTargetChildren() {
    this.duplicateChildren.forEach((c) => c.remove());
  }
  /**
   * Gets the list of duplicate children (i.e. those with the same ID)
   */
  get duplicateChildren() {
    const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.id);
    const newChildrenIds = [...this.templateContent?.children || []].filter((c) => !!c.id).map((c) => c.id);
    return existingChildren.filter((c) => newChildrenIds.includes(c.id));
  }
  /**
   * Gets the action function to be performed.
   */
  get performAction() {
    if (this.action) {
      const actionFunction = StreamActions[this.action];
      if (actionFunction) {
        return actionFunction;
      }
      this.#raise("unknown action");
    }
    this.#raise("action attribute is missing");
  }
  /**
   * Gets the target elements which the template will be rendered to.
   */
  get targetElements() {
    if (this.target) {
      return this.targetElementsById;
    } else if (this.targets) {
      return this.targetElementsByQuery;
    } else {
      this.#raise("target or targets attribute is missing");
    }
  }
  /**
   * Gets the contents of the main `<template>`.
   */
  get templateContent() {
    return this.templateElement.content.cloneNode(true);
  }
  /**
   * Gets the main `<template>` used for rendering
   */
  get templateElement() {
    if (this.firstElementChild === null) {
      const template = this.ownerDocument.createElement("template");
      this.appendChild(template);
      return template;
    } else if (this.firstElementChild instanceof HTMLTemplateElement) {
      return this.firstElementChild;
    }
    this.#raise("first child element must be a <template> element");
  }
  /**
   * Gets the current action.
   */
  get action() {
    return this.getAttribute("action");
  }
  /**
   * Gets the current target (an element ID) to which the result will
   * be rendered.
   */
  get target() {
    return this.getAttribute("target");
  }
  /**
   * Gets the current "targets" selector (a CSS selector)
   */
  get targets() {
    return this.getAttribute("targets");
  }
  /**
   * Reads the request-id attribute
   */
  get requestId() {
    return this.getAttribute("request-id");
  }
  #raise(message) {
    throw new Error(`${this.description}: ${message}`);
  }
  get description() {
    return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
  }
  get beforeRenderEvent() {
    return new CustomEvent("turbo:before-stream-render", {
      bubbles: true,
      cancelable: true,
      detail: { newStream: this, render: _StreamElement.renderElement }
    });
  }
  get targetElementsById() {
    const element = this.ownerDocument?.getElementById(this.target);
    if (element !== null) {
      return [element];
    } else {
      return [];
    }
  }
  get targetElementsByQuery() {
    const elements = this.ownerDocument?.querySelectorAll(this.targets);
    if (elements.length !== 0) {
      return Array.prototype.slice.call(elements);
    } else {
      return [];
    }
  }
};
var StreamSourceElement = class extends HTMLElement {
  streamSource = null;
  connectedCallback() {
    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
    connectStreamSource(this.streamSource);
  }
  disconnectedCallback() {
    if (this.streamSource) {
      this.streamSource.close();
      disconnectStreamSource(this.streamSource);
    }
  }
  get src() {
    return this.getAttribute("src") || "";
  }
};
FrameElement.delegateConstructor = FrameController;
if (customElements.get("turbo-frame") === void 0) {
  customElements.define("turbo-frame", FrameElement);
}
if (customElements.get("turbo-stream") === void 0) {
  customElements.define("turbo-stream", StreamElement);
}
if (customElements.get("turbo-stream-source") === void 0) {
  customElements.define("turbo-stream-source", StreamSourceElement);
}
(() => {
  let element = document.currentScript;
  if (!element) return;
  if (element.hasAttribute("data-turbo-suppress-warning")) return;
  element = element.parentElement;
  while (element) {
    if (element == document.body) {
      return console.warn(
        unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
        element.outerHTML
      );
    }
    element = element.parentElement;
  }
})();
window.Turbo = { ...Turbo, StreamActions };
start();

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
var consumer;
async function getConsumer() {
  return consumer || setConsumer(createConsumer2().then(setConsumer));
}
function setConsumer(newConsumer) {
  return consumer = newConsumer;
}
async function createConsumer2() {
  const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
  return createConsumer3();
}
async function subscribeTo(channel, mixin) {
  const { subscriptions } = await getConsumer();
  return subscriptions.create(channel, mixin);
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
function walk(obj) {
  if (!obj || typeof obj !== "object") return obj;
  if (obj instanceof Date || obj instanceof RegExp) return obj;
  if (Array.isArray(obj)) return obj.map(walk);
  return Object.keys(obj).reduce(function(acc, key) {
    var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m, x) {
      return "_" + x.toLowerCase();
    });
    acc[camel] = walk(obj[key]);
    return acc;
  }, {});
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
var TurboCableStreamSourceElement = class extends HTMLElement {
  static observedAttributes = ["channel", "signed-stream-name"];
  async connectedCallback() {
    connectStreamSource(this);
    this.subscription = await subscribeTo(this.channel, {
      received: this.dispatchMessageEvent.bind(this),
      connected: this.subscriptionConnected.bind(this),
      disconnected: this.subscriptionDisconnected.bind(this)
    });
  }
  disconnectedCallback() {
    disconnectStreamSource(this);
    if (this.subscription) this.subscription.unsubscribe();
    this.subscriptionDisconnected();
  }
  attributeChangedCallback() {
    if (this.subscription) {
      this.disconnectedCallback();
      this.connectedCallback();
    }
  }
  dispatchMessageEvent(data) {
    const event = new MessageEvent("message", { data });
    return this.dispatchEvent(event);
  }
  subscriptionConnected() {
    this.setAttribute("connected", "");
  }
  subscriptionDisconnected() {
    this.removeAttribute("connected");
  }
  get channel() {
    const channel = this.getAttribute("channel");
    const signed_stream_name = this.getAttribute("signed-stream-name");
    return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
  }
};
if (customElements.get("turbo-cable-stream-source") === void 0) {
  customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
function encodeMethodIntoRequestBody(event) {
  if (event.target instanceof HTMLFormElement) {
    const { target: form, detail: { fetchOptions } } = event;
    form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter: submitter2 } } }) => {
      const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
      const method = determineFetchMethod(submitter2, body, form);
      if (!/get/i.test(method)) {
        if (/post/i.test(method)) {
          body.delete("_method");
        } else {
          body.set("_method", method);
        }
        fetchOptions.method = "post";
      }
    }, { once: true });
  }
}
function determineFetchMethod(submitter2, body, form) {
  const formMethod = determineFormMethod(submitter2);
  const overrideMethod = body.get("_method");
  const method = form.getAttribute("method") || "get";
  if (typeof formMethod == "string") {
    return formMethod;
  } else if (typeof overrideMethod == "string") {
    return overrideMethod;
  } else {
    return method;
  }
}
function determineFormMethod(submitter2) {
  if (submitter2 instanceof HTMLButtonElement || submitter2 instanceof HTMLInputElement) {
    if (submitter2.name === "_method") {
      return submitter2.value;
    } else if (submitter2.hasAttribute("formmethod")) {
      return submitter2.formMethod;
    } else {
      return null;
    }
  } else {
    return null;
  }
}
function isBodyInit(body) {
  return body instanceof FormData || body instanceof URLSearchParams;
}

// node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
window.Turbo = turbo_es2017_esm_exports;
addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

// node_modules/@hotwired/stimulus/dist/stimulus.js
var EventListener = class {
  constructor(eventTarget, eventName, eventOptions) {
    this.eventTarget = eventTarget;
    this.eventName = eventName;
    this.eventOptions = eventOptions;
    this.unorderedBindings = /* @__PURE__ */ new Set();
  }
  connect() {
    this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
  }
  disconnect() {
    this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
  }
  bindingConnected(binding) {
    this.unorderedBindings.add(binding);
  }
  bindingDisconnected(binding) {
    this.unorderedBindings.delete(binding);
  }
  handleEvent(event) {
    const extendedEvent = extendEvent(event);
    for (const binding of this.bindings) {
      if (extendedEvent.immediatePropagationStopped) {
        break;
      } else {
        binding.handleEvent(extendedEvent);
      }
    }
  }
  hasBindings() {
    return this.unorderedBindings.size > 0;
  }
  get bindings() {
    return Array.from(this.unorderedBindings).sort((left2, right2) => {
      const leftIndex = left2.index, rightIndex = right2.index;
      return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
    });
  }
};
function extendEvent(event) {
  if ("immediatePropagationStopped" in event) {
    return event;
  } else {
    const { stopImmediatePropagation } = event;
    return Object.assign(event, {
      immediatePropagationStopped: false,
      stopImmediatePropagation() {
        this.immediatePropagationStopped = true;
        stopImmediatePropagation.call(this);
      }
    });
  }
}
var Dispatcher = class {
  constructor(application2) {
    this.application = application2;
    this.eventListenerMaps = /* @__PURE__ */ new Map();
    this.started = false;
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.eventListeners.forEach((eventListener) => eventListener.connect());
    }
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.eventListeners.forEach((eventListener) => eventListener.disconnect());
    }
  }
  get eventListeners() {
    return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
  }
  bindingConnected(binding) {
    this.fetchEventListenerForBinding(binding).bindingConnected(binding);
  }
  bindingDisconnected(binding, clearEventListeners = false) {
    this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    if (clearEventListeners)
      this.clearEventListenersForBinding(binding);
  }
  handleError(error2, message, detail = {}) {
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  clearEventListenersForBinding(binding) {
    const eventListener = this.fetchEventListenerForBinding(binding);
    if (!eventListener.hasBindings()) {
      eventListener.disconnect();
      this.removeMappedEventListenerFor(binding);
    }
  }
  removeMappedEventListenerFor(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    eventListenerMap.delete(cacheKey);
    if (eventListenerMap.size == 0)
      this.eventListenerMaps.delete(eventTarget);
  }
  fetchEventListenerForBinding(binding) {
    const { eventTarget, eventName, eventOptions } = binding;
    return this.fetchEventListener(eventTarget, eventName, eventOptions);
  }
  fetchEventListener(eventTarget, eventName, eventOptions) {
    const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
    const cacheKey = this.cacheKey(eventName, eventOptions);
    let eventListener = eventListenerMap.get(cacheKey);
    if (!eventListener) {
      eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
      eventListenerMap.set(cacheKey, eventListener);
    }
    return eventListener;
  }
  createEventListener(eventTarget, eventName, eventOptions) {
    const eventListener = new EventListener(eventTarget, eventName, eventOptions);
    if (this.started) {
      eventListener.connect();
    }
    return eventListener;
  }
  fetchEventListenerMapForEventTarget(eventTarget) {
    let eventListenerMap = this.eventListenerMaps.get(eventTarget);
    if (!eventListenerMap) {
      eventListenerMap = /* @__PURE__ */ new Map();
      this.eventListenerMaps.set(eventTarget, eventListenerMap);
    }
    return eventListenerMap;
  }
  cacheKey(eventName, eventOptions) {
    const parts = [eventName];
    Object.keys(eventOptions).sort().forEach((key) => {
      parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
    });
    return parts.join(":");
  }
};
var defaultActionDescriptorFilters = {
  stop({ event, value }) {
    if (value)
      event.stopPropagation();
    return true;
  },
  prevent({ event, value }) {
    if (value)
      event.preventDefault();
    return true;
  },
  self({ event, value, element }) {
    if (value) {
      return element === event.target;
    } else {
      return true;
    }
  }
};
var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
function parseActionDescriptorString(descriptorString) {
  const source = descriptorString.trim();
  const matches = source.match(descriptorPattern) || [];
  let eventName = matches[2];
  let keyFilter = matches[3];
  if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
    eventName += `.${keyFilter}`;
    keyFilter = "";
  }
  return {
    eventTarget: parseEventTarget(matches[4]),
    eventName,
    eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
    identifier: matches[5],
    methodName: matches[6],
    keyFilter: matches[1] || keyFilter
  };
}
function parseEventTarget(eventTargetName) {
  if (eventTargetName == "window") {
    return window;
  } else if (eventTargetName == "document") {
    return document;
  }
}
function parseEventOptions(eventOptions) {
  return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
}
function stringifyEventTarget(eventTarget) {
  if (eventTarget == window) {
    return "window";
  } else if (eventTarget == document) {
    return "document";
  }
}
function camelize(value) {
  return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function namespaceCamelize(value) {
  return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
}
function capitalize(value) {
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
  return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
  return value.match(/[^\s]+/g) || [];
}
function isSomething(object) {
  return object !== null && object !== void 0;
}
function hasProperty(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property);
}
var allModifiers = ["meta", "ctrl", "alt", "shift"];
var Action = class {
  constructor(element, index, descriptor, schema) {
    this.element = element;
    this.index = index;
    this.eventTarget = descriptor.eventTarget || element;
    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
    this.eventOptions = descriptor.eventOptions || {};
    this.identifier = descriptor.identifier || error("missing identifier");
    this.methodName = descriptor.methodName || error("missing method name");
    this.keyFilter = descriptor.keyFilter || "";
    this.schema = schema;
  }
  static forToken(token, schema) {
    return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
  }
  toString() {
    const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
    const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
    return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
  }
  shouldIgnoreKeyboardEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = this.keyFilter.split("+");
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
    if (!standardFilter) {
      return false;
    }
    if (!hasProperty(this.keyMappings, standardFilter)) {
      error(`contains unknown key filter: ${this.keyFilter}`);
    }
    return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
  }
  shouldIgnoreMouseEvent(event) {
    if (!this.keyFilter) {
      return false;
    }
    const filters = [this.keyFilter];
    if (this.keyFilterDissatisfied(event, filters)) {
      return true;
    }
    return false;
  }
  get params() {
    const params = {};
    const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
    for (const { name, value } of Array.from(this.element.attributes)) {
      const match = name.match(pattern);
      const key = match && match[1];
      if (key) {
        params[camelize(key)] = typecast(value);
      }
    }
    return params;
  }
  get eventTargetName() {
    return stringifyEventTarget(this.eventTarget);
  }
  get keyMappings() {
    return this.schema.keyMappings;
  }
  keyFilterDissatisfied(event, filters) {
    const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
    return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
  }
};
var defaultEventNames = {
  a: () => "click",
  button: () => "click",
  form: () => "submit",
  details: () => "toggle",
  input: (e) => e.getAttribute("type") == "submit" ? "click" : "input",
  select: () => "change",
  textarea: () => "input"
};
function getDefaultEventNameForElement(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName in defaultEventNames) {
    return defaultEventNames[tagName](element);
  }
}
function error(message) {
  throw new Error(message);
}
function typecast(value) {
  try {
    return JSON.parse(value);
  } catch (o_O) {
    return value;
  }
}
var Binding = class {
  constructor(context, action) {
    this.context = context;
    this.action = action;
  }
  get index() {
    return this.action.index;
  }
  get eventTarget() {
    return this.action.eventTarget;
  }
  get eventOptions() {
    return this.action.eventOptions;
  }
  get identifier() {
    return this.context.identifier;
  }
  handleEvent(event) {
    const actionEvent = this.prepareActionEvent(event);
    if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
      this.invokeWithEvent(actionEvent);
    }
  }
  get eventName() {
    return this.action.eventName;
  }
  get method() {
    const method = this.controller[this.methodName];
    if (typeof method == "function") {
      return method;
    }
    throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
  }
  applyEventModifiers(event) {
    const { element } = this.action;
    const { actionDescriptorFilters } = this.context.application;
    const { controller } = this.context;
    let passes = true;
    for (const [name, value] of Object.entries(this.eventOptions)) {
      if (name in actionDescriptorFilters) {
        const filter = actionDescriptorFilters[name];
        passes = passes && filter({ name, value, event, element, controller });
      } else {
        continue;
      }
    }
    return passes;
  }
  prepareActionEvent(event) {
    return Object.assign(event, { params: this.action.params });
  }
  invokeWithEvent(event) {
    const { target, currentTarget } = event;
    try {
      this.method.call(this.controller, event);
      this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
    } catch (error2) {
      const { identifier, controller, element, index } = this;
      const detail = { identifier, controller, element, index, event };
      this.context.handleError(error2, `invoking action "${this.action}"`, detail);
    }
  }
  willBeInvokedByEvent(event) {
    const eventTarget = event.target;
    if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
      return false;
    }
    if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
      return false;
    }
    if (this.element === eventTarget) {
      return true;
    } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
      return this.scope.containsElement(eventTarget);
    } else {
      return this.scope.containsElement(this.action.element);
    }
  }
  get controller() {
    return this.context.controller;
  }
  get methodName() {
    return this.action.methodName;
  }
  get element() {
    return this.scope.element;
  }
  get scope() {
    return this.context.scope;
  }
};
var ElementObserver = class {
  constructor(element, delegate) {
    this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
    this.element = element;
    this.started = false;
    this.delegate = delegate;
    this.elements = /* @__PURE__ */ new Set();
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.refresh();
    }
  }
  pause(callback) {
    if (this.started) {
      this.mutationObserver.disconnect();
      this.started = false;
    }
    callback();
    if (!this.started) {
      this.mutationObserver.observe(this.element, this.mutationObserverInit);
      this.started = true;
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      const matches = new Set(this.matchElementsInTree());
      for (const element of Array.from(this.elements)) {
        if (!matches.has(element)) {
          this.removeElement(element);
        }
      }
      for (const element of Array.from(matches)) {
        this.addElement(element);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    if (mutation.type == "attributes") {
      this.processAttributeChange(mutation.target, mutation.attributeName);
    } else if (mutation.type == "childList") {
      this.processRemovedNodes(mutation.removedNodes);
      this.processAddedNodes(mutation.addedNodes);
    }
  }
  processAttributeChange(element, attributeName) {
    if (this.elements.has(element)) {
      if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
        this.delegate.elementAttributeChanged(element, attributeName);
      } else {
        this.removeElement(element);
      }
    } else if (this.matchElement(element)) {
      this.addElement(element);
    }
  }
  processRemovedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element) {
        this.processTree(element, this.removeElement);
      }
    }
  }
  processAddedNodes(nodes) {
    for (const node of Array.from(nodes)) {
      const element = this.elementFromNode(node);
      if (element && this.elementIsActive(element)) {
        this.processTree(element, this.addElement);
      }
    }
  }
  matchElement(element) {
    return this.delegate.matchElement(element);
  }
  matchElementsInTree(tree = this.element) {
    return this.delegate.matchElementsInTree(tree);
  }
  processTree(tree, processor) {
    for (const element of this.matchElementsInTree(tree)) {
      processor.call(this, element);
    }
  }
  elementFromNode(node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      return node;
    }
  }
  elementIsActive(element) {
    if (element.isConnected != this.element.isConnected) {
      return false;
    } else {
      return this.element.contains(element);
    }
  }
  addElement(element) {
    if (!this.elements.has(element)) {
      if (this.elementIsActive(element)) {
        this.elements.add(element);
        if (this.delegate.elementMatched) {
          this.delegate.elementMatched(element);
        }
      }
    }
  }
  removeElement(element) {
    if (this.elements.has(element)) {
      this.elements.delete(element);
      if (this.delegate.elementUnmatched) {
        this.delegate.elementUnmatched(element);
      }
    }
  }
};
var AttributeObserver = class {
  constructor(element, attributeName, delegate) {
    this.attributeName = attributeName;
    this.delegate = delegate;
    this.elementObserver = new ElementObserver(element, this);
  }
  get element() {
    return this.elementObserver.element;
  }
  get selector() {
    return `[${this.attributeName}]`;
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get started() {
    return this.elementObserver.started;
  }
  matchElement(element) {
    return element.hasAttribute(this.attributeName);
  }
  matchElementsInTree(tree) {
    const match = this.matchElement(tree) ? [tree] : [];
    const matches = Array.from(tree.querySelectorAll(this.selector));
    return match.concat(matches);
  }
  elementMatched(element) {
    if (this.delegate.elementMatchedAttribute) {
      this.delegate.elementMatchedAttribute(element, this.attributeName);
    }
  }
  elementUnmatched(element) {
    if (this.delegate.elementUnmatchedAttribute) {
      this.delegate.elementUnmatchedAttribute(element, this.attributeName);
    }
  }
  elementAttributeChanged(element, attributeName) {
    if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
      this.delegate.elementAttributeValueChanged(element, attributeName);
    }
  }
};
function add(map, key, value) {
  fetch2(map, key).add(value);
}
function del(map, key, value) {
  fetch2(map, key).delete(value);
  prune(map, key);
}
function fetch2(map, key) {
  let values = map.get(key);
  if (!values) {
    values = /* @__PURE__ */ new Set();
    map.set(key, values);
  }
  return values;
}
function prune(map, key) {
  const values = map.get(key);
  if (values != null && values.size == 0) {
    map.delete(key);
  }
}
var Multimap = class {
  constructor() {
    this.valuesByKey = /* @__PURE__ */ new Map();
  }
  get keys() {
    return Array.from(this.valuesByKey.keys());
  }
  get values() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((values, set) => values.concat(Array.from(set)), []);
  }
  get size() {
    const sets = Array.from(this.valuesByKey.values());
    return sets.reduce((size, set) => size + set.size, 0);
  }
  add(key, value) {
    add(this.valuesByKey, key, value);
  }
  delete(key, value) {
    del(this.valuesByKey, key, value);
  }
  has(key, value) {
    const values = this.valuesByKey.get(key);
    return values != null && values.has(value);
  }
  hasKey(key) {
    return this.valuesByKey.has(key);
  }
  hasValue(value) {
    const sets = Array.from(this.valuesByKey.values());
    return sets.some((set) => set.has(value));
  }
  getValuesForKey(key) {
    const values = this.valuesByKey.get(key);
    return values ? Array.from(values) : [];
  }
  getKeysForValue(value) {
    return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
  }
};
var SelectorObserver = class {
  constructor(element, selector, delegate, details) {
    this._selector = selector;
    this.details = details;
    this.elementObserver = new ElementObserver(element, this);
    this.delegate = delegate;
    this.matchesByElement = new Multimap();
  }
  get started() {
    return this.elementObserver.started;
  }
  get selector() {
    return this._selector;
  }
  set selector(selector) {
    this._selector = selector;
    this.refresh();
  }
  start() {
    this.elementObserver.start();
  }
  pause(callback) {
    this.elementObserver.pause(callback);
  }
  stop() {
    this.elementObserver.stop();
  }
  refresh() {
    this.elementObserver.refresh();
  }
  get element() {
    return this.elementObserver.element;
  }
  matchElement(element) {
    const { selector } = this;
    if (selector) {
      const matches = element.matches(selector);
      if (this.delegate.selectorMatchElement) {
        return matches && this.delegate.selectorMatchElement(element, this.details);
      }
      return matches;
    } else {
      return false;
    }
  }
  matchElementsInTree(tree) {
    const { selector } = this;
    if (selector) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
      return match.concat(matches);
    } else {
      return [];
    }
  }
  elementMatched(element) {
    const { selector } = this;
    if (selector) {
      this.selectorMatched(element, selector);
    }
  }
  elementUnmatched(element) {
    const selectors = this.matchesByElement.getKeysForValue(element);
    for (const selector of selectors) {
      this.selectorUnmatched(element, selector);
    }
  }
  elementAttributeChanged(element, _attributeName) {
    const { selector } = this;
    if (selector) {
      const matches = this.matchElement(element);
      const matchedBefore = this.matchesByElement.has(selector, element);
      if (matches && !matchedBefore) {
        this.selectorMatched(element, selector);
      } else if (!matches && matchedBefore) {
        this.selectorUnmatched(element, selector);
      }
    }
  }
  selectorMatched(element, selector) {
    this.delegate.selectorMatched(element, selector, this.details);
    this.matchesByElement.add(selector, element);
  }
  selectorUnmatched(element, selector) {
    this.delegate.selectorUnmatched(element, selector, this.details);
    this.matchesByElement.delete(selector, element);
  }
};
var StringMapObserver = class {
  constructor(element, delegate) {
    this.element = element;
    this.delegate = delegate;
    this.started = false;
    this.stringMap = /* @__PURE__ */ new Map();
    this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
  }
  start() {
    if (!this.started) {
      this.started = true;
      this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
      this.refresh();
    }
  }
  stop() {
    if (this.started) {
      this.mutationObserver.takeRecords();
      this.mutationObserver.disconnect();
      this.started = false;
    }
  }
  refresh() {
    if (this.started) {
      for (const attributeName of this.knownAttributeNames) {
        this.refreshAttribute(attributeName, null);
      }
    }
  }
  processMutations(mutations) {
    if (this.started) {
      for (const mutation of mutations) {
        this.processMutation(mutation);
      }
    }
  }
  processMutation(mutation) {
    const attributeName = mutation.attributeName;
    if (attributeName) {
      this.refreshAttribute(attributeName, mutation.oldValue);
    }
  }
  refreshAttribute(attributeName, oldValue) {
    const key = this.delegate.getStringMapKeyForAttribute(attributeName);
    if (key != null) {
      if (!this.stringMap.has(attributeName)) {
        this.stringMapKeyAdded(key, attributeName);
      }
      const value = this.element.getAttribute(attributeName);
      if (this.stringMap.get(attributeName) != value) {
        this.stringMapValueChanged(value, key, oldValue);
      }
      if (value == null) {
        const oldValue2 = this.stringMap.get(attributeName);
        this.stringMap.delete(attributeName);
        if (oldValue2)
          this.stringMapKeyRemoved(key, attributeName, oldValue2);
      } else {
        this.stringMap.set(attributeName, value);
      }
    }
  }
  stringMapKeyAdded(key, attributeName) {
    if (this.delegate.stringMapKeyAdded) {
      this.delegate.stringMapKeyAdded(key, attributeName);
    }
  }
  stringMapValueChanged(value, key, oldValue) {
    if (this.delegate.stringMapValueChanged) {
      this.delegate.stringMapValueChanged(value, key, oldValue);
    }
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    if (this.delegate.stringMapKeyRemoved) {
      this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
    }
  }
  get knownAttributeNames() {
    return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
  }
  get currentAttributeNames() {
    return Array.from(this.element.attributes).map((attribute) => attribute.name);
  }
  get recordedAttributeNames() {
    return Array.from(this.stringMap.keys());
  }
};
var TokenListObserver = class {
  constructor(element, attributeName, delegate) {
    this.attributeObserver = new AttributeObserver(element, attributeName, this);
    this.delegate = delegate;
    this.tokensByElement = new Multimap();
  }
  get started() {
    return this.attributeObserver.started;
  }
  start() {
    this.attributeObserver.start();
  }
  pause(callback) {
    this.attributeObserver.pause(callback);
  }
  stop() {
    this.attributeObserver.stop();
  }
  refresh() {
    this.attributeObserver.refresh();
  }
  get element() {
    return this.attributeObserver.element;
  }
  get attributeName() {
    return this.attributeObserver.attributeName;
  }
  elementMatchedAttribute(element) {
    this.tokensMatched(this.readTokensForElement(element));
  }
  elementAttributeValueChanged(element) {
    const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
    this.tokensUnmatched(unmatchedTokens);
    this.tokensMatched(matchedTokens);
  }
  elementUnmatchedAttribute(element) {
    this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
  }
  tokensMatched(tokens) {
    tokens.forEach((token) => this.tokenMatched(token));
  }
  tokensUnmatched(tokens) {
    tokens.forEach((token) => this.tokenUnmatched(token));
  }
  tokenMatched(token) {
    this.delegate.tokenMatched(token);
    this.tokensByElement.add(token.element, token);
  }
  tokenUnmatched(token) {
    this.delegate.tokenUnmatched(token);
    this.tokensByElement.delete(token.element, token);
  }
  refreshTokensForElement(element) {
    const previousTokens = this.tokensByElement.getValuesForKey(element);
    const currentTokens = this.readTokensForElement(element);
    const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
    if (firstDifferingIndex == -1) {
      return [[], []];
    } else {
      return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
    }
  }
  readTokensForElement(element) {
    const attributeName = this.attributeName;
    const tokenString = element.getAttribute(attributeName) || "";
    return parseTokenString(tokenString, element, attributeName);
  }
};
function parseTokenString(tokenString, element, attributeName) {
  return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
}
function zip(left2, right2) {
  const length = Math.max(left2.length, right2.length);
  return Array.from({ length }, (_, index) => [left2[index], right2[index]]);
}
function tokensAreEqual(left2, right2) {
  return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
}
var ValueListObserver = class {
  constructor(element, attributeName, delegate) {
    this.tokenListObserver = new TokenListObserver(element, attributeName, this);
    this.delegate = delegate;
    this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
    this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
  }
  get started() {
    return this.tokenListObserver.started;
  }
  start() {
    this.tokenListObserver.start();
  }
  stop() {
    this.tokenListObserver.stop();
  }
  refresh() {
    this.tokenListObserver.refresh();
  }
  get element() {
    return this.tokenListObserver.element;
  }
  get attributeName() {
    return this.tokenListObserver.attributeName;
  }
  tokenMatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).set(token, value);
      this.delegate.elementMatchedValue(element, value);
    }
  }
  tokenUnmatched(token) {
    const { element } = token;
    const { value } = this.fetchParseResultForToken(token);
    if (value) {
      this.fetchValuesByTokenForElement(element).delete(token);
      this.delegate.elementUnmatchedValue(element, value);
    }
  }
  fetchParseResultForToken(token) {
    let parseResult = this.parseResultsByToken.get(token);
    if (!parseResult) {
      parseResult = this.parseToken(token);
      this.parseResultsByToken.set(token, parseResult);
    }
    return parseResult;
  }
  fetchValuesByTokenForElement(element) {
    let valuesByToken = this.valuesByTokenByElement.get(element);
    if (!valuesByToken) {
      valuesByToken = /* @__PURE__ */ new Map();
      this.valuesByTokenByElement.set(element, valuesByToken);
    }
    return valuesByToken;
  }
  parseToken(token) {
    try {
      const value = this.delegate.parseValueForToken(token);
      return { value };
    } catch (error2) {
      return { error: error2 };
    }
  }
};
var BindingObserver = class {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.bindingsByAction = /* @__PURE__ */ new Map();
  }
  start() {
    if (!this.valueListObserver) {
      this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
      this.valueListObserver.start();
    }
  }
  stop() {
    if (this.valueListObserver) {
      this.valueListObserver.stop();
      delete this.valueListObserver;
      this.disconnectAllActions();
    }
  }
  get element() {
    return this.context.element;
  }
  get identifier() {
    return this.context.identifier;
  }
  get actionAttribute() {
    return this.schema.actionAttribute;
  }
  get schema() {
    return this.context.schema;
  }
  get bindings() {
    return Array.from(this.bindingsByAction.values());
  }
  connectAction(action) {
    const binding = new Binding(this.context, action);
    this.bindingsByAction.set(action, binding);
    this.delegate.bindingConnected(binding);
  }
  disconnectAction(action) {
    const binding = this.bindingsByAction.get(action);
    if (binding) {
      this.bindingsByAction.delete(action);
      this.delegate.bindingDisconnected(binding);
    }
  }
  disconnectAllActions() {
    this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
    this.bindingsByAction.clear();
  }
  parseValueForToken(token) {
    const action = Action.forToken(token, this.schema);
    if (action.identifier == this.identifier) {
      return action;
    }
  }
  elementMatchedValue(element, action) {
    this.connectAction(action);
  }
  elementUnmatchedValue(element, action) {
    this.disconnectAction(action);
  }
};
var ValueObserver = class {
  constructor(context, receiver) {
    this.context = context;
    this.receiver = receiver;
    this.stringMapObserver = new StringMapObserver(this.element, this);
    this.valueDescriptorMap = this.controller.valueDescriptorMap;
  }
  start() {
    this.stringMapObserver.start();
    this.invokeChangedCallbacksForDefaultValues();
  }
  stop() {
    this.stringMapObserver.stop();
  }
  get element() {
    return this.context.element;
  }
  get controller() {
    return this.context.controller;
  }
  getStringMapKeyForAttribute(attributeName) {
    if (attributeName in this.valueDescriptorMap) {
      return this.valueDescriptorMap[attributeName].name;
    }
  }
  stringMapKeyAdded(key, attributeName) {
    const descriptor = this.valueDescriptorMap[attributeName];
    if (!this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
    }
  }
  stringMapValueChanged(value, name, oldValue) {
    const descriptor = this.valueDescriptorNameMap[name];
    if (value === null)
      return;
    if (oldValue === null) {
      oldValue = descriptor.writer(descriptor.defaultValue);
    }
    this.invokeChangedCallback(name, value, oldValue);
  }
  stringMapKeyRemoved(key, attributeName, oldValue) {
    const descriptor = this.valueDescriptorNameMap[key];
    if (this.hasValue(key)) {
      this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
    } else {
      this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
    }
  }
  invokeChangedCallbacksForDefaultValues() {
    for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
      if (defaultValue != void 0 && !this.controller.data.has(key)) {
        this.invokeChangedCallback(name, writer(defaultValue), void 0);
      }
    }
  }
  invokeChangedCallback(name, rawValue, rawOldValue) {
    const changedMethodName = `${name}Changed`;
    const changedMethod = this.receiver[changedMethodName];
    if (typeof changedMethod == "function") {
      const descriptor = this.valueDescriptorNameMap[name];
      try {
        const value = descriptor.reader(rawValue);
        let oldValue = rawOldValue;
        if (rawOldValue) {
          oldValue = descriptor.reader(rawOldValue);
        }
        changedMethod.call(this.receiver, value, oldValue);
      } catch (error2) {
        if (error2 instanceof TypeError) {
          error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
        }
        throw error2;
      }
    }
  }
  get valueDescriptors() {
    const { valueDescriptorMap } = this;
    return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
  }
  get valueDescriptorNameMap() {
    const descriptors = {};
    Object.keys(this.valueDescriptorMap).forEach((key) => {
      const descriptor = this.valueDescriptorMap[key];
      descriptors[descriptor.name] = descriptor;
    });
    return descriptors;
  }
  hasValue(attributeName) {
    const descriptor = this.valueDescriptorNameMap[attributeName];
    const hasMethodName = `has${capitalize(descriptor.name)}`;
    return this.receiver[hasMethodName];
  }
};
var TargetObserver = class {
  constructor(context, delegate) {
    this.context = context;
    this.delegate = delegate;
    this.targetsByName = new Multimap();
  }
  start() {
    if (!this.tokenListObserver) {
      this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
      this.tokenListObserver.start();
    }
  }
  stop() {
    if (this.tokenListObserver) {
      this.disconnectAllTargets();
      this.tokenListObserver.stop();
      delete this.tokenListObserver;
    }
  }
  tokenMatched({ element, content: name }) {
    if (this.scope.containsElement(element)) {
      this.connectTarget(element, name);
    }
  }
  tokenUnmatched({ element, content: name }) {
    this.disconnectTarget(element, name);
  }
  connectTarget(element, name) {
    var _a;
    if (!this.targetsByName.has(name, element)) {
      this.targetsByName.add(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
    }
  }
  disconnectTarget(element, name) {
    var _a;
    if (this.targetsByName.has(name, element)) {
      this.targetsByName.delete(name, element);
      (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
    }
  }
  disconnectAllTargets() {
    for (const name of this.targetsByName.keys) {
      for (const element of this.targetsByName.getValuesForKey(name)) {
        this.disconnectTarget(element, name);
      }
    }
  }
  get attributeName() {
    return `data-${this.context.identifier}-target`;
  }
  get element() {
    return this.context.element;
  }
  get scope() {
    return this.context.scope;
  }
};
function readInheritableStaticArrayValues(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return Array.from(ancestors.reduce((values, constructor2) => {
    getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
    return values;
  }, /* @__PURE__ */ new Set()));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
  const ancestors = getAncestorsForConstructor(constructor);
  return ancestors.reduce((pairs, constructor2) => {
    pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
    return pairs;
  }, []);
}
function getAncestorsForConstructor(constructor) {
  const ancestors = [];
  while (constructor) {
    ancestors.push(constructor);
    constructor = Object.getPrototypeOf(constructor);
  }
  return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
  const definition = constructor[propertyName];
  return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
  const definition = constructor[propertyName];
  return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
}
var OutletObserver = class {
  constructor(context, delegate) {
    this.started = false;
    this.context = context;
    this.delegate = delegate;
    this.outletsByName = new Multimap();
    this.outletElementsByName = new Multimap();
    this.selectorObserverMap = /* @__PURE__ */ new Map();
    this.attributeObserverMap = /* @__PURE__ */ new Map();
  }
  start() {
    if (!this.started) {
      this.outletDefinitions.forEach((outletName) => {
        this.setupSelectorObserverForOutlet(outletName);
        this.setupAttributeObserverForOutlet(outletName);
      });
      this.started = true;
      this.dependentContexts.forEach((context) => context.refresh());
    }
  }
  refresh() {
    this.selectorObserverMap.forEach((observer) => observer.refresh());
    this.attributeObserverMap.forEach((observer) => observer.refresh());
  }
  stop() {
    if (this.started) {
      this.started = false;
      this.disconnectAllOutlets();
      this.stopSelectorObservers();
      this.stopAttributeObservers();
    }
  }
  stopSelectorObservers() {
    if (this.selectorObserverMap.size > 0) {
      this.selectorObserverMap.forEach((observer) => observer.stop());
      this.selectorObserverMap.clear();
    }
  }
  stopAttributeObservers() {
    if (this.attributeObserverMap.size > 0) {
      this.attributeObserverMap.forEach((observer) => observer.stop());
      this.attributeObserverMap.clear();
    }
  }
  selectorMatched(element, _selector, { outletName }) {
    const outlet = this.getOutlet(element, outletName);
    if (outlet) {
      this.connectOutlet(outlet, element, outletName);
    }
  }
  selectorUnmatched(element, _selector, { outletName }) {
    const outlet = this.getOutletFromMap(element, outletName);
    if (outlet) {
      this.disconnectOutlet(outlet, element, outletName);
    }
  }
  selectorMatchElement(element, { outletName }) {
    const selector = this.selector(outletName);
    const hasOutlet = this.hasOutlet(element, outletName);
    const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
    if (selector) {
      return hasOutlet && hasOutletController && element.matches(selector);
    } else {
      return false;
    }
  }
  elementMatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementAttributeValueChanged(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  elementUnmatchedAttribute(_element, attributeName) {
    const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
    if (outletName) {
      this.updateSelectorObserverForOutlet(outletName);
    }
  }
  connectOutlet(outlet, element, outletName) {
    var _a;
    if (!this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.add(outletName, outlet);
      this.outletElementsByName.add(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
    }
  }
  disconnectOutlet(outlet, element, outletName) {
    var _a;
    if (this.outletElementsByName.has(outletName, element)) {
      this.outletsByName.delete(outletName, outlet);
      this.outletElementsByName.delete(outletName, element);
      (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
    }
  }
  disconnectAllOutlets() {
    for (const outletName of this.outletElementsByName.keys) {
      for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
        for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
          this.disconnectOutlet(outlet, element, outletName);
        }
      }
    }
  }
  updateSelectorObserverForOutlet(outletName) {
    const observer = this.selectorObserverMap.get(outletName);
    if (observer) {
      observer.selector = this.selector(outletName);
    }
  }
  setupSelectorObserverForOutlet(outletName) {
    const selector = this.selector(outletName);
    const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
    this.selectorObserverMap.set(outletName, selectorObserver);
    selectorObserver.start();
  }
  setupAttributeObserverForOutlet(outletName) {
    const attributeName = this.attributeNameForOutletName(outletName);
    const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
    this.attributeObserverMap.set(outletName, attributeObserver);
    attributeObserver.start();
  }
  selector(outletName) {
    return this.scope.outlets.getSelectorForOutletName(outletName);
  }
  attributeNameForOutletName(outletName) {
    return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
  }
  getOutletNameFromOutletAttributeName(attributeName) {
    return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
  }
  get outletDependencies() {
    const dependencies = new Multimap();
    this.router.modules.forEach((module) => {
      const constructor = module.definition.controllerConstructor;
      const outlets = readInheritableStaticArrayValues(constructor, "outlets");
      outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
    });
    return dependencies;
  }
  get outletDefinitions() {
    return this.outletDependencies.getKeysForValue(this.identifier);
  }
  get dependentControllerIdentifiers() {
    return this.outletDependencies.getValuesForKey(this.identifier);
  }
  get dependentContexts() {
    const identifiers = this.dependentControllerIdentifiers;
    return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
  }
  hasOutlet(element, outletName) {
    return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
  }
  getOutlet(element, outletName) {
    return this.application.getControllerForElementAndIdentifier(element, outletName);
  }
  getOutletFromMap(element, outletName) {
    return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
  }
  get scope() {
    return this.context.scope;
  }
  get schema() {
    return this.context.schema;
  }
  get identifier() {
    return this.context.identifier;
  }
  get application() {
    return this.context.application;
  }
  get router() {
    return this.application.router;
  }
};
var Context = class {
  constructor(module, scope) {
    this.logDebugActivity = (functionName, detail = {}) => {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.logDebugActivity(this.identifier, functionName, detail);
    };
    this.module = module;
    this.scope = scope;
    this.controller = new module.controllerConstructor(this);
    this.bindingObserver = new BindingObserver(this, this.dispatcher);
    this.valueObserver = new ValueObserver(this, this.controller);
    this.targetObserver = new TargetObserver(this, this);
    this.outletObserver = new OutletObserver(this, this);
    try {
      this.controller.initialize();
      this.logDebugActivity("initialize");
    } catch (error2) {
      this.handleError(error2, "initializing controller");
    }
  }
  connect() {
    this.bindingObserver.start();
    this.valueObserver.start();
    this.targetObserver.start();
    this.outletObserver.start();
    try {
      this.controller.connect();
      this.logDebugActivity("connect");
    } catch (error2) {
      this.handleError(error2, "connecting controller");
    }
  }
  refresh() {
    this.outletObserver.refresh();
  }
  disconnect() {
    try {
      this.controller.disconnect();
      this.logDebugActivity("disconnect");
    } catch (error2) {
      this.handleError(error2, "disconnecting controller");
    }
    this.outletObserver.stop();
    this.targetObserver.stop();
    this.valueObserver.stop();
    this.bindingObserver.stop();
  }
  get application() {
    return this.module.application;
  }
  get identifier() {
    return this.module.identifier;
  }
  get schema() {
    return this.application.schema;
  }
  get dispatcher() {
    return this.application.dispatcher;
  }
  get element() {
    return this.scope.element;
  }
  get parentElement() {
    return this.element.parentElement;
  }
  handleError(error2, message, detail = {}) {
    const { identifier, controller, element } = this;
    detail = Object.assign({ identifier, controller, element }, detail);
    this.application.handleError(error2, `Error ${message}`, detail);
  }
  targetConnected(element, name) {
    this.invokeControllerMethod(`${name}TargetConnected`, element);
  }
  targetDisconnected(element, name) {
    this.invokeControllerMethod(`${name}TargetDisconnected`, element);
  }
  outletConnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
  }
  outletDisconnected(outlet, element, name) {
    this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
  }
  invokeControllerMethod(methodName, ...args) {
    const controller = this.controller;
    if (typeof controller[methodName] == "function") {
      controller[methodName](...args);
    }
  }
};
function bless(constructor) {
  return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
  const shadowConstructor = extend2(constructor);
  const shadowProperties = getShadowProperties(constructor.prototype, properties);
  Object.defineProperties(shadowConstructor.prototype, shadowProperties);
  return shadowConstructor;
}
function getBlessedProperties(constructor) {
  const blessings = readInheritableStaticArrayValues(constructor, "blessings");
  return blessings.reduce((blessedProperties, blessing) => {
    const properties = blessing(constructor);
    for (const key in properties) {
      const descriptor = blessedProperties[key] || {};
      blessedProperties[key] = Object.assign(descriptor, properties[key]);
    }
    return blessedProperties;
  }, {});
}
function getShadowProperties(prototype, properties) {
  return getOwnKeys(properties).reduce((shadowProperties, key) => {
    const descriptor = getShadowedDescriptor(prototype, properties, key);
    if (descriptor) {
      Object.assign(shadowProperties, { [key]: descriptor });
    }
    return shadowProperties;
  }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
  const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
  const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
  if (!shadowedByValue) {
    const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
    if (shadowingDescriptor) {
      descriptor.get = shadowingDescriptor.get || descriptor.get;
      descriptor.set = shadowingDescriptor.set || descriptor.set;
    }
    return descriptor;
  }
}
var getOwnKeys = (() => {
  if (typeof Object.getOwnPropertySymbols == "function") {
    return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
  } else {
    return Object.getOwnPropertyNames;
  }
})();
var extend2 = (() => {
  function extendWithReflect(constructor) {
    function extended() {
      return Reflect.construct(constructor, arguments, new.target);
    }
    extended.prototype = Object.create(constructor.prototype, {
      constructor: { value: extended }
    });
    Reflect.setPrototypeOf(extended, constructor);
    return extended;
  }
  function testReflectExtension() {
    const a = function() {
      this.a.call(this);
    };
    const b = extendWithReflect(a);
    b.prototype.a = function() {
    };
    return new b();
  }
  try {
    testReflectExtension();
    return extendWithReflect;
  } catch (error2) {
    return (constructor) => class extended extends constructor {
    };
  }
})();
function blessDefinition(definition) {
  return {
    identifier: definition.identifier,
    controllerConstructor: bless(definition.controllerConstructor)
  };
}
var Module = class {
  constructor(application2, definition) {
    this.application = application2;
    this.definition = blessDefinition(definition);
    this.contextsByScope = /* @__PURE__ */ new WeakMap();
    this.connectedContexts = /* @__PURE__ */ new Set();
  }
  get identifier() {
    return this.definition.identifier;
  }
  get controllerConstructor() {
    return this.definition.controllerConstructor;
  }
  get contexts() {
    return Array.from(this.connectedContexts);
  }
  connectContextForScope(scope) {
    const context = this.fetchContextForScope(scope);
    this.connectedContexts.add(context);
    context.connect();
  }
  disconnectContextForScope(scope) {
    const context = this.contextsByScope.get(scope);
    if (context) {
      this.connectedContexts.delete(context);
      context.disconnect();
    }
  }
  fetchContextForScope(scope) {
    let context = this.contextsByScope.get(scope);
    if (!context) {
      context = new Context(this, scope);
      this.contextsByScope.set(scope, context);
    }
    return context;
  }
};
var ClassMap = class {
  constructor(scope) {
    this.scope = scope;
  }
  has(name) {
    return this.data.has(this.getDataKey(name));
  }
  get(name) {
    return this.getAll(name)[0];
  }
  getAll(name) {
    const tokenString = this.data.get(this.getDataKey(name)) || "";
    return tokenize(tokenString);
  }
  getAttributeName(name) {
    return this.data.getAttributeNameForKey(this.getDataKey(name));
  }
  getDataKey(name) {
    return `${name}-class`;
  }
  get data() {
    return this.scope.data;
  }
};
var DataMap = class {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.getAttribute(name);
  }
  set(key, value) {
    const name = this.getAttributeNameForKey(key);
    this.element.setAttribute(name, value);
    return this.get(key);
  }
  has(key) {
    const name = this.getAttributeNameForKey(key);
    return this.element.hasAttribute(name);
  }
  delete(key) {
    if (this.has(key)) {
      const name = this.getAttributeNameForKey(key);
      this.element.removeAttribute(name);
      return true;
    } else {
      return false;
    }
  }
  getAttributeNameForKey(key) {
    return `data-${this.identifier}-${dasherize(key)}`;
  }
};
var Guide = class {
  constructor(logger) {
    this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
    this.logger = logger;
  }
  warn(object, key, message) {
    let warnedKeys = this.warnedKeysByObject.get(object);
    if (!warnedKeys) {
      warnedKeys = /* @__PURE__ */ new Set();
      this.warnedKeysByObject.set(object, warnedKeys);
    }
    if (!warnedKeys.has(key)) {
      warnedKeys.add(key);
      this.logger.warn(message, object);
    }
  }
};
function attributeValueContainsToken(attributeName, token) {
  return `[${attributeName}~="${token}"]`;
}
var TargetSet = class {
  constructor(scope) {
    this.scope = scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(targetName) {
    return this.find(targetName) != null;
  }
  find(...targetNames) {
    return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
  }
  findAll(...targetNames) {
    return targetNames.reduce((targets, targetName) => [
      ...targets,
      ...this.findAllTargets(targetName),
      ...this.findAllLegacyTargets(targetName)
    ], []);
  }
  findTarget(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findElement(selector);
  }
  findAllTargets(targetName) {
    const selector = this.getSelectorForTargetName(targetName);
    return this.scope.findAllElements(selector);
  }
  getSelectorForTargetName(targetName) {
    const attributeName = this.schema.targetAttributeForScope(this.identifier);
    return attributeValueContainsToken(attributeName, targetName);
  }
  findLegacyTarget(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.deprecate(this.scope.findElement(selector), targetName);
  }
  findAllLegacyTargets(targetName) {
    const selector = this.getLegacySelectorForTargetName(targetName);
    return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
  }
  getLegacySelectorForTargetName(targetName) {
    const targetDescriptor = `${this.identifier}.${targetName}`;
    return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
  }
  deprecate(element, targetName) {
    if (element) {
      const { identifier } = this;
      const attributeName = this.schema.targetAttribute;
      const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
      this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
    }
    return element;
  }
  get guide() {
    return this.scope.guide;
  }
};
var OutletSet = class {
  constructor(scope, controllerElement) {
    this.scope = scope;
    this.controllerElement = controllerElement;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get schema() {
    return this.scope.schema;
  }
  has(outletName) {
    return this.find(outletName) != null;
  }
  find(...outletNames) {
    return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
  }
  findAll(...outletNames) {
    return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
  }
  getSelectorForOutletName(outletName) {
    const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
    return this.controllerElement.getAttribute(attributeName);
  }
  findOutlet(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    if (selector)
      return this.findElement(selector, outletName);
  }
  findAllOutlets(outletName) {
    const selector = this.getSelectorForOutletName(outletName);
    return selector ? this.findAllElements(selector, outletName) : [];
  }
  findElement(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
  }
  findAllElements(selector, outletName) {
    const elements = this.scope.queryElements(selector);
    return elements.filter((element) => this.matchesElement(element, selector, outletName));
  }
  matchesElement(element, selector, outletName) {
    const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
    return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
  }
};
var Scope = class _Scope {
  constructor(schema, element, identifier, logger) {
    this.targets = new TargetSet(this);
    this.classes = new ClassMap(this);
    this.data = new DataMap(this);
    this.containsElement = (element2) => {
      return element2.closest(this.controllerSelector) === this.element;
    };
    this.schema = schema;
    this.element = element;
    this.identifier = identifier;
    this.guide = new Guide(logger);
    this.outlets = new OutletSet(this.documentScope, element);
  }
  findElement(selector) {
    return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
  }
  findAllElements(selector) {
    return [
      ...this.element.matches(selector) ? [this.element] : [],
      ...this.queryElements(selector).filter(this.containsElement)
    ];
  }
  queryElements(selector) {
    return Array.from(this.element.querySelectorAll(selector));
  }
  get controllerSelector() {
    return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
  }
  get isDocumentScope() {
    return this.element === document.documentElement;
  }
  get documentScope() {
    return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
  }
};
var ScopeObserver = class {
  constructor(element, schema, delegate) {
    this.element = element;
    this.schema = schema;
    this.delegate = delegate;
    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
    this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
    this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
  }
  start() {
    this.valueListObserver.start();
  }
  stop() {
    this.valueListObserver.stop();
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  parseValueForToken(token) {
    const { element, content: identifier } = token;
    return this.parseValueForElementAndIdentifier(element, identifier);
  }
  parseValueForElementAndIdentifier(element, identifier) {
    const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
    let scope = scopesByIdentifier.get(identifier);
    if (!scope) {
      scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
      scopesByIdentifier.set(identifier, scope);
    }
    return scope;
  }
  elementMatchedValue(element, value) {
    const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
    this.scopeReferenceCounts.set(value, referenceCount);
    if (referenceCount == 1) {
      this.delegate.scopeConnected(value);
    }
  }
  elementUnmatchedValue(element, value) {
    const referenceCount = this.scopeReferenceCounts.get(value);
    if (referenceCount) {
      this.scopeReferenceCounts.set(value, referenceCount - 1);
      if (referenceCount == 1) {
        this.delegate.scopeDisconnected(value);
      }
    }
  }
  fetchScopesByIdentifierForElement(element) {
    let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
    if (!scopesByIdentifier) {
      scopesByIdentifier = /* @__PURE__ */ new Map();
      this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
    }
    return scopesByIdentifier;
  }
};
var Router = class {
  constructor(application2) {
    this.application = application2;
    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
    this.scopesByIdentifier = new Multimap();
    this.modulesByIdentifier = /* @__PURE__ */ new Map();
  }
  get element() {
    return this.application.element;
  }
  get schema() {
    return this.application.schema;
  }
  get logger() {
    return this.application.logger;
  }
  get controllerAttribute() {
    return this.schema.controllerAttribute;
  }
  get modules() {
    return Array.from(this.modulesByIdentifier.values());
  }
  get contexts() {
    return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
  }
  start() {
    this.scopeObserver.start();
  }
  stop() {
    this.scopeObserver.stop();
  }
  loadDefinition(definition) {
    this.unloadIdentifier(definition.identifier);
    const module = new Module(this.application, definition);
    this.connectModule(module);
    const afterLoad = definition.controllerConstructor.afterLoad;
    if (afterLoad) {
      afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
    }
  }
  unloadIdentifier(identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      this.disconnectModule(module);
    }
  }
  getContextForElementAndIdentifier(element, identifier) {
    const module = this.modulesByIdentifier.get(identifier);
    if (module) {
      return module.contexts.find((context) => context.element == element);
    }
  }
  proposeToConnectScopeForElementAndIdentifier(element, identifier) {
    const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
    if (scope) {
      this.scopeObserver.elementMatchedValue(scope.element, scope);
    } else {
      console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
    }
  }
  handleError(error2, message, detail) {
    this.application.handleError(error2, message, detail);
  }
  createScopeForElementAndIdentifier(element, identifier) {
    return new Scope(this.schema, element, identifier, this.logger);
  }
  scopeConnected(scope) {
    this.scopesByIdentifier.add(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.connectContextForScope(scope);
    }
  }
  scopeDisconnected(scope) {
    this.scopesByIdentifier.delete(scope.identifier, scope);
    const module = this.modulesByIdentifier.get(scope.identifier);
    if (module) {
      module.disconnectContextForScope(scope);
    }
  }
  connectModule(module) {
    this.modulesByIdentifier.set(module.identifier, module);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.connectContextForScope(scope));
  }
  disconnectModule(module) {
    this.modulesByIdentifier.delete(module.identifier);
    const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
    scopes.forEach((scope) => module.disconnectContextForScope(scope));
  }
};
var defaultSchema = {
  controllerAttribute: "data-controller",
  actionAttribute: "data-action",
  targetAttribute: "data-target",
  targetAttributeForScope: (identifier) => `data-${identifier}-target`,
  outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
  keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n])))
};
function objectFromEntries(array) {
  return array.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
}
var Application = class {
  constructor(element = document.documentElement, schema = defaultSchema) {
    this.logger = console;
    this.debug = false;
    this.logDebugActivity = (identifier, functionName, detail = {}) => {
      if (this.debug) {
        this.logFormattedMessage(identifier, functionName, detail);
      }
    };
    this.element = element;
    this.schema = schema;
    this.dispatcher = new Dispatcher(this);
    this.router = new Router(this);
    this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
  }
  static start(element, schema) {
    const application2 = new this(element, schema);
    application2.start();
    return application2;
  }
  async start() {
    await domReady();
    this.logDebugActivity("application", "starting");
    this.dispatcher.start();
    this.router.start();
    this.logDebugActivity("application", "start");
  }
  stop() {
    this.logDebugActivity("application", "stopping");
    this.dispatcher.stop();
    this.router.stop();
    this.logDebugActivity("application", "stop");
  }
  register(identifier, controllerConstructor) {
    this.load({ identifier, controllerConstructor });
  }
  registerActionOption(name, filter) {
    this.actionDescriptorFilters[name] = filter;
  }
  load(head, ...rest) {
    const definitions = Array.isArray(head) ? head : [head, ...rest];
    definitions.forEach((definition) => {
      if (definition.controllerConstructor.shouldLoad) {
        this.router.loadDefinition(definition);
      }
    });
  }
  unload(head, ...rest) {
    const identifiers = Array.isArray(head) ? head : [head, ...rest];
    identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
  }
  get controllers() {
    return this.router.contexts.map((context) => context.controller);
  }
  getControllerForElementAndIdentifier(element, identifier) {
    const context = this.router.getContextForElementAndIdentifier(element, identifier);
    return context ? context.controller : null;
  }
  handleError(error2, message, detail) {
    var _a;
    this.logger.error(`%s

%o

%o`, message, error2, detail);
    (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
  }
  logFormattedMessage(identifier, functionName, detail = {}) {
    detail = Object.assign({ application: this }, detail);
    this.logger.groupCollapsed(`${identifier} #${functionName}`);
    this.logger.log("details:", Object.assign({}, detail));
    this.logger.groupEnd();
  }
};
function domReady() {
  return new Promise((resolve) => {
    if (document.readyState == "loading") {
      document.addEventListener("DOMContentLoaded", () => resolve());
    } else {
      resolve();
    }
  });
}
function ClassPropertiesBlessing(constructor) {
  const classes = readInheritableStaticArrayValues(constructor, "classes");
  return classes.reduce((properties, classDefinition) => {
    return Object.assign(properties, propertiesForClassDefinition(classDefinition));
  }, {});
}
function propertiesForClassDefinition(key) {
  return {
    [`${key}Class`]: {
      get() {
        const { classes } = this;
        if (classes.has(key)) {
          return classes.get(key);
        } else {
          const attribute = classes.getAttributeName(key);
          throw new Error(`Missing attribute "${attribute}"`);
        }
      }
    },
    [`${key}Classes`]: {
      get() {
        return this.classes.getAll(key);
      }
    },
    [`has${capitalize(key)}Class`]: {
      get() {
        return this.classes.has(key);
      }
    }
  };
}
function OutletPropertiesBlessing(constructor) {
  const outlets = readInheritableStaticArrayValues(constructor, "outlets");
  return outlets.reduce((properties, outletDefinition) => {
    return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
  }, {});
}
function getOutletController(controller, element, identifier) {
  return controller.application.getControllerForElementAndIdentifier(element, identifier);
}
function getControllerAndEnsureConnectedScope(controller, element, outletName) {
  let outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
  controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
  outletController = getOutletController(controller, element, outletName);
  if (outletController)
    return outletController;
}
function propertiesForOutletDefinition(name) {
  const camelizedName = namespaceCamelize(name);
  return {
    [`${camelizedName}Outlet`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
          if (outletController)
            return outletController;
          throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
        }
        throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
      }
    },
    [`${camelizedName}Outlets`]: {
      get() {
        const outlets = this.outlets.findAll(name);
        if (outlets.length > 0) {
          return outlets.map((outletElement) => {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
          }).filter((controller) => controller);
        }
        return [];
      }
    },
    [`${camelizedName}OutletElement`]: {
      get() {
        const outletElement = this.outlets.find(name);
        const selector = this.outlets.getSelectorForOutletName(name);
        if (outletElement) {
          return outletElement;
        } else {
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      }
    },
    [`${camelizedName}OutletElements`]: {
      get() {
        return this.outlets.findAll(name);
      }
    },
    [`has${capitalize(camelizedName)}Outlet`]: {
      get() {
        return this.outlets.has(name);
      }
    }
  };
}
function TargetPropertiesBlessing(constructor) {
  const targets = readInheritableStaticArrayValues(constructor, "targets");
  return targets.reduce((properties, targetDefinition) => {
    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
  }, {});
}
function propertiesForTargetDefinition(name) {
  return {
    [`${name}Target`]: {
      get() {
        const target = this.targets.find(name);
        if (target) {
          return target;
        } else {
          throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
        }
      }
    },
    [`${name}Targets`]: {
      get() {
        return this.targets.findAll(name);
      }
    },
    [`has${capitalize(name)}Target`]: {
      get() {
        return this.targets.has(name);
      }
    }
  };
}
function ValuePropertiesBlessing(constructor) {
  const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
  const propertyDescriptorMap = {
    valueDescriptorMap: {
      get() {
        return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
          const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
          const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
          return Object.assign(result, { [attributeName]: valueDescriptor });
        }, {});
      }
    }
  };
  return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
  }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
  const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
  const { key, name, reader: read2, writer: write2 } = definition;
  return {
    [name]: {
      get() {
        const value = this.data.get(key);
        if (value !== null) {
          return read2(value);
        } else {
          return definition.defaultValue;
        }
      },
      set(value) {
        if (value === void 0) {
          this.data.delete(key);
        } else {
          this.data.set(key, write2(value));
        }
      }
    },
    [`has${capitalize(name)}`]: {
      get() {
        return this.data.has(key) || definition.hasCustomDefaultValue;
      }
    }
  };
}
function parseValueDefinitionPair([token, typeDefinition], controller) {
  return valueDescriptorForTokenAndTypeDefinition({
    controller,
    token,
    typeDefinition
  });
}
function parseValueTypeConstant(constant) {
  switch (constant) {
    case Array:
      return "array";
    case Boolean:
      return "boolean";
    case Number:
      return "number";
    case Object:
      return "object";
    case String:
      return "string";
  }
}
function parseValueTypeDefault(defaultValue) {
  switch (typeof defaultValue) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
  }
  if (Array.isArray(defaultValue))
    return "array";
  if (Object.prototype.toString.call(defaultValue) === "[object Object]")
    return "object";
}
function parseValueTypeObject(payload) {
  const { controller, token, typeObject } = payload;
  const hasType = isSomething(typeObject.type);
  const hasDefault = isSomething(typeObject.default);
  const fullObject = hasType && hasDefault;
  const onlyType = hasType && !hasDefault;
  const onlyDefault = !hasType && hasDefault;
  const typeFromObject = parseValueTypeConstant(typeObject.type);
  const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
  if (onlyType)
    return typeFromObject;
  if (onlyDefault)
    return typeFromDefaultValue;
  if (typeFromObject !== typeFromDefaultValue) {
    const propertyPath = controller ? `${controller}.${token}` : token;
    throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
  }
  if (fullObject)
    return typeFromObject;
}
function parseValueTypeDefinition(payload) {
  const { controller, token, typeDefinition } = payload;
  const typeObject = { controller, token, typeObject: typeDefinition };
  const typeFromObject = parseValueTypeObject(typeObject);
  const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
  const typeFromConstant = parseValueTypeConstant(typeDefinition);
  const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
  if (type)
    return type;
  const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
  throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
}
function defaultValueForDefinition(typeDefinition) {
  const constant = parseValueTypeConstant(typeDefinition);
  if (constant)
    return defaultValuesByType[constant];
  const hasDefault = hasProperty(typeDefinition, "default");
  const hasType = hasProperty(typeDefinition, "type");
  const typeObject = typeDefinition;
  if (hasDefault)
    return typeObject.default;
  if (hasType) {
    const { type } = typeObject;
    const constantFromType = parseValueTypeConstant(type);
    if (constantFromType)
      return defaultValuesByType[constantFromType];
  }
  return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(payload) {
  const { token, typeDefinition } = payload;
  const key = `${dasherize(token)}-value`;
  const type = parseValueTypeDefinition(payload);
  return {
    type,
    key,
    name: camelize(key),
    get defaultValue() {
      return defaultValueForDefinition(typeDefinition);
    },
    get hasCustomDefaultValue() {
      return parseValueTypeDefault(typeDefinition) !== void 0;
    },
    reader: readers[type],
    writer: writers[type] || writers.default
  };
}
var defaultValuesByType = {
  get array() {
    return [];
  },
  boolean: false,
  number: 0,
  get object() {
    return {};
  },
  string: ""
};
var readers = {
  array(value) {
    const array = JSON.parse(value);
    if (!Array.isArray(array)) {
      throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
    }
    return array;
  },
  boolean(value) {
    return !(value == "0" || String(value).toLowerCase() == "false");
  },
  number(value) {
    return Number(value.replace(/_/g, ""));
  },
  object(value) {
    const object = JSON.parse(value);
    if (object === null || typeof object != "object" || Array.isArray(object)) {
      throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
    }
    return object;
  },
  string(value) {
    return value;
  }
};
var writers = {
  default: writeString,
  array: writeJSON,
  object: writeJSON
};
function writeJSON(value) {
  return JSON.stringify(value);
}
function writeString(value) {
  return `${value}`;
}
var Controller = class {
  constructor(context) {
    this.context = context;
  }
  static get shouldLoad() {
    return true;
  }
  static afterLoad(_identifier, _application) {
    return;
  }
  get application() {
    return this.context.application;
  }
  get scope() {
    return this.context.scope;
  }
  get element() {
    return this.scope.element;
  }
  get identifier() {
    return this.scope.identifier;
  }
  get targets() {
    return this.scope.targets;
  }
  get outlets() {
    return this.scope.outlets;
  }
  get classes() {
    return this.scope.classes;
  }
  get data() {
    return this.scope.data;
  }
  initialize() {
  }
  connect() {
  }
  disconnect() {
  }
  dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
    const type = prefix ? `${prefix}:${eventName}` : eventName;
    const event = new CustomEvent(type, { detail, bubbles, cancelable });
    target.dispatchEvent(event);
    return event;
  }
};
Controller.blessings = [
  ClassPropertiesBlessing,
  TargetPropertiesBlessing,
  ValuePropertiesBlessing,
  OutletPropertiesBlessing
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};

// app/javascript/controllers/application.js
var application = Application.start();
application.debug = false;
window.Stimulus = application;

// app/javascript/controllers/hello_controller.js
var hello_controller_default = class extends Controller {
  connect() {
    this.element.textContent = "Hello World!";
  }
};

// app/javascript/controllers/index.js
application.register("hello", hello_controller_default);

// node_modules/@popperjs/core/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  afterMain: () => afterMain,
  afterRead: () => afterRead,
  afterWrite: () => afterWrite,
  applyStyles: () => applyStyles_default,
  arrow: () => arrow_default,
  auto: () => auto,
  basePlacements: () => basePlacements,
  beforeMain: () => beforeMain,
  beforeRead: () => beforeRead,
  beforeWrite: () => beforeWrite,
  bottom: () => bottom,
  clippingParents: () => clippingParents,
  computeStyles: () => computeStyles_default,
  createPopper: () => createPopper3,
  createPopperBase: () => createPopper,
  createPopperLite: () => createPopper2,
  detectOverflow: () => detectOverflow,
  end: () => end,
  eventListeners: () => eventListeners_default,
  flip: () => flip_default,
  hide: () => hide_default,
  left: () => left,
  main: () => main,
  modifierPhases: () => modifierPhases,
  offset: () => offset_default,
  placements: () => placements,
  popper: () => popper,
  popperGenerator: () => popperGenerator,
  popperOffsets: () => popperOffsets_default,
  preventOverflow: () => preventOverflow_default,
  read: () => read,
  reference: () => reference,
  right: () => right,
  start: () => start2,
  top: () => top,
  variationPlacements: () => variationPlacements,
  viewport: () => viewport,
  write: () => write
});

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start2 = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start2, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start2, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start2:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start2;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce2(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = /* @__PURE__ */ popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = /* @__PURE__ */ popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/bootstrap/dist/js/bootstrap.esm.js
var elementMap = /* @__PURE__ */ new Map();
var Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, /* @__PURE__ */ new Map());
    }
    const instanceMap = elementMap.get(element);
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }
    instanceMap.set(key, instance);
  },
  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    const instanceMap = elementMap.get(element);
    instanceMap.delete(key);
    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }
};
var MAX_UID = 1e6;
var MILLISECONDS_MULTIPLIER = 1e3;
var TRANSITION_END = "transitionend";
var parseSelector = (selector) => {
  if (selector && window.CSS && window.CSS.escape) {
    selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
  }
  return selector;
};
var toType = (object) => {
  if (object === null || object === void 0) {
    return `${object}`;
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
var getUID = (prefix) => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
var getTransitionDurationFromElement = (element) => {
  if (!element) {
    return 0;
  }
  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
var triggerTransitionEnd = (element) => {
  element.dispatchEvent(new Event(TRANSITION_END));
};
var isElement2 = (object) => {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (typeof object.jquery !== "undefined") {
    object = object[0];
  }
  return typeof object.nodeType !== "undefined";
};
var getElement = (object) => {
  if (isElement2(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === "string" && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
var isVisible = (element) => {
  if (!isElement2(element) || element.getClientRects().length === 0) {
    return false;
  }
  const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
  const closedDetails = element.closest("details:not([open])");
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    const summary = element.closest("summary");
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
var isDisabled = (element) => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains("disabled")) {
    return true;
  }
  if (typeof element.disabled !== "undefined") {
    return element.disabled;
  }
  return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
};
var findShadowRoot = (element) => {
  if (!document.documentElement.attachShadow) {
    return null;
  }
  if (typeof element.getRootNode === "function") {
    const root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }
  if (!element.parentNode) {
    return null;
  }
  return findShadowRoot(element.parentNode);
};
var noop = () => {
};
var reflow = (element) => {
  element.offsetHeight;
};
var getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
    return window.jQuery;
  }
  return null;
};
var DOMContentLoadedCallbacks = [];
var onDOMContentLoaded = (callback) => {
  if (document.readyState === "loading") {
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener("DOMContentLoaded", () => {
        for (const callback2 of DOMContentLoadedCallbacks) {
          callback2();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
var isRTL = () => document.documentElement.dir === "rtl";
var defineJQueryPlugin = (plugin) => {
  onDOMContentLoaded(() => {
    const $ = getjQuery();
    if ($) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $.fn[name];
      $.fn[name] = plugin.jQueryInterface;
      $.fn[name].Constructor = plugin;
      $.fn[name].noConflict = () => {
        $.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
var execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
  return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
};
var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list.length;
  let index = list.indexOf(activeElement);
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list[Math.max(0, Math.min(index, listLength - 1))];
};
var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
var stripNameRegex = /\..*/;
var stripUidRegex = /::\d+$/;
var eventRegistry = {};
var uidEvent = 1;
var customEvents = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
};
var nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
function makeEventUid(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element, fn2) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn2);
    }
    return fn2.apply(element, [event]);
  };
}
function bootstrapDelegationHandler(element, selector, fn2) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);
    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }
        hydrateObj(event, {
          delegateTarget: target
        });
        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn2);
        }
        return fn2.apply(target, [event]);
      }
    }
  };
}
function findHandler(events, callable, delegationSelector = null) {
  return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === "string";
  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== "string" || !element) {
    return;
  }
  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
  if (originalTypeEvent in customEvents) {
    const wrapFunction = (fn3) => {
      return function(event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn3.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  const events = getElementEvents(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
  const fn2 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn2.delegationSelector = isDelegated ? handler : null;
  fn2.callable = callable;
  fn2.oneOff = oneOff;
  fn2.uidEvent = uid;
  handlers[uid] = fn2;
  element.addEventListener(typeEvent, fn2, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn2) {
    return;
  }
  element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
  delete events[typeEvent][fn2.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
}
function getTypeEvent(event) {
  event = event.replace(stripNameRegex, "");
  return customEvents[event] || event;
}
var EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getElementEvents(element);
    const storeElementEvent = events[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith(".");
    if (typeof callable !== "undefined") {
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, "");
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger(element, event, args) {
    if (typeof event !== "string" || !element) {
      return null;
    }
    const $ = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args);
      $(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    const evt = hydrateObj(new Event(event, {
      bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
function hydrateObj(obj, meta = {}) {
  for (const [key, value] of Object.entries(meta)) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get() {
          return value;
        }
      });
    }
  }
  return obj;
}
function normalizeData(value) {
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === "" || value === "null") {
    return null;
  }
  if (typeof value !== "string") {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
}
var Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element) {
    if (!element) {
      return {};
    }
    const attributes = {};
    const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, "");
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    }
    return attributes;
  },
  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }
};
var Config2 = class {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(config2) {
    config2 = this._mergeConfigObj(config2);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  _configAfterMerge(config2) {
    return config2;
  }
  _mergeConfigObj(config2, element) {
    const jsonConfig = isElement2(element) ? Manipulator.getDataAttribute(element, "config") : {};
    return {
      ...this.constructor.Default,
      ...typeof jsonConfig === "object" ? jsonConfig : {},
      ...isElement2(element) ? Manipulator.getDataAttributes(element) : {},
      ...typeof config2 === "object" ? config2 : {}
    };
  }
  _typeCheckConfig(config2, configTypes = this.constructor.DefaultType) {
    for (const [property, expectedTypes] of Object.entries(configTypes)) {
      const value = config2[property];
      const valueType = isElement2(value) ? "element" : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }
};
var VERSION = "5.3.3";
var BaseComponent = class extends Config2 {
  constructor(element, config2) {
    super();
    element = getElement(element);
    if (!element) {
      return;
    }
    this._element = element;
    this._config = this._getConfig(config2);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }
  // Public
  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }
  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  _getConfig(config2) {
    config2 = this._mergeConfigObj(config2, this._element);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  // Static
  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }
  static getOrCreateInstance(element, config2 = {}) {
    return this.getInstance(element) || new this(element, typeof config2 === "object" ? config2 : null);
  }
  static get VERSION() {
    return VERSION;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(name) {
    return `${name}${this.EVENT_KEY}`;
  }
};
var getSelector = (element) => {
  let selector = element.getAttribute("data-bs-target");
  if (!selector || selector === "#") {
    let hrefAttribute = element.getAttribute("href");
    if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
      return null;
    }
    if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
      hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
    }
    selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
  }
  return selector ? selector.split(",").map((sel) => parseSelector(sel)).join(",") : null;
};
var SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },
  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },
  children(element, selector) {
    return [].concat(...element.children).filter((child) => child.matches(selector));
  },
  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev(element, selector) {
    let previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(element, selector) {
    let next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element) {
    const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
    return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
  },
  getSelectorFromElement(element) {
    const selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};
var enableDismissTrigger = (component, method = "hide") => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
    const instance = component.getOrCreateInstance(target);
    instance[method]();
  });
};
var NAME$f = "alert";
var DATA_KEY$a = "bs.alert";
var EVENT_KEY$b = `.${DATA_KEY$a}`;
var EVENT_CLOSE = `close${EVENT_KEY$b}`;
var EVENT_CLOSED = `closed${EVENT_KEY$b}`;
var CLASS_NAME_FADE$5 = "fade";
var CLASS_NAME_SHOW$8 = "show";
var Alert = class _Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$f;
  }
  // Public
  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    this._element.classList.remove(CLASS_NAME_SHOW$8);
    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  }
  // Private
  _destroyElement() {
    this._element.remove();
    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Alert.getOrCreateInstance(this);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2](this);
    });
  }
};
enableDismissTrigger(Alert, "close");
defineJQueryPlugin(Alert);
var NAME$e = "button";
var DATA_KEY$9 = "bs.button";
var EVENT_KEY$a = `.${DATA_KEY$9}`;
var DATA_API_KEY$6 = ".data-api";
var CLASS_NAME_ACTIVE$3 = "active";
var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
var Button = class _Button extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$e;
  }
  // Public
  toggle() {
    this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Button.getOrCreateInstance(this);
      if (config2 === "toggle") {
        data[config2]();
      }
    });
  }
};
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data = Button.getOrCreateInstance(button);
  data.toggle();
});
defineJQueryPlugin(Button);
var NAME$d = "swipe";
var EVENT_KEY$9 = ".bs.swipe";
var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
var EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
var EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
var POINTER_TYPE_TOUCH = "touch";
var POINTER_TYPE_PEN = "pen";
var CLASS_NAME_POINTER_EVENT = "pointer-event";
var SWIPE_THRESHOLD = 40;
var Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
var DefaultType$c = {
  endCallback: "(function|null)",
  leftCallback: "(function|null)",
  rightCallback: "(function|null)"
};
var Swipe = class _Swipe extends Config2 {
  constructor(element, config2) {
    super();
    this._element = element;
    if (!element || !_Swipe.isSupported()) {
      return;
    }
    this._config = this._getConfig(config2);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);
    this._initEvents();
  }
  // Getters
  static get Default() {
    return Default$c;
  }
  static get DefaultType() {
    return DefaultType$c;
  }
  static get NAME() {
    return NAME$d;
  }
  // Public
  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  }
  // Private
  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }
  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }
    this._handleSwipe();
    execute(this._config.endCallback);
  }
  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);
    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;
    if (!direction) {
      return;
    }
    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
    }
  }
  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  }
  // Static
  static isSupported() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
};
var NAME$c = "carousel";
var DATA_KEY$8 = "bs.carousel";
var EVENT_KEY$8 = `.${DATA_KEY$8}`;
var DATA_API_KEY$5 = ".data-api";
var ARROW_LEFT_KEY$1 = "ArrowLeft";
var ARROW_RIGHT_KEY$1 = "ArrowRight";
var TOUCHEVENT_COMPAT_WAIT = 500;
var ORDER_NEXT = "next";
var ORDER_PREV = "prev";
var DIRECTION_LEFT = "left";
var DIRECTION_RIGHT = "right";
var EVENT_SLIDE = `slide${EVENT_KEY$8}`;
var EVENT_SLID = `slid${EVENT_KEY$8}`;
var EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
var EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
var EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
var EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
var EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
var CLASS_NAME_CAROUSEL = "carousel";
var CLASS_NAME_ACTIVE$2 = "active";
var CLASS_NAME_SLIDE = "slide";
var CLASS_NAME_END = "carousel-item-end";
var CLASS_NAME_START = "carousel-item-start";
var CLASS_NAME_NEXT = "carousel-item-next";
var CLASS_NAME_PREV = "carousel-item-prev";
var SELECTOR_ACTIVE = ".active";
var SELECTOR_ITEM = ".carousel-item";
var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
var SELECTOR_ITEM_IMG = ".carousel-item img";
var SELECTOR_INDICATORS = ".carousel-indicators";
var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
var KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
var Default$b = {
  interval: 5e3,
  keyboard: true,
  pause: "hover",
  ride: false,
  touch: true,
  wrap: true
};
var DefaultType$b = {
  interval: "(number|boolean)",
  // TODO:v6 remove boolean support
  keyboard: "boolean",
  pause: "(string|boolean)",
  ride: "(boolean|string)",
  touch: "boolean",
  wrap: "boolean"
};
var Carousel = class _Carousel extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._addEventListeners();
    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  }
  // Getters
  static get Default() {
    return Default$b;
  }
  static get DefaultType() {
    return DefaultType$b;
  }
  static get NAME() {
    return NAME$c;
  }
  // Public
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }
    this._clearInterval();
  }
  cycle() {
    this._clearInterval();
    this._updateInterval();
    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }
    this.cycle();
  }
  to(index) {
    const items = this._getItems();
    if (index > items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    const activeIndex = this._getItemIndex(this._getActive());
    if (activeIndex === index) {
      return;
    }
    const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order2, items[index]);
  }
  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }
    super.dispose();
  }
  // Private
  _configAfterMerge(config2) {
    config2.defaultInterval = config2.interval;
    return config2;
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
    }
    if (this._config.pause === "hover") {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }
    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }
  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
    }
    const endCallBack = () => {
      if (this._config.pause !== "hover") {
        return;
      }
      this.pause();
      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }
      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };
    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(this._directionToOrder(direction));
    }
  }
  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }
  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }
    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute("aria-current");
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute("aria-current", "true");
    }
  }
  _updateInterval() {
    const element = this._activeElement || this._getActive();
    if (!element) {
      return;
    }
    const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }
  _slide(order2, element = null) {
    if (this._isSliding) {
      return;
    }
    const activeElement = this._getActive();
    const isNext = order2 === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    if (nextElement === activeElement) {
      return;
    }
    const nextElementIndex = this._getItemIndex(nextElement);
    const triggerEvent = (eventName) => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order2),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };
    const slideEvent = triggerEvent(EVENT_SLIDE);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      return;
    }
    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;
    this._setActiveIndicatorElement(nextElementIndex);
    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);
    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent(EVENT_SLID);
    };
    this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    if (isCycling) {
      this.cycle();
    }
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }
  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }
  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }
  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }
  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order2) {
    if (isRTL()) {
      return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Carousel.getOrCreateInstance(this, config2);
      if (typeof config2 === "number") {
        data.to(config2);
        return;
      }
      if (typeof config2 === "string") {
        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      }
    });
  }
};
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute("data-bs-slide-to");
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, "slide") === "next") {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});
defineJQueryPlugin(Carousel);
var NAME$b = "collapse";
var DATA_KEY$7 = "bs.collapse";
var EVENT_KEY$7 = `.${DATA_KEY$7}`;
var DATA_API_KEY$4 = ".data-api";
var EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
var EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
var EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
var EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
var CLASS_NAME_SHOW$7 = "show";
var CLASS_NAME_COLLAPSE = "collapse";
var CLASS_NAME_COLLAPSING = "collapsing";
var CLASS_NAME_COLLAPSED = "collapsed";
var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
var WIDTH = "width";
var HEIGHT = "height";
var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
var Default$a = {
  parent: null,
  toggle: true
};
var DefaultType$a = {
  parent: "(null|element)",
  toggle: "boolean"
};
var Collapse = class _Collapse extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    for (const elem of toggleList) {
      const selector = SelectorEngine.getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }
  // Getters
  static get Default() {
    return Default$a;
  }
  static get DefaultType() {
    return DefaultType$a;
  }
  static get NAME() {
    return NAME$b;
  }
  // Public
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let activeChildren = [];
    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => _Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }
    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }
    const dimension = this._getDimension();
    this._element.classList.remove(CLASS_NAME_COLLAPSE);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      this._element.style[dimension] = "";
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    for (const trigger of this._triggerArray) {
      const element = SelectorEngine.getElementFromSelector(trigger);
      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE);
      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };
    this._element.style[dimension] = "";
    this._queueCallback(complete, this._element, true);
  }
  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  }
  // Private
  _configAfterMerge(config2) {
    config2.toggle = Boolean(config2.toggle);
    config2.parent = getElement(config2.parent);
    return config2;
  }
  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    for (const element of children) {
      const selected = SelectorEngine.getElementFromSelector(element);
      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }
  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute("aria-expanded", isOpen);
    }
  }
  // Static
  static jQueryInterface(config2) {
    const _config = {};
    if (typeof config2 === "string" && /show|hide/.test(config2)) {
      _config.toggle = false;
    }
    return this.each(function() {
      const data = _Collapse.getOrCreateInstance(this, _config);
      if (typeof config2 === "string") {
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2]();
      }
    });
  }
};
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
  if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
    event.preventDefault();
  }
  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});
defineJQueryPlugin(Collapse);
var NAME$a = "dropdown";
var DATA_KEY$6 = "bs.dropdown";
var EVENT_KEY$6 = `.${DATA_KEY$6}`;
var DATA_API_KEY$3 = ".data-api";
var ESCAPE_KEY$2 = "Escape";
var TAB_KEY$1 = "Tab";
var ARROW_UP_KEY$1 = "ArrowUp";
var ARROW_DOWN_KEY$1 = "ArrowDown";
var RIGHT_MOUSE_BUTTON = 2;
var EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
var EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
var EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
var CLASS_NAME_SHOW$6 = "show";
var CLASS_NAME_DROPUP = "dropup";
var CLASS_NAME_DROPEND = "dropend";
var CLASS_NAME_DROPSTART = "dropstart";
var CLASS_NAME_DROPUP_CENTER = "dropup-center";
var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
var SELECTOR_MENU = ".dropdown-menu";
var SELECTOR_NAVBAR = ".navbar";
var SELECTOR_NAVBAR_NAV = ".navbar-nav";
var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
var PLACEMENT_TOPCENTER = "top";
var PLACEMENT_BOTTOMCENTER = "bottom";
var Default$9 = {
  autoClose: true,
  boundary: "clippingParents",
  display: "dynamic",
  offset: [0, 2],
  popperConfig: null,
  reference: "toggle"
};
var DefaultType$9 = {
  autoClose: "(boolean|string)",
  boundary: "(string|element)",
  display: "string",
  offset: "(array|string|function)",
  popperConfig: "(null|object|function)",
  reference: "(string|element|object)"
};
var Dropdown = class _Dropdown extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._popper = null;
    this._parent = this._element.parentNode;
    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  }
  // Getters
  static get Default() {
    return Default$9;
  }
  static get DefaultType() {
    return DefaultType$9;
  }
  static get NAME() {
    return NAME$a;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._createPopper();
    if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    this._element.focus();
    this._element.setAttribute("aria-expanded", true);
    this._menu.classList.add(CLASS_NAME_SHOW$6);
    this._element.classList.add(CLASS_NAME_SHOW$6);
    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }
  // Private
  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    if (hideEvent.defaultPrevented) {
      return;
    }
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    if (this._popper) {
      this._popper.destroy();
    }
    this._menu.classList.remove(CLASS_NAME_SHOW$6);
    this._element.classList.remove(CLASS_NAME_SHOW$6);
    this._element.setAttribute("aria-expanded", "false");
    Manipulator.removeDataAttribute(this._menu, "popper");
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }
  _getConfig(config2) {
    config2 = super._getConfig(config2);
    if (typeof config2.reference === "object" && !isElement2(config2.reference) && typeof config2.reference.getBoundingClientRect !== "function") {
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }
    return config2;
  }
  _createPopper() {
    if (typeof lib_exports === "undefined") {
      throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
    }
    let referenceElement = this._element;
    if (this._config.reference === "parent") {
      referenceElement = this._parent;
    } else if (isElement2(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === "object") {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    this._popper = createPopper3(referenceElement, this._menu, popperConfig);
  }
  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }
  _getPlacement() {
    const parentDropdown = this._parent;
    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    }
    const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }]
    };
    if (this._inNavbar || this._config.display === "static") {
      Manipulator.setDataAttribute(this._menu, "popper", "static");
      defaultBsPopperConfig.modifiers = [{
        name: "applyStyles",
        enabled: false
      }];
    }
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
    if (!items.length) {
      return;
    }
    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Dropdown.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
      return;
    }
    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    for (const toggle of openToggles) {
      const context = _Dropdown.getInstance(toggle);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);
      if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
        continue;
      }
      if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event.type === "click") {
        relatedTarget.clickEvent = event;
      }
      context._completeHide(relatedTarget);
    }
  }
  static dataApiKeydownHandler(event) {
    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }
    if (isInput && !isEscapeEvent) {
      return;
    }
    event.preventDefault();
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = _Dropdown.getOrCreateInstance(getToggleButton);
    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();
      instance._selectMenuItem(event);
      return;
    }
    if (instance._isShown()) {
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }
};
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
defineJQueryPlugin(Dropdown);
var NAME$9 = "backdrop";
var CLASS_NAME_FADE$4 = "fade";
var CLASS_NAME_SHOW$5 = "show";
var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
var Default$8 = {
  className: "modal-backdrop",
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: "body"
  // give the choice to place backdrop under different elements
};
var DefaultType$8 = {
  className: "string",
  clickCallback: "(function|null)",
  isAnimated: "boolean",
  isVisible: "boolean",
  rootElement: "(element|string)"
};
var Backdrop = class extends Config2 {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
    this._isAppended = false;
    this._element = null;
  }
  // Getters
  static get Default() {
    return Default$8;
  }
  static get DefaultType() {
    return DefaultType$8;
  }
  static get NAME() {
    return NAME$9;
  }
  // Public
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    const element = this._getElement();
    if (this._config.isAnimated) {
      reflow(element);
    }
    element.classList.add(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    EventHandler.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }
  // Private
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement("div");
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _configAfterMerge(config2) {
    config2.rootElement = getElement(config2.rootElement);
    return config2;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    const element = this._getElement();
    this._config.rootElement.append(element);
    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }
};
var NAME$8 = "focustrap";
var DATA_KEY$5 = "bs.focustrap";
var EVENT_KEY$5 = `.${DATA_KEY$5}`;
var EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
var TAB_KEY = "Tab";
var TAB_NAV_FORWARD = "forward";
var TAB_NAV_BACKWARD = "backward";
var Default$7 = {
  autofocus: true,
  trapElement: null
  // The element to trap focus inside of
};
var DefaultType$7 = {
  autofocus: "boolean",
  trapElement: "element"
};
var FocusTrap = class extends Config2 {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }
  // Getters
  static get Default() {
    return Default$7;
  }
  static get DefaultType() {
    return DefaultType$7;
  }
  static get NAME() {
    return NAME$8;
  }
  // Public
  activate() {
    if (this._isActive) {
      return;
    }
    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }
    EventHandler.off(document, EVENT_KEY$5);
    EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
    this._isActive = true;
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  }
  // Private
  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;
    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }
    const elements = SelectorEngine.focusableChildren(trapElement);
    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }
  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }
    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }
};
var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
var SELECTOR_STICKY_CONTENT = ".sticky-top";
var PROPERTY_PADDING = "padding-right";
var PROPERTY_MARGIN = "margin-right";
var ScrollBarHelper = class {
  constructor() {
    this._element = document.body;
  }
  // Public
  getWidth() {
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width = this.getWidth();
    this._disableOverFlow();
    this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow");
    this._resetElementAttributes(this._element, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow");
    this._element.style.overflow = "hidden";
  }
  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = (element) => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element, styleProperty);
      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);
    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = (element) => {
      const value = Manipulator.getDataAttribute(element, styleProperty);
      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }
      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement2(selector)) {
      callBack(selector);
      return;
    }
    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }
};
var NAME$7 = "modal";
var DATA_KEY$4 = "bs.modal";
var EVENT_KEY$4 = `.${DATA_KEY$4}`;
var DATA_API_KEY$2 = ".data-api";
var ESCAPE_KEY$1 = "Escape";
var EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
var EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
var EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
var EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
var EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
var CLASS_NAME_OPEN = "modal-open";
var CLASS_NAME_FADE$3 = "fade";
var CLASS_NAME_SHOW$4 = "show";
var CLASS_NAME_STATIC = "modal-static";
var OPEN_SELECTOR$1 = ".modal.show";
var SELECTOR_DIALOG = ".modal-dialog";
var SELECTOR_MODAL_BODY = ".modal-body";
var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
var Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
var DefaultType$6 = {
  backdrop: "(boolean|string)",
  focus: "boolean",
  keyboard: "boolean"
};
var Modal = class _Modal extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$6;
  }
  static get DefaultType() {
    return DefaultType$6;
  }
  static get NAME() {
    return NAME$7;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._isTransitioning = true;
    this._scrollBar.hide();
    document.body.classList.add(CLASS_NAME_OPEN);
    this._adjustDialog();
    this._backdrop.show(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    this._isTransitioning = true;
    this._focustrap.deactivate();
    this._element.classList.remove(CLASS_NAME_SHOW$4);
    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }
  dispose() {
    EventHandler.off(window, EVENT_KEY$4);
    EventHandler.off(this._dialog, EVENT_KEY$4);
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _showElement(relatedTarget) {
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }
    this._element.style.display = "block";
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW$4);
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }
      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
      EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
        if (this._element !== event.target || this._element !== event2.target) {
          return;
        }
        if (this._config.backdrop === "static") {
          this._triggerBackdropTransition();
          return;
        }
        if (this._config.backdrop) {
          this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = "none";
    this._element.setAttribute("aria-hidden", true);
    this._element.removeAttribute("aria-modal");
    this._element.removeAttribute("role");
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._scrollBar.reset();
      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }
  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY;
    if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }
    if (!isModalOverflowing) {
      this._element.style.overflowY = "hidden";
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);
    this._element.focus();
  }
  /**
   * The following methods are used to handle overflowing modals
   */
  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? "paddingLeft" : "paddingRight";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? "paddingRight" : "paddingLeft";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "";
    this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(config2, relatedTarget) {
    return this.each(function() {
      const data = _Modal.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2](relatedTarget);
    });
  }
};
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
    if (showEvent.defaultPrevented) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  const data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);
defineJQueryPlugin(Modal);
var NAME$6 = "offcanvas";
var DATA_KEY$3 = "bs.offcanvas";
var EVENT_KEY$3 = `.${DATA_KEY$3}`;
var DATA_API_KEY$1 = ".data-api";
var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
var ESCAPE_KEY = "Escape";
var CLASS_NAME_SHOW$3 = "show";
var CLASS_NAME_SHOWING$1 = "showing";
var CLASS_NAME_HIDING = "hiding";
var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
var OPEN_SELECTOR = ".offcanvas.show";
var EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
var EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
var EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
var EVENT_RESIZE = `resize${EVENT_KEY$3}`;
var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
var Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
var DefaultType$5 = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  scroll: "boolean"
};
var Offcanvas = class _Offcanvas extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$5;
  }
  static get DefaultType() {
    return DefaultType$5;
  }
  static get NAME() {
    return NAME$6;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._backdrop.show();
    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.classList.add(CLASS_NAME_SHOWING$1);
    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }
      this._element.classList.add(CLASS_NAME_SHOW$3);
      this._element.classList.remove(CLASS_NAME_SHOWING$1);
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.deactivate();
    this._element.blur();
    this._isShown = false;
    this._element.classList.add(CLASS_NAME_HIDING);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }
      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  // Private
  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === "static") {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }
      this.hide();
    };
    const isVisible2 = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible: isVisible2,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible2 ? clickCallback : null
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
    });
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Offcanvas.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2](this);
    });
  }
};
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    if (isVisible(this)) {
      this.focus();
    }
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  const data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
    if (getComputedStyle(element).position !== "fixed") {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);
defineJQueryPlugin(Offcanvas);
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
var DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  dd: [],
  div: [],
  dl: [],
  dt: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
var uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
var allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }
  return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === "function") {
    return sanitizeFunction(unsafeHtml);
  }
  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
  const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
  for (const element of elements) {
    const elementName = element.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }
    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }
  return createdDocument.body.innerHTML;
}
var NAME$5 = "TemplateFactory";
var Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: "",
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: "<div></div>"
};
var DefaultType$4 = {
  allowList: "object",
  content: "object",
  extraClass: "(string|function)",
  html: "boolean",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  template: "string"
};
var DefaultContentType = {
  entry: "(string|element|function|null)",
  selector: "(string|element)"
};
var TemplateFactory = class extends Config2 {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
  }
  // Getters
  static get Default() {
    return Default$4;
  }
  static get DefaultType() {
    return DefaultType$4;
  }
  static get NAME() {
    return NAME$5;
  }
  // Public
  getContent() {
    return Object.values(this._config.content).map((config2) => this._resolvePossibleFunction(config2)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(content) {
    this._checkContent(content);
    this._config.content = {
      ...this._config.content,
      ...content
    };
    return this;
  }
  toHtml() {
    const templateWrapper = document.createElement("div");
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    for (const [selector, text] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text, selector);
    }
    const template = templateWrapper.children[0];
    const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    if (extraClass) {
      template.classList.add(...extraClass.split(" "));
    }
    return template;
  }
  // Private
  _typeCheckConfig(config2) {
    super._typeCheckConfig(config2);
    this._checkContent(config2.content);
  }
  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }
  _setContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);
    if (!templateElement) {
      return;
    }
    content = this._resolvePossibleFunction(content);
    if (!content) {
      templateElement.remove();
      return;
    }
    if (isElement2(content)) {
      this._putElementInTemplate(getElement(content), templateElement);
      return;
    }
    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }
    templateElement.textContent = content;
  }
  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this]);
  }
  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = "";
      templateElement.append(element);
      return;
    }
    templateElement.textContent = element.textContent;
  }
};
var NAME$4 = "tooltip";
var DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
var CLASS_NAME_FADE$2 = "fade";
var CLASS_NAME_MODAL = "modal";
var CLASS_NAME_SHOW$2 = "show";
var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
var EVENT_MODAL_HIDE = "hide.bs.modal";
var TRIGGER_HOVER = "hover";
var TRIGGER_FOCUS = "focus";
var TRIGGER_CLICK = "click";
var TRIGGER_MANUAL = "manual";
var EVENT_HIDE$2 = "hide";
var EVENT_HIDDEN$2 = "hidden";
var EVENT_SHOW$2 = "show";
var EVENT_SHOWN$2 = "shown";
var EVENT_INSERTED = "inserted";
var EVENT_CLICK$1 = "click";
var EVENT_FOCUSIN$1 = "focusin";
var EVENT_FOCUSOUT$1 = "focusout";
var EVENT_MOUSEENTER = "mouseenter";
var EVENT_MOUSELEAVE = "mouseleave";
var AttachmentMap = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: isRTL() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: isRTL() ? "right" : "left"
};
var Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: "clippingParents",
  container: false,
  customClass: "",
  delay: 0,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  html: false,
  offset: [0, 6],
  placement: "top",
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  title: "",
  trigger: "hover focus"
};
var DefaultType$3 = {
  allowList: "object",
  animation: "boolean",
  boundary: "(string|element)",
  container: "(string|element|boolean)",
  customClass: "(string|function)",
  delay: "(number|object)",
  fallbackPlacements: "array",
  html: "boolean",
  offset: "(array|string|function)",
  placement: "(string|function)",
  popperConfig: "(null|object|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  selector: "(string|boolean)",
  template: "string",
  title: "(string|element|function)",
  trigger: "string"
};
var Tooltip = class _Tooltip extends BaseComponent {
  constructor(element, config2) {
    if (typeof lib_exports === "undefined") {
      throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
    }
    super(element, config2);
    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = null;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null;
    this.tip = null;
    this._setListeners();
    if (!this._config.selector) {
      this._fixTitle();
    }
  }
  // Getters
  static get Default() {
    return Default$3;
  }
  static get DefaultType() {
    return DefaultType$3;
  }
  static get NAME() {
    return NAME$4;
  }
  // Public
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (!this._isEnabled) {
      return;
    }
    this._activeTrigger.click = !this._activeTrigger.click;
    if (this._isShown()) {
      this._leave();
      return;
    }
    this._enter();
  }
  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    if (this._element.getAttribute("data-bs-original-title")) {
      this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === "none") {
      throw new Error("Please use show on visible elements");
    }
    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }
    this._disposePopper();
    const tip = this._getTipElement();
    this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
    const {
      container
    } = this._config;
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }
    this._popper = this._createPopper(tip);
    tip.classList.add(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    const complete = () => {
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
      if (this._isHovered === false) {
        this._leave();
      }
      this._isHovered = false;
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    if (hideEvent.defaultPrevented) {
      return;
    }
    const tip = this._getTipElement();
    tip.classList.remove(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = null;
    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (!this._isHovered) {
        this._disposePopper();
      }
      this._element.removeAttribute("aria-describedby");
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  update() {
    if (this._popper) {
      this._popper.update();
    }
  }
  // Protected
  _isWithContent() {
    return Boolean(this._getTitle());
  }
  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }
    return this.tip;
  }
  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml();
    if (!tip) {
      return null;
    }
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute("id", tipId);
    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }
    return tip;
  }
  setContent(content) {
    this._newContent = content;
    if (this._isShown()) {
      this._disposePopper();
      this.show();
    }
  }
  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({
        ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }
    return this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
  }
  // Private
  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }
  _createPopper(tip) {
    const placement = execute(this._config.placement, [this, tip, this._element]);
    const attachment = AttachmentMap[placement.toUpperCase()];
    return createPopper3(this._element, tip, this._getPopperConfig(attachment));
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this._element]);
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: "flip",
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }, {
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "arrow",
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: "preSetPlacement",
        enabled: true,
        phase: "beforeMain",
        fn: (data) => {
          this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
        }
      }]
    };
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _setListeners() {
    const triggers = this._config.trigger.split(" ");
    for (const trigger of triggers) {
      if (trigger === "click") {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context.toggle();
        });
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
          context._leave();
        });
      }
    }
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
  }
  _fixTitle() {
    const title = this._element.getAttribute("title");
    if (!title) {
      return;
    }
    if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
      this._element.setAttribute("aria-label", title);
    }
    this._element.setAttribute("data-bs-original-title", title);
    this._element.removeAttribute("title");
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }
    this._isHovered = true;
    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }
  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }
    this._isHovered = false;
    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }
  _setTimeout(handler, timeout) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }
  _getConfig(config2) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }
    config2 = {
      ...dataAttributes,
      ...typeof config2 === "object" && config2 ? config2 : {}
    };
    config2 = this._mergeConfigObj(config2);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  _configAfterMerge(config2) {
    config2.container = config2.container === false ? document.body : getElement(config2.container);
    if (typeof config2.delay === "number") {
      config2.delay = {
        show: config2.delay,
        hide: config2.delay
      };
    }
    if (typeof config2.title === "number") {
      config2.title = config2.title.toString();
    }
    if (typeof config2.content === "number") {
      config2.content = config2.content.toString();
    }
    return config2;
  }
  _getDelegateConfig() {
    const config2 = {};
    for (const [key, value] of Object.entries(this._config)) {
      if (this.constructor.Default[key] !== value) {
        config2[key] = value;
      }
    }
    config2.selector = false;
    config2.trigger = "manual";
    return config2;
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Tooltip.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
};
defineJQueryPlugin(Tooltip);
var NAME$3 = "popover";
var SELECTOR_TITLE = ".popover-header";
var SELECTOR_CONTENT = ".popover-body";
var Default$2 = {
  ...Tooltip.Default,
  content: "",
  offset: [0, 8],
  placement: "right",
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  trigger: "click"
};
var DefaultType$2 = {
  ...Tooltip.DefaultType,
  content: "(null|string|element|function)"
};
var Popover = class _Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }
  static get DefaultType() {
    return DefaultType$2;
  }
  static get NAME() {
    return NAME$3;
  }
  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }
  // Private
  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Popover.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
};
defineJQueryPlugin(Popover);
var NAME$2 = "scrollspy";
var DATA_KEY$2 = "bs.scrollspy";
var EVENT_KEY$2 = `.${DATA_KEY$2}`;
var DATA_API_KEY = ".data-api";
var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
var EVENT_CLICK = `click${EVENT_KEY$2}`;
var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
var CLASS_NAME_ACTIVE$1 = "active";
var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
var SELECTOR_TARGET_LINKS = "[href]";
var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
var SELECTOR_NAV_LINKS = ".nav-link";
var SELECTOR_NAV_ITEMS = ".nav-item";
var SELECTOR_LIST_ITEMS = ".list-group-item";
var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
var SELECTOR_DROPDOWN = ".dropdown";
var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
var Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "0px 0px -25%",
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
var DefaultType$1 = {
  offset: "(number|null)",
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "string",
  smoothScroll: "boolean",
  target: "element",
  threshold: "array"
};
var ScrollSpy = class _ScrollSpy extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh();
  }
  // Getters
  static get Default() {
    return Default$1;
  }
  static get DefaultType() {
    return DefaultType$1;
  }
  static get NAME() {
    return NAME$2;
  }
  // Public
  refresh() {
    this._initializeTargetsAndObservables();
    this._maybeEnableSmoothScroll();
    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }
    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }
  dispose() {
    this._observer.disconnect();
    super.dispose();
  }
  // Private
  _configAfterMerge(config2) {
    config2.target = getElement(config2.target) || document.body;
    config2.rootMargin = config2.offset ? `${config2.offset}px 0px -30%` : config2.rootMargin;
    if (typeof config2.threshold === "string") {
      config2.threshold = config2.threshold.split(",").map((value) => Number.parseFloat(value));
    }
    return config2;
  }
  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    }
    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
      const observableSection = this._observableSections.get(event.target.hash);
      if (observableSection) {
        event.preventDefault();
        const root = this._rootElement || window;
        const height = observableSection.offsetTop - this._element.offsetTop;
        if (root.scrollTo) {
          root.scrollTo({
            top: height,
            behavior: "smooth"
          });
          return;
        }
        root.scrollTop = height;
      }
    });
  }
  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver((entries) => this._observerCallback(entries), options);
  }
  // The logic of selection
  _observerCallback(entries) {
    const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
    const activate = (entry) => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
      this._process(targetElement(entry));
    };
    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;
    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;
        this._clearActiveClass(targetElement(entry));
        continue;
      }
      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry);
        if (!parentScrollTop) {
          return;
        }
        continue;
      }
      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    for (const anchor of targetLinks) {
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }
      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
      if (isVisible(observableSection)) {
        this._targetLinks.set(decodeURI(anchor.hash), anchor);
        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }
  _process(target) {
    if (this._activeTarget === target) {
      return;
    }
    this._clearActiveClass(this._config.target);
    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);
    this._activateParents(target);
    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _activateParents(target) {
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }
    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }
  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _ScrollSpy.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
};
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});
defineJQueryPlugin(ScrollSpy);
var NAME$1 = "tab";
var DATA_KEY$1 = "bs.tab";
var EVENT_KEY$1 = `.${DATA_KEY$1}`;
var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
var EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
var EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
var ARROW_LEFT_KEY = "ArrowLeft";
var ARROW_RIGHT_KEY = "ArrowRight";
var ARROW_UP_KEY = "ArrowUp";
var ARROW_DOWN_KEY = "ArrowDown";
var HOME_KEY = "Home";
var END_KEY = "End";
var CLASS_NAME_ACTIVE = "active";
var CLASS_NAME_FADE$1 = "fade";
var CLASS_NAME_SHOW$1 = "show";
var CLASS_DROPDOWN = "dropdown";
var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
var NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
var SELECTOR_OUTER = ".nav-item, .list-group-item";
var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
var Tab = class _Tab extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    if (!this._parent) {
      return;
    }
    this._setInitialAttributes(this._parent, this._getChildren());
    EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
  }
  // Getters
  static get NAME() {
    return NAME$1;
  }
  // Public
  show() {
    const innerElem = this._element;
    if (this._elemIsActive(innerElem)) {
      return;
    }
    const active = this._getActiveElem();
    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });
    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }
    this._deactivate(active, innerElem);
    this._activate(innerElem, active);
  }
  // Private
  _activate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.add(CLASS_NAME_ACTIVE);
    this._activate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }
      element.removeAttribute("tabindex");
      element.setAttribute("aria-selected", true);
      this._toggleDropDown(element, true);
      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();
    this._deactivate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }
      element.setAttribute("aria-selected", false);
      element.setAttribute("tabindex", "-1");
      this._toggleDropDown(element, false);
      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    const children = this._getChildren().filter((element) => !isDisabled(element));
    let nextActiveElement;
    if ([HOME_KEY, END_KEY].includes(event.key)) {
      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
    } else {
      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
    }
    if (nextActiveElement) {
      nextActiveElement.focus({
        preventScroll: true
      });
      _Tab.getOrCreateInstance(nextActiveElement).show();
    }
  }
  _getChildren() {
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find((child) => this._elemIsActive(child)) || null;
  }
  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, "role", "tablist");
    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }
  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);
    const isActive = this._elemIsActive(child);
    const outerElem = this._getOuterElement(child);
    child.setAttribute("aria-selected", isActive);
    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, "role", "presentation");
    }
    if (!isActive) {
      child.setAttribute("tabindex", "-1");
    }
    this._setAttributeIfNotExists(child, "role", "tab");
    this._setInitialAttributesOnTargetPanel(child);
  }
  _setInitialAttributesOnTargetPanel(child) {
    const target = SelectorEngine.getElementFromSelector(child);
    if (!target) {
      return;
    }
    this._setAttributeIfNotExists(target, "role", "tabpanel");
    if (child.id) {
      this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
    }
  }
  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);
    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }
    const toggle = (selector, className) => {
      const element2 = SelectorEngine.findOne(selector, outerElem);
      if (element2) {
        element2.classList.toggle(className, open);
      }
    };
    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    outerElem.setAttribute("aria-expanded", open);
  }
  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }
  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  }
  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  }
  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Tab.getOrCreateInstance(this);
      if (typeof config2 !== "string") {
        return;
      }
      if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data[config2]();
    });
  }
};
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab.getOrCreateInstance(this).show();
});
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab.getOrCreateInstance(element);
  }
});
defineJQueryPlugin(Tab);
var NAME = "toast";
var DATA_KEY = "bs.toast";
var EVENT_KEY = `.${DATA_KEY}`;
var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
var EVENT_HIDE = `hide${EVENT_KEY}`;
var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
var EVENT_SHOW = `show${EVENT_KEY}`;
var EVENT_SHOWN = `shown${EVENT_KEY}`;
var CLASS_NAME_FADE = "fade";
var CLASS_NAME_HIDE = "hide";
var CLASS_NAME_SHOW = "show";
var CLASS_NAME_SHOWING = "showing";
var DefaultType = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
};
var Default = {
  animation: true,
  autohide: true,
  delay: 5e3
};
var Toast = class _Toast extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }
  // Getters
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME;
  }
  // Public
  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }
    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);
      EventHandler.trigger(this._element, EVENT_SHOWN);
      this._maybeScheduleHide();
    };
    this._element.classList.remove(CLASS_NAME_HIDE);
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE);
      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };
    this._element.classList.add(CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }
    super.dispose();
  }
  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  }
  // Private
  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case "mouseover":
      case "mouseout": {
        this._hasMouseInteraction = isInteracting;
        break;
      }
      case "focusin":
      case "focusout": {
        this._hasKeyboardInteraction = isInteracting;
        break;
      }
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data = _Toast.getOrCreateInstance(this, config2);
      if (typeof config2 === "string") {
        if (typeof data[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data[config2](this);
      }
    });
  }
};
enableDismissTrigger(Toast);
defineJQueryPlugin(Toast);

// app/javascript/custom/gantt_chart.js
var import_dhtmlxgantt = __toESM(require_dhtmlxgantt());
console.log("Hello from gantt_chart.js");
gantt.plugins({
  tooltip: true
});
gantt.templates.tooltip_text = function(start3, end2, task) {
  return task.tool_tip_text;
};
gantt.config.scales = [
  { unit: "month", step: 1, format: "%F, %Y" },
  { unit: "day", step: 1, format: "%D - %j" },
  { unit: "hour", step: 1, date: "%H:%i" }
];
gantt.config.columns = [
  { name: "text", label: "Task name", width: 150, resize: true, tree: true },
  { name: "start_date", label: "Start Time", align: "center", resize: true, width: 160 },
  { name: "end_date", label: "End Time", align: "center", resize: true, width: 160 },
  { name: "log_messages", label: "Log Messages", align: "center", resize: true, width: 100 }
];
gantt.config.scale_height = 54;
gantt.config.drag_links = false;
gantt.config.drag_progress = false;
gantt.config.drag_resize = false;
gantt.config.drag_move = false;
gantt.config.readonly = true;
gantt.config.date_grid = "%Y-%m-%d %H:%i:%s";
gantt.setSkin("dark");

// app/javascript/application.js
document.addEventListener("turbo:load", function() {
  const elements = document.getElementsByClassName("nav-link");
  for (let i = 0; i < elements.length; i++) {
    elements[i].addEventListener("click", navButtonClick);
  }
  ;
  function navButtonClick(event) {
    console.log("clicked");
    console.log(event.target);
  }
});
/** @license

dhtmlxGantt v.9.0.4 Standard

This version of dhtmlxGantt is distributed under GPL 2.0 license and can be legally used in GPL projects.

To use dhtmlxGantt in non-GPL projects (and get Pro version of the product), please obtain Individual, Commercial, Enterprise or Ultimate license on our site https://dhtmlx.com/docs/products/dhtmlxGantt/#licensing or contact us at info@dhtmlx.com

(c) XB Software

*/
/*! Bundled license information:

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.12
  Copyright  2024 37signals LLC
   *)

bootstrap/dist/js/bootstrap.esm.js:
  (*!
    * Bootstrap v5.3.3 (https://getbootstrap.com/)
    * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)
*/
//# sourceMappingURL=/assets/application-46155ab5.js.map
